{
  "tasks": {
    "Knn": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nextern \"C\" {\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) {\n\n#pragma HLS interface s_axilite port = in_0 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_0); }\n\n#pragma HLS interface s_axilite port = in_1 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_1); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_1); }\n\n#pragma HLS interface s_axilite port = in_2 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_2); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_2); }\n\n#pragma HLS interface s_axilite port = in_3 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_3); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_3); }\n\n#pragma HLS interface s_axilite port = in_4 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_4); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_4); }\n\n#pragma HLS interface s_axilite port = in_5 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_5); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_5); }\n\n#pragma HLS interface s_axilite port = in_6 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_6); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_6); }\n\n#pragma HLS interface s_axilite port = in_7 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_7); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_7); }\n\n#pragma HLS interface s_axilite port = in_8 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_8); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_8); }\n\n#pragma HLS interface s_axilite port = in_9 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_9); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_9); }\n\n#pragma HLS interface s_axilite port = in_10 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_10); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_10); }\n\n#pragma HLS interface s_axilite port = in_11 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_11); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_11); }\n\n#pragma HLS interface s_axilite port = in_12 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_12); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_12); }\n\n#pragma HLS interface s_axilite port = in_13 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_13); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_13); }\n\n#pragma HLS interface s_axilite port = in_14 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_14); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_14); }\n\n#pragma HLS interface s_axilite port = in_15 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_15); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_15); }\n\n#pragma HLS interface s_axilite port = in_16 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_16); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_16); }\n\n#pragma HLS interface s_axilite port = in_17 bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_17); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(in_17); }\n\n#pragma HLS interface s_axilite port = L3_out_dist bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(L3_out_dist); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(L3_out_dist); }\n\n#pragma HLS interface s_axilite port = L3_out_id bundle = control\n{ auto val = reinterpret_cast<volatile uint8_t&>(L3_out_id); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(L3_out_id); }\n\n\n#pragma HLS interface s_axilite port = return bundle = control\n}\n\n\n}  // extern \"C\"\n\n",
      "fifos": {
        "L1_out_dist[0]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            0
          ]
        },
        "L1_out_dist[1]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            1
          ]
        },
        "L1_out_dist[2]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            2
          ]
        },
        "L1_out_dist[3]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            3
          ]
        },
        "L1_out_dist[4]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            4
          ]
        },
        "L1_out_dist[5]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            5
          ]
        },
        "L1_out_id[0]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            0
          ]
        },
        "L1_out_id[1]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            1
          ]
        },
        "L1_out_id[2]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            6
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            2
          ]
        },
        "L1_out_id[3]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            3
          ]
        },
        "L1_out_id[4]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            4
          ]
        },
        "L1_out_id[5]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            7
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            5
          ]
        },
        "L2_out_dist0": {
          "consumed_by": [
            "krnl_globalSort_L3",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            6
          ]
        },
        "L2_out_dist1": {
          "consumed_by": [
            "krnl_globalSort_L3",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            7
          ]
        },
        "L2_out_id0": {
          "consumed_by": [
            "krnl_globalSort_L3",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            6
          ]
        },
        "L2_out_id1": {
          "consumed_by": [
            "krnl_globalSort_L3",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_globalSort_L1_L2",
            7
          ]
        },
        "out_dist[0]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_0",
            0
          ]
        },
        "out_dist[10]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_10",
            0
          ]
        },
        "out_dist[11]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_11",
            0
          ]
        },
        "out_dist[12]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_12",
            0
          ]
        },
        "out_dist[13]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_13",
            0
          ]
        },
        "out_dist[14]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_14",
            0
          ]
        },
        "out_dist[15]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_15",
            0
          ]
        },
        "out_dist[16]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_16",
            0
          ]
        },
        "out_dist[17]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_17",
            0
          ]
        },
        "out_dist[1]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_1",
            0
          ]
        },
        "out_dist[2]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_2",
            0
          ]
        },
        "out_dist[3]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_3",
            0
          ]
        },
        "out_dist[4]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_4",
            0
          ]
        },
        "out_dist[5]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_5",
            0
          ]
        },
        "out_dist[6]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_6",
            0
          ]
        },
        "out_dist[7]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_7",
            0
          ]
        },
        "out_dist[8]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_8",
            0
          ]
        },
        "out_dist[9]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_9",
            0
          ]
        },
        "out_id[0]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_0",
            0
          ]
        },
        "out_id[10]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_10",
            0
          ]
        },
        "out_id[11]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_11",
            0
          ]
        },
        "out_id[12]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_12",
            0
          ]
        },
        "out_id[13]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_13",
            0
          ]
        },
        "out_id[14]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            4
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_14",
            0
          ]
        },
        "out_id[15]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_15",
            0
          ]
        },
        "out_id[16]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_16",
            0
          ]
        },
        "out_id[17]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            5
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_17",
            0
          ]
        },
        "out_id[1]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_1",
            0
          ]
        },
        "out_id[2]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            0
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_2",
            0
          ]
        },
        "out_id[3]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_3",
            0
          ]
        },
        "out_id[4]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_4",
            0
          ]
        },
        "out_id[5]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            1
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_5",
            0
          ]
        },
        "out_id[6]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_6",
            0
          ]
        },
        "out_id[7]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_7",
            0
          ]
        },
        "out_id[8]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            2
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_8",
            0
          ]
        },
        "out_id[9]": {
          "consumed_by": [
            "krnl_globalSort_L1_L2",
            3
          ],
          "depth": 2,
          "produced_by": [
            "krnl_partialKnn_wrapper_9",
            0
          ]
        }
      },
      "frt_interface": "#include <sstream>\n#include <stdexcept>\n#include <frt.h>\n\n#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  tapa::mmap<INTERFACE_WIDTH> in_0,\n  tapa::mmap<INTERFACE_WIDTH> in_1,\n  tapa::mmap<INTERFACE_WIDTH> in_2,\n  tapa::mmap<INTERFACE_WIDTH> in_3,\n  tapa::mmap<INTERFACE_WIDTH> in_4,\n  tapa::mmap<INTERFACE_WIDTH> in_5,\n  tapa::mmap<INTERFACE_WIDTH> in_6,\n  tapa::mmap<INTERFACE_WIDTH> in_7,\n  tapa::mmap<INTERFACE_WIDTH> in_8,\n  tapa::mmap<INTERFACE_WIDTH> in_9,\n  tapa::mmap<INTERFACE_WIDTH> in_10,\n  tapa::mmap<INTERFACE_WIDTH> in_11,\n  tapa::mmap<INTERFACE_WIDTH> in_12,\n  tapa::mmap<INTERFACE_WIDTH> in_13,\n  tapa::mmap<INTERFACE_WIDTH> in_14,\n  tapa::mmap<INTERFACE_WIDTH> in_15,\n  tapa::mmap<INTERFACE_WIDTH> in_16,\n  tapa::mmap<INTERFACE_WIDTH> in_17,\n  tapa::mmap<float> L3_out_dist,\n  tapa::mmap<int> L3_out_id\n) {\n#define TAPAB_APP \"TAPAB_Knn\"\n#define TAPAB \"TAPAB\"\n  const char* _tapa_bitstream = nullptr;\n  if ((_tapa_bitstream = getenv(TAPAB_APP)) ||\n      (_tapa_bitstream = getenv(TAPAB))) {\n    fpga::Instance _tapa_instance(_tapa_bitstream);\n    int _tapa_arg_index = 0;\n    for (const auto& _tapa_arg_info : _tapa_instance.GetArgsInfo()) {\n      if (false) {\n      } else if (_tapa_arg_info.name == \"in_0\") {\n        auto _tapa_arg = fpga::ReadWrite(in_0.get(), in_0.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_1\") {\n        auto _tapa_arg = fpga::ReadWrite(in_1.get(), in_1.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_2\") {\n        auto _tapa_arg = fpga::ReadWrite(in_2.get(), in_2.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_3\") {\n        auto _tapa_arg = fpga::ReadWrite(in_3.get(), in_3.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_4\") {\n        auto _tapa_arg = fpga::ReadWrite(in_4.get(), in_4.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_5\") {\n        auto _tapa_arg = fpga::ReadWrite(in_5.get(), in_5.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_6\") {\n        auto _tapa_arg = fpga::ReadWrite(in_6.get(), in_6.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_7\") {\n        auto _tapa_arg = fpga::ReadWrite(in_7.get(), in_7.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_8\") {\n        auto _tapa_arg = fpga::ReadWrite(in_8.get(), in_8.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_9\") {\n        auto _tapa_arg = fpga::ReadWrite(in_9.get(), in_9.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_10\") {\n        auto _tapa_arg = fpga::ReadWrite(in_10.get(), in_10.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_11\") {\n        auto _tapa_arg = fpga::ReadWrite(in_11.get(), in_11.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_12\") {\n        auto _tapa_arg = fpga::ReadWrite(in_12.get(), in_12.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_13\") {\n        auto _tapa_arg = fpga::ReadWrite(in_13.get(), in_13.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_14\") {\n        auto _tapa_arg = fpga::ReadWrite(in_14.get(), in_14.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_15\") {\n        auto _tapa_arg = fpga::ReadWrite(in_15.get(), in_15.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_16\") {\n        auto _tapa_arg = fpga::ReadWrite(in_16.get(), in_16.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"in_17\") {\n        auto _tapa_arg = fpga::ReadWrite(in_17.get(), in_17.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"L3_out_dist\") {\n        auto _tapa_arg = fpga::ReadWrite(L3_out_dist.get(), L3_out_dist.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else if (_tapa_arg_info.name == \"L3_out_id\") {\n        auto _tapa_arg = fpga::ReadWrite(L3_out_id.get(), L3_out_id.size());\n        _tapa_instance.SetArg(_tapa_arg_index, _tapa_arg);\n      } else {\n        std::stringstream ss;\n        ss << \"unknown argument: \" << _tapa_arg_info;\n        throw std::runtime_error(ss.str());\n      }\n      ++_tapa_arg_index;\n    }\n    _tapa_instance.WriteToDevice();\n    _tapa_instance.Exec();\n    _tapa_instance.ReadFromDevice();\n    _tapa_instance.Finish();\n  } else {\n    throw std::runtime_error(\"no bitstream found; please set `\" TAPAB_APP\n                             \"` or `\" TAPAB \"`\");\n  }\n}\n",
      "level": "upper",
      "ports": [
        {
          "cat": "mmap",
          "name": "in_0",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_1",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_2",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_3",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_4",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_5",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_6",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_7",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_8",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_9",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_10",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_11",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_12",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_13",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_14",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_15",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_16",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "in_17",
          "type": "ap_uint<IWIDTH>*",
          "width": 256
        },
        {
          "cat": "mmap",
          "name": "L3_out_dist",
          "type": "float*",
          "width": 32
        },
        {
          "cat": "mmap",
          "name": "L3_out_id",
          "type": "int*",
          "width": 32
        }
      ],
      "target": "hls",
      "tasks": {
        "krnl_globalSort_L1_L2": [
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[0]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[1]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[2]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[0]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[1]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[2]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[0]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[0]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[3]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[4]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[5]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[3]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[4]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[5]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[1]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[1]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[6]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[7]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[8]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[6]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[7]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[8]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[2]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[2]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[9]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[10]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[11]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[9]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[10]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[11]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[3]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[3]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[12]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[13]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[14]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[12]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[13]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[14]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[4]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[4]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "out_dist[15]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "out_dist[16]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "out_dist[17]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "out_id[15]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "out_id[16]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "out_id[17]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L1_out_dist[5]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L1_out_id[5]",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "L1_out_dist[0]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "L1_out_dist[1]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "L1_out_dist[2]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "L1_out_id[0]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "L1_out_id[1]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "L1_out_id[2]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L2_out_dist0",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L2_out_id0",
                "cat": "ostream"
              }
            },
            "step": 0
          },
          {
            "args": {
              "in_dist0": {
                "arg": "L1_out_dist[3]",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "L1_out_dist[4]",
                "cat": "istream"
              },
              "in_dist2": {
                "arg": "L1_out_dist[5]",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "L1_out_id[3]",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "L1_out_id[4]",
                "cat": "istream"
              },
              "in_id2": {
                "arg": "L1_out_id[5]",
                "cat": "istream"
              },
              "out_dist": {
                "arg": "L2_out_dist1",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "L2_out_id1",
                "cat": "ostream"
              }
            },
            "step": 0
          }
        ],
        "krnl_globalSort_L3": [
          {
            "args": {
              "in_dist0": {
                "arg": "L2_out_dist0",
                "cat": "istream"
              },
              "in_dist1": {
                "arg": "L2_out_dist1",
                "cat": "istream"
              },
              "in_id0": {
                "arg": "L2_out_id0",
                "cat": "istream"
              },
              "in_id1": {
                "arg": "L2_out_id1",
                "cat": "istream"
              },
              "output_knnDist": {
                "arg": "L3_out_dist",
                "cat": "async_mmap"
              },
              "output_knnId": {
                "arg": "L3_out_id",
                "cat": "async_mmap"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_0": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[0]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[0]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_0",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd0",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_1": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[1]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[1]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_1",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd1048576",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_10": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[10]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[10]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_10",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd10485760",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_11": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[11]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[11]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_11",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd11534336",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_12": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[12]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[12]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_12",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd12582912",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_13": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[13]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[13]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_13",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd13631488",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_14": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[14]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[14]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_14",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd14680064",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_15": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[15]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[15]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_15",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd15728640",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_16": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[16]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[16]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_16",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd16777216",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_17": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[17]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[17]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_17",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd17825792",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_2": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[2]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[2]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_2",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd2097152",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_3": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[3]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[3]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_3",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd3145728",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_4": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[4]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[4]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_4",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd4194304",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_5": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[5]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[5]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_5",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd5242880",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_6": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[6]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[6]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_6",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd6291456",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_7": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[7]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[7]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_7",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd7340032",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_8": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[8]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[8]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_8",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd8388608",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ],
        "krnl_partialKnn_wrapper_9": [
          {
            "args": {
              "out_dist": {
                "arg": "out_dist[9]",
                "cat": "ostream"
              },
              "out_id": {
                "arg": "out_id[9]",
                "cat": "ostream"
              },
              "searchSpace_0": {
                "arg": "in_9",
                "cat": "async_mmap"
              },
              "start_id_0": {
                "arg": "64'd9437184",
                "cat": "scalar"
              }
            },
            "step": 0
          }
        ]
      },
      "vendor": "xilinx"
    },
    "krnl_globalSort_L1_L2": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) {\n#pragma HLS disaggregate variable = in_dist0\n#pragma HLS interface ap_fifo port = in_dist0._\n#pragma HLS aggregate variable = in_dist0._ bit\n#pragma HLS interface ap_fifo port = in_dist0._peek\n#pragma HLS aggregate variable = in_dist0._peek bit\nvoid(in_dist0._.empty());\nvoid(in_dist0._peek.empty());\n\n#pragma HLS disaggregate variable = in_id0\n#pragma HLS interface ap_fifo port = in_id0._\n#pragma HLS aggregate variable = in_id0._ bit\n#pragma HLS interface ap_fifo port = in_id0._peek\n#pragma HLS aggregate variable = in_id0._peek bit\nvoid(in_id0._.empty());\nvoid(in_id0._peek.empty());\n\n#pragma HLS disaggregate variable = in_dist1\n#pragma HLS interface ap_fifo port = in_dist1._\n#pragma HLS aggregate variable = in_dist1._ bit\n#pragma HLS interface ap_fifo port = in_dist1._peek\n#pragma HLS aggregate variable = in_dist1._peek bit\nvoid(in_dist1._.empty());\nvoid(in_dist1._peek.empty());\n\n#pragma HLS disaggregate variable = in_id1\n#pragma HLS interface ap_fifo port = in_id1._\n#pragma HLS aggregate variable = in_id1._ bit\n#pragma HLS interface ap_fifo port = in_id1._peek\n#pragma HLS aggregate variable = in_id1._peek bit\nvoid(in_id1._.empty());\nvoid(in_id1._peek.empty());\n\n#pragma HLS disaggregate variable = in_dist2\n#pragma HLS interface ap_fifo port = in_dist2._\n#pragma HLS aggregate variable = in_dist2._ bit\n#pragma HLS interface ap_fifo port = in_dist2._peek\n#pragma HLS aggregate variable = in_dist2._peek bit\nvoid(in_dist2._.empty());\nvoid(in_dist2._peek.empty());\n\n#pragma HLS disaggregate variable = in_id2\n#pragma HLS interface ap_fifo port = in_id2._\n#pragma HLS aggregate variable = in_id2._ bit\n#pragma HLS interface ap_fifo port = in_id2._peek\n#pragma HLS aggregate variable = in_id2._peek bit\nvoid(in_id2._.empty());\nvoid(in_id2._peek.empty());\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n\n    DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial complete dim=0\n    int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial complete dim=0\n\n    DATA_TYPE output_dist[TOP];\n    #pragma HLS ARRAY_PARTITION variable=output_dist complete\n    int output_id[TOP];\n    #pragma HLS ARRAY_PARTITION variable=output_id complete\n\n    for (unsigned int i=0; i<TOP; ++i) {\n    #pragma HLS PIPELINE II=1\n      pkt v0 = in_dist0.read();\n      STREAM_WIDTH v0_item = v0.data.range(DATA_TYPE_TOTAL_SZ-1, 0);\n      local_kNearstDist_partial[0][i] = *((DATA_TYPE*)(&v0_item));\n      pkt v1 = in_dist1.read();\n      STREAM_WIDTH v1_item = v1.data.range(DATA_TYPE_TOTAL_SZ-1, 0);\n      local_kNearstDist_partial[1][i] = *((DATA_TYPE*)(&v1_item));\n      pkt v2 = in_dist2.read();\n      STREAM_WIDTH v2_item = v2.data.range(DATA_TYPE_TOTAL_SZ-1, 0);\n      local_kNearstDist_partial[2][i] = *((DATA_TYPE*)(&v2_item));\n    }\n\n    for (unsigned int i=0; i<TOP; ++i) {\n    #pragma HLS PIPELINE II=1\n      id_pkt v0_id = in_id0.read();\n      local_kNearstId_partial[0][i] = v0_id.data;\n      id_pkt v1_id = in_id1.read();\n      local_kNearstId_partial[1][i] = v1_id.data;\n      id_pkt v2_id = in_id2.read();\n      local_kNearstId_partial[2][i] = v2_id.data;\n    }\n\n    seq_global_merge_L1_L2(local_kNearstDist_partial, local_kNearstId_partial, output_dist, output_id);\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 0; i < TOP; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = output_dist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 0; i < TOP; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = output_id[i];\n        out_id.write(v_id);\n    }\n\n}\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_globalSort_L3": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::async_mmap<DATA_TYPE>& output_knnDist,   // Output Result\n    tapa::async_mmap<int>& output_knnId            // Output Result\n) {\n#pragma HLS disaggregate variable = in_dist0\n#pragma HLS interface ap_fifo port = in_dist0._\n#pragma HLS aggregate variable = in_dist0._ bit\n#pragma HLS interface ap_fifo port = in_dist0._peek\n#pragma HLS aggregate variable = in_dist0._peek bit\nvoid(in_dist0._.empty());\nvoid(in_dist0._peek.empty());\n\n#pragma HLS disaggregate variable = in_id0\n#pragma HLS interface ap_fifo port = in_id0._\n#pragma HLS aggregate variable = in_id0._ bit\n#pragma HLS interface ap_fifo port = in_id0._peek\n#pragma HLS aggregate variable = in_id0._peek bit\nvoid(in_id0._.empty());\nvoid(in_id0._peek.empty());\n\n#pragma HLS disaggregate variable = in_dist1\n#pragma HLS interface ap_fifo port = in_dist1._\n#pragma HLS aggregate variable = in_dist1._ bit\n#pragma HLS interface ap_fifo port = in_dist1._peek\n#pragma HLS aggregate variable = in_dist1._peek bit\nvoid(in_dist1._.empty());\nvoid(in_dist1._peek.empty());\n\n#pragma HLS disaggregate variable = in_id1\n#pragma HLS interface ap_fifo port = in_id1._\n#pragma HLS aggregate variable = in_id1._ bit\n#pragma HLS interface ap_fifo port = in_id1._peek\n#pragma HLS aggregate variable = in_id1._peek bit\nvoid(in_id1._.empty());\nvoid(in_id1._peek.empty());\n\n#pragma HLS disaggregate variable = output_knnDist\n#pragma HLS interface ap_fifo port = output_knnDist.read_addr._\n#pragma HLS aggregate variable = output_knnDist.read_addr._  bit\n#pragma HLS interface ap_fifo port = output_knnDist.read_data._\n#pragma HLS aggregate variable = output_knnDist.read_data._  bit\n#pragma HLS interface ap_fifo port = output_knnDist.write_addr._\n#pragma HLS aggregate variable = output_knnDist.write_addr._  bit\n#pragma HLS interface ap_fifo port = output_knnDist.write_data._\n#pragma HLS aggregate variable = output_knnDist.write_data._  bit\n#pragma HLS interface ap_fifo port = output_knnDist.write_resp._\n#pragma HLS aggregate variable = output_knnDist.write_resp._  bit\n#pragma HLS disaggregate variable = output_knnDist .read_data\n#pragma HLS interface ap_fifo port = output_knnDist.read_data._peek\n#pragma HLS aggregate variable = output_knnDist.read_data._peek bit\n#pragma HLS disaggregate variable = output_knnDist .write_resp\n#pragma HLS interface ap_fifo port = output_knnDist.write_resp._peek\n#pragma HLS aggregate variable = output_knnDist.write_resp._peek bit\nvoid(output_knnDist.read_addr._.full());\nvoid(output_knnDist.read_data._.empty());\nvoid(output_knnDist.read_data._peek.empty());\nvoid(output_knnDist.write_addr._.full());\nvoid(output_knnDist.write_data._.full());\nvoid(output_knnDist.write_resp._.empty());\nvoid(output_knnDist.write_resp._peek.empty());\n\n#pragma HLS disaggregate variable = output_knnId\n#pragma HLS interface ap_fifo port = output_knnId.read_addr._\n#pragma HLS aggregate variable = output_knnId.read_addr._  bit\n#pragma HLS interface ap_fifo port = output_knnId.read_data._\n#pragma HLS aggregate variable = output_knnId.read_data._  bit\n#pragma HLS interface ap_fifo port = output_knnId.write_addr._\n#pragma HLS aggregate variable = output_knnId.write_addr._  bit\n#pragma HLS interface ap_fifo port = output_knnId.write_data._\n#pragma HLS aggregate variable = output_knnId.write_data._  bit\n#pragma HLS interface ap_fifo port = output_knnId.write_resp._\n#pragma HLS aggregate variable = output_knnId.write_resp._  bit\n#pragma HLS disaggregate variable = output_knnId .read_data\n#pragma HLS interface ap_fifo port = output_knnId.read_data._peek\n#pragma HLS aggregate variable = output_knnId.read_data._peek bit\n#pragma HLS disaggregate variable = output_knnId .write_resp\n#pragma HLS interface ap_fifo port = output_knnId.write_resp._peek\n#pragma HLS aggregate variable = output_knnId.write_resp._peek bit\nvoid(output_knnId.read_addr._.full());\nvoid(output_knnId.read_data._.empty());\nvoid(output_knnId.read_data._peek.empty());\nvoid(output_knnId.write_addr._.full());\nvoid(output_knnId.write_data._.full());\nvoid(output_knnId.write_resp._.empty());\nvoid(output_knnId.write_resp._peek.empty());\n\n\n    DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial complete dim=0\n    int local_kNearstId_partial[NUM_KERNEL_L3][TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial complete dim=0\n\n    DATA_TYPE output_dist[TOP];\n    #pragma HLS ARRAY_PARTITION variable=output_dist complete\n    int output_id[TOP];\n    #pragma HLS ARRAY_PARTITION variable=output_id complete\n\n    for (unsigned int i=0; i<TOP; ++i) {\n    #pragma HLS PIPELINE II=1\n      pkt v0 = in_dist0.read();\n      STREAM_WIDTH v0_item = v0.data.range(DATA_TYPE_TOTAL_SZ-1, 0);\n      local_kNearstDist_partial[0][i] = *((DATA_TYPE*)(&v0_item));\n      pkt v1 = in_dist1.read();\n      STREAM_WIDTH v1_item = v1.data.range(DATA_TYPE_TOTAL_SZ-1, 0);\n      local_kNearstDist_partial[1][i] = *((DATA_TYPE*)(&v1_item));\n    }\n\n    for (unsigned int i=0; i<TOP; ++i) {\n    #pragma HLS PIPELINE II=1\n      id_pkt v0_id = in_id0.read();\n      local_kNearstId_partial[0][i] = v0_id.data;\n      id_pkt v1_id = in_id1.read();\n      local_kNearstId_partial[1][i] = v1_id.data;\n    }\n\n    seq_global_merge_L3(local_kNearstDist_partial, local_kNearstId_partial, output_dist, output_id);\n\nfor (unsigned int i_req_dist = 0, i_resp_dist = 0, i_req_id = 0, i_resp_id = 0; i_resp_dist < TOP || i_resp_id < TOP; ) {\n      #pragma HLS pipeline II=1\n\n      // write to output_KnnDist\n      if (i_req_dist < TOP &&\n          !output_knnDist.write_addr.full() &&\n          !output_knnDist.write_data.full()\n      ) {\n        output_knnDist.write_addr.try_write(i_req_dist);\n        output_knnDist.write_data.try_write(output_dist[i_req_dist]);\n\n        ++i_req_dist;\n      }\n\n      if (!output_knnDist.write_resp.empty()) {\n        i_resp_dist += (unsigned int)(output_knnDist.write_resp.read(nullptr)) + 1;\n      }\n\n      // write to output_KnnId\n      if (i_req_id < TOP &&\n          !output_knnId.write_addr.full() &&\n          !output_knnId.write_data.full()\n      ) {\n        output_knnId.write_addr.try_write(i_req_id);\n        output_knnId.write_data.try_write(output_id[i_req_id]);\n\n        ++i_req_id;\n      }\n\n      if (!output_knnId.write_resp.empty()) {\n        i_resp_id += (unsigned int)(output_knnId.write_resp.read(nullptr)) + 1;\n      }\n\n    }\n}\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_0": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<0>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_1": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<1>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_10": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<10>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_11": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<11>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_12": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<12>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_13": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<13>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_14": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<14>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_15": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<15>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_16": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<16>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_17": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<17>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_2": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<2>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_3": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<3>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_4": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<4>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_5": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<5>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_6": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<6>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_7": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<7>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_8": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<8>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_9(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    },
    "krnl_partialKnn_wrapper_9": {
      "code": "#include \"ap_int.h\"\n#include \"ap_axi_sdata.h\"\n#include <tapa.h>\n#include <inttypes.h>\n#include <stdlib.h>\n\n\nconst int IWIDTH = 256;\n#define INTERFACE_WIDTH ap_uint<IWIDTH>\n#define INPUT_DIM (2)\n#define TOP (10)\n#define NUM_SP_PTS (1048576)\n#define DISTANCE_METRIC (1)\n#define NUM_PE (1)\n#define NUM_KERNEL_L1_L2 (3)\n#define NUM_KERNEL_L3 (2)\n\n#define DATA_TYPE_TOTAL_SZ 32\n#define DATA_TYPE float\n#define LOCAL_DIST_SZ   (32)\n#define LOCAL_DIST_DTYPE float\n#define TRANSFER_TYPE ap_uint<DATA_TYPE_TOTAL_SZ>\n\n/***************************************************************/\n\n#define BUFFER_SIZE_PADDED (1048576)\n#define NUM_SP_PTS_PADDED (1048576)\n\n// NOTE: Each of the below calculations are effectively a ceil() operation.\n//      Ex: (x-1)/y + 1 is ceil(x/y).\n// L2I = Local to Interface\nconst int L2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * LOCAL_DIST_SZ)) + 1;\n// D2L = Data_Type to Local\nconst int D2L_FACTOR_W = ((LOCAL_DIST_SZ - 1)/ (DATA_TYPE_TOTAL_SZ)) + 1;\n// D2I = Data_Type to Interface\nconst int D2I_FACTOR_W = ((IWIDTH - 1) / (INPUT_DIM * DATA_TYPE_TOTAL_SZ)) + 1;\n// I2D = Interface to Data_type\nconst int I2D_FACTOR_W = ((INPUT_DIM * DATA_TYPE_TOTAL_SZ - 1) / (IWIDTH)) + 1;\n#define NUM_OF_TILES (64)\n#define TILE_LEN_IN_I (BUFFER_SIZE_PADDED / IWIDTH)\n#define TILE_LEN_IN_D (BUFFER_SIZE_PADDED / (INPUT_DIM * DATA_TYPE_TOTAL_SZ))\n#define TILE_LEN_IN_L (BUFFER_SIZE_PADDED / (INPUT_DIM * LOCAL_DIST_SZ))\n// // DEBUG NOTE: BW_FACTOR = 0.7698287024216459\n#define USING_LTYPES 1\n#define PARALLEL_SORT (1)\n#define PARALLEL_SORT_FACTOR (L2I_FACTOR_W * 2)\n#define USING_CAT_CMP 0\n\nconst int SWIDTH = DATA_TYPE_TOTAL_SZ;\ntypedef ap_axiu<SWIDTH, 0, 0, 0> pkt;\ntypedef ap_axiu<32, 0, 0, 0>    id_pkt;\n#define STREAM_WIDTH ap_uint<SWIDTH>\n\nconst int NUM_FEATURES_PER_READ = (IWIDTH/DATA_TYPE_TOTAL_SZ);\nconst int QUERY_FEATURE_RESERVE = (128);\n#define QUERY_DATA_RESERVE (QUERY_FEATURE_RESERVE / NUM_FEATURES_PER_READ)\n#define MAX_DATA_TYPE_VAL (3.402823e+38f)\n#define FLOOR_SQRT_MAX_DATA_TYPE_VAL (1.8446742e+19f)\n\n// We name each sub-array of the local_distance arrays a \"segment\".\n#define NUM_SEGMENTS PARALLEL_SORT_FACTOR\n\n#define SEGMENT_SIZE_IN_L (2048)\n#define SEGMENT_SIZE_IN_D (SEGMENT_SIZE_IN_L*D2L_FACTOR_W)\n\nconst int __NUM_PADDED_SEGMENTS = (1 + ((NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L) / SEGMENT_SIZE_IN_L));\nconst int SEGMENT_IDX_START_OF_PADDING = (NUM_SEGMENTS - __NUM_PADDED_SEGMENTS);\nconst int LVALUE_IDX_START_OF_PADDING = (TILE_LEN_IN_L % SEGMENT_SIZE_IN_L);\n\n\nconst int NUM_ITERATIONS = 1;\n#define NUM_PART (1)\n\n\nstatic inline DATA_TYPE absval(DATA_TYPE input){\n    return (input > 0 ? input : static_cast<DATA_TYPE>(-1*input));\n}\n\nbool compare_with_register(DATA_TYPE in_1, DATA_TYPE in_2){\n#pragma HLS pipeline\n#pragma HLS inline off\n#pragma HLS LATENCY min=2 max=2\n    return in_1 < in_2;\n}\n\n/*************************************************/\n/******************** LOADS: *********************/\n/*************************************************/\n\nvoid load(int flag, int tile_idx, INTERFACE_WIDTH* local_SP, tapa::async_mmap<INTERFACE_WIDTH>& searchSpace)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        for (int i_req = 0, i_resp = 0; i_resp < TILE_LEN_IN_I; ) {\n          #pragma HLS pipeline II=1\n          int addr = QUERY_DATA_RESERVE + tile_idx*TILE_LEN_IN_I + i_req;\n          if (i_req < TILE_LEN_IN_I && searchSpace.read_addr.try_write(addr)) {\n            i_req++;\n          }\n          if (!searchSpace.read_data.empty()) {\n            local_SP[i_resp] = searchSpace.read_data.read(nullptr);\n            i_resp++;\n          }\n        }\n    }\n}\n\n/*************************************************/\n/******************* COMPUTES: *******************/\n/*************************************************/\n\nvoid compute(int flag, DATA_TYPE* local_Query, INTERFACE_WIDTH* local_SP,\n        LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n        int debug_i)\n{\n#pragma HLS INLINE OFF\n    if (flag){\n        int SP_idx = 0;\n        for (int ii = 0 ; ii < NUM_SEGMENTS; ++ii){\n            for (int jj = 0; jj < SEGMENT_SIZE_IN_D/D2I_FACTOR_W; ++jj){\n#pragma HLS PIPELINE II=1\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n                SP_idx = ii * SEGMENT_SIZE_IN_D/D2I_FACTOR_W + jj;\n                int TEMP_DEBUG_INT = 0;\n\n                for (int kk = 0; kk < D2I_FACTOR_W; ++kk){\n                #pragma HLS UNROLL\n\n                    DATA_TYPE delta_squared_sum = 0.0;\n                    unsigned int dist_range_idx =  (kk % D2L_FACTOR_W) * DATA_TYPE_TOTAL_SZ;\n                    int start_idx = kk * INPUT_DIM;\n\n                    for (int ll = 0; ll < INPUT_DIM; ++ll){\n                        unsigned int sp_range_idx = (start_idx + ll) * DATA_TYPE_TOTAL_SZ;\n\n                        DATA_TYPE sp_dim_item_value;\n                        TRANSFER_TYPE tmp;\n\n                        tmp.range(DATA_TYPE_TOTAL_SZ-1, 0) =\n                            local_SP[SP_idx].range(sp_range_idx + (DATA_TYPE_TOTAL_SZ-1),\n                                                   sp_range_idx);\n\n                        sp_dim_item_value = *((DATA_TYPE*) (&tmp));\n\n#if DISTANCE_METRIC == 0 // manhattan\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta;\n#elif DISTANCE_METRIC == 1 // L2\n                        // NOTE(Kenny): I think this absval will help unsigned payloads.\n                        DATA_TYPE delta = absval(sp_dim_item_value - local_Query[ll]);\n                        delta_squared_sum += delta * delta;\n#endif\n                    }\n                    aggregated_local_dists = delta_squared_sum;\n\n                    if ((kk % D2L_FACTOR_W) == D2L_FACTOR_W - 1){\n                        unsigned int inner_idx_location = (jj*D2I_FACTOR_W + kk) / D2L_FACTOR_W;\n                        local_distance[ii][inner_idx_location] = aggregated_local_dists;\n                        aggregated_local_dists = 0;\n                    }\n                }\n            }\n        }\n    }\n}\nvoid swap(DATA_TYPE* a, DATA_TYPE* b,\n               int* x, int* y)\n{\n#pragma HLS INLINE\n\n    DATA_TYPE tmpdist_a;\n    DATA_TYPE tmpdist_b;\n\n    int tmpid_x;\n    int tmpid_y;\n\n    tmpdist_a = *a;\n    tmpdist_b = *b;\n    *b = tmpdist_a;\n    *a = tmpdist_b;\n\n    tmpid_x = *x;\n    tmpid_y = *y;\n    *x = tmpid_y;\n    *y = tmpid_x;\n}\nvoid para_partial_sort(LOCAL_DIST_DTYPE* local_distance,\n                            int start_id,\n                            DATA_TYPE local_kNearstDist[D2L_FACTOR_W][TOP+1],\n                            int local_kNearstId[D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n    for (int i = 0; i < (SEGMENT_SIZE_IN_L+TOP)*D2L_FACTOR_W; ++i) {\n    #pragma HLS PIPELINE II=2\n    #pragma HLS UNROLL FACTOR=D2L_FACTOR_W\n\n        LOCAL_DIST_DTYPE cur_Lval = local_distance[i/D2L_FACTOR_W];\n        unsigned char D_idx = i%D2L_FACTOR_W;\n        unsigned char range_idx = (D_idx)*DATA_TYPE_TOTAL_SZ;\n        DATA_TYPE cur_Dval;\n\n        cur_Dval = cur_Lval;\n\n        local_kNearstDist[D_idx][0] = cur_Dval;\n        local_kNearstId[D_idx][0] = start_id + i;\n\n\n        //compare and swap odd\n        for(int ii=1; ii<TOP; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii], local_kNearstDist[D_idx][ii+1]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii+1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii+1]);\n            }\n\n        }\n\n\n        //compare and swap even\n        for(int ii=1; ii<TOP+1; ii+=2){\n        #pragma HLS UNROLL\n        #pragma HLS DEPENDENCE variable=\"local_kNearstDist\" inter false\n        #pragma HLS DEPENDENCE variable=\"local_kNearstId\" inter false\n            bool fcmp = compare_with_register(local_kNearstDist[D_idx][ii-1], local_kNearstDist[D_idx][ii]);\n            if (fcmp){\n                swap(&local_kNearstDist[D_idx][ii], &local_kNearstDist[D_idx][ii-1],\n                          &local_kNearstId[D_idx][ii], &local_kNearstId[D_idx][ii-1]);\n            }\n\n        }\n    }\n}\nvoid sort(int flag, int start_id,\n          LOCAL_DIST_DTYPE local_distance[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP],\n\t\t  DATA_TYPE local_kNearstDist_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1],\n          int local_kNearstId_partial [NUM_SEGMENTS][D2L_FACTOR_W][TOP+1])\n{\n#pragma HLS INLINE OFF\n\tif (flag){\n\t\tint starting_id[NUM_SEGMENTS];\n\t\t#pragma HLS ARRAY_PARTITION variable=starting_id complete dim=0\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tstarting_id[i] = start_id+i*SEGMENT_SIZE_IN_D;\n\t\t}\n\n        // overwrite invalid sections of the local_distnace array that are only there because\n        //  we cant perfectly \"segment\" our tiles\n\t\tfor (int i = 0; i < (NUM_SEGMENTS * SEGMENT_SIZE_IN_L - TILE_LEN_IN_L)%SEGMENT_SIZE_IN_L; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t#pragma HLS UNROLL FACTOR=L2I_FACTOR_W\n            DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n            LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n            for (int k = 0; k < D2L_FACTOR_W; ++k){\n                aggregated_local_dists = maxval;\n            }\n\n            local_distance[SEGMENT_IDX_START_OF_PADDING][LVALUE_IDX_START_OF_PADDING+i] =\n                aggregated_local_dists;\n\t\t}\n\n        #if (NUM_SEGMENTS - 1) != SEGMENT_IDX_START_OF_PADDING\n        for (int outer_idx = SEGMENT_IDX_START_OF_PADDING+1; outer_idx < NUM_SEGMENTS; ++outer_idx){\n            for (int i = 0; i < SEGMENT_SIZE_IN_L; i++){\n\t\t    #pragma HLS PIPELINE II=1\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance[outer_idx][i] =\n                    aggregated_local_dists;\n            }\n        }\n        #endif\n\n\t\tfor (unsigned char i = 0; i < NUM_SEGMENTS; ++i){\n\t\t#pragma HLS UNROLL\n\t\t\tpara_partial_sort(local_distance[i],\n\t\t\t\t   starting_id[i],\n\t\t\t\t   local_kNearstDist_partial[i],\n\t\t\t\t   local_kNearstId_partial[i]);\n\t\t}\n\t}\n\t/*\n\telse{\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\t}\n\t*/\n}\nvoid merge_dual(DATA_TYPE local_kNearstDist_partial_a[TOP+1],\n                DATA_TYPE local_kNearstDist_partial_b[TOP+1],\n                int local_kNearstId_partial_a[TOP+1],\n                int local_kNearstId_partial_b[TOP+1],\n                DATA_TYPE dist[TOP+1], int id[TOP+1])\n{\n    // Process only TWO segments TOPs, instead of all of them.\n    int idx_a = TOP;\n    int idx_b = TOP;\n\n    /*********************/\n\n    for (int i = TOP; i >= 0; --i)\n    {\n        if (local_kNearstDist_partial_a[idx_a] < local_kNearstDist_partial_b[idx_b])\n        {\n            dist[i] = local_kNearstDist_partial_a[idx_a];\n            id[i] = local_kNearstId_partial_a[idx_a];\n            --idx_a;\n        }\n        else\n        {\n            dist[i] = local_kNearstDist_partial_b[idx_b];\n            id[i] = local_kNearstId_partial_b[idx_b];\n            --idx_b;\n        }\n    }\n}\n\nvoid merge_dual_all_PEs(DATA_TYPE local_kNearstDist_partial_a[NUM_PART][TOP+1],\n                        DATA_TYPE local_kNearstDist_partial_b[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_a[NUM_PART][TOP+1],\n                        int local_kNearstId_partial_b[NUM_PART][TOP+1],\n                        DATA_TYPE dist[NUM_PART][TOP+1], int id[NUM_PART][TOP+1])\n{\n    for (int i = 0; i < NUM_PART; ++i)\n    {\n    #pragma HLS UNROLL\n        merge_dual(local_kNearstDist_partial_a[i],\n                   local_kNearstDist_partial_b[i],\n                   local_kNearstId_partial_a  [i],\n                   local_kNearstId_partial_b  [i],\n                   dist[i],\n                   id[i]);\n    }\n}\n\ntemplate <int id>\nvoid krnl_partialKnn(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n    #pragma HLS inline\n\n    DATA_TYPE local_Query_0[INPUT_DIM];\n    #pragma HLS ARRAY_PARTITION variable=local_Query_0 complete dim=1\n    INTERFACE_WIDTH local_SP_0_A[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_A core=XPM_MEMORY uram\n    INTERFACE_WIDTH local_SP_0_B[TILE_LEN_IN_I];\n    #pragma HLS RESOURCE variable=local_SP_0_B core=XPM_MEMORY uram\n\n    LOCAL_DIST_DTYPE local_distance_0_A[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_A cyclic factor=L2I_FACTOR_W dim=2\n    LOCAL_DIST_DTYPE local_distance_0_B[NUM_SEGMENTS][SEGMENT_SIZE_IN_L+TOP];\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B complete dim=1\n    #pragma HLS ARRAY_PARTITION variable=local_distance_0_B cyclic factor=L2I_FACTOR_W dim=2\n\n    // These are the outputs of the sort() function.\n    //  Together, they contain the nearest (distance, ID) pairs for each segment of all tiles.\n    static DATA_TYPE local_kNearstDist_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist_partial_0 complete dim=0\n    static int local_kNearstId_partial_0[NUM_SEGMENTS][D2L_FACTOR_W][(TOP+1)];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId_partial_0 complete dim=0\n\n    // These store the top K results for each PE.\n    DATA_TYPE local_kNearstDist[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstDist complete dim=0\n    int local_kNearstId[NUM_PART][TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=local_kNearstId complete dim=0\n\n    // These store the top K results for this KERNEL.\n    DATA_TYPE global_kNearstDist[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstDist complete\n    int global_kNearstId[TOP+1];\n    #pragma HLS ARRAY_PARTITION variable=global_kNearstId complete\n\n    LOAD_QUERY: for (int i_req = 0, i_resp = 0; i_resp < INPUT_DIM;){\n        #pragma HLS pipeline II=1\n        // issue read address\n        int input_rd_idx = i_req / NUM_FEATURES_PER_READ;\n        if (i_req < INPUT_DIM && searchSpace_0.read_addr.try_write(input_rd_idx)) {\n          ++i_req;\n        }\n\n        // get read response\n        if (! searchSpace_0.read_data.empty()) {\n          INTERFACE_WIDTH resp = searchSpace_0.read_data.read(nullptr);\n          int range_idx = i_resp % NUM_FEATURES_PER_READ;\n          TRANSFER_TYPE tmp;\n          tmp.range(DATA_TYPE_TOTAL_SZ - 1, 0)\n              = resp.range(range_idx*DATA_TYPE_TOTAL_SZ + (DATA_TYPE_TOTAL_SZ-1),\n                                                          range_idx*DATA_TYPE_TOTAL_SZ);\n          local_Query_0[i_resp] = *((DATA_TYPE*)(&tmp));\n\n          i_resp++;\n        }\n    }\n\n    ITERATION_LOOP: for (int it_idx = 0; it_idx < NUM_ITERATIONS; ++it_idx)\n    {\n        for (int i = 0; i < NUM_SEGMENTS; ++i){\n            for (int j = 0; j < TOP; ++j){\n            #pragma HLS PIPELINE II=1\n\n                DATA_TYPE maxval = MAX_DATA_TYPE_VAL;\n                LOCAL_DIST_DTYPE aggregated_local_dists = 0;\n\n                // Overwrite local_distance, chunk by chunk.\n                for (int k = 0; k < D2L_FACTOR_W; ++k){\n                    aggregated_local_dists = maxval;\n                }\n\n                local_distance_0_A[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n                local_distance_0_B[i][SEGMENT_SIZE_IN_L+j] = aggregated_local_dists;\n            }\n        }\n\n\t\tfor (int i = 0; i < NUM_SEGMENTS; ++i){\n\t\t\tfor (int j = 0; j < D2L_FACTOR_W; ++j){\n                for (int k = 0; k < TOP+1; ++k){\n\t\t\t    #pragma HLS UNROLL\n\t\t\t    \tlocal_kNearstId_partial_0[i][j][k] = -1;\n\t\t\t        local_kNearstDist_partial_0[i][j][k] = MAX_DATA_TYPE_VAL;\n\t\t\t    }\n            }\n\t\t}\n\n        for(int i = 0; i < NUM_OF_TILES+2; ++i){\n            int load_img_flag = i >= 0 && i < NUM_OF_TILES;\n            int compute_flag = i >= 1 && i < NUM_OF_TILES + 1;\n            int sort_flag = i >= 2 && i < NUM_OF_TILES + 2;\n            if (i % 2 == 0) {\n                load(load_img_flag, i, local_SP_0_A, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_B, local_distance_0_B, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_A, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n            else {\n                load(load_img_flag, i, local_SP_0_B, searchSpace_0);\n                compute(compute_flag, local_Query_0, local_SP_0_A, local_distance_0_A, i);\n                sort(sort_flag, start_id_0+(i-2)*TILE_LEN_IN_D, local_distance_0_B, local_kNearstDist_partial_0, local_kNearstId_partial_0);\n            }\n        }\n        /**********************************************************************/\n        /**************************  MERGING PARTIAL SORTS ********************/\n        /**********************************************************************/\n        DATA_TYPE temp_kNearstDist[NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstDist complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstDist core=RAM_1P_LUTRAM\n        int       temp_kNearstId  [NUM_SEGMENTS][D2L_FACTOR_W*2][NUM_PART][TOP+1];\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=1\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=2\n        #pragma HLS ARRAY_PARTITION variable=temp_kNearstId complete dim=3\n        #pragma HLS RESOURCE variable=temp_kNearstId core=RAM_1P_LUTRAM\n\n        for (int i = 0; i < NUM_SEGMENTS; ++i)\n        {\n        #pragma HLS unroll\n            for (int j = 0; j < D2L_FACTOR_W; ++j)\n            {\n            #pragma HLS unroll\n                for (int k = 0; k < TOP+1; ++k)\n                {\n                #pragma HLS unroll\n                    temp_kNearstDist[i][j][0][k] = local_kNearstDist_partial_0[i][j][k];\n                    temp_kNearstId  [i][j][0][k] = local_kNearstId_partial_0  [i][j][k];\n\n                }\n            }\n        }\n\n        /*********************************************/\n        /* Merge pairwise on the NUM_SEGMENTS-level. */\n        /*********************************************/\n\n        for (int i = 0; i < 4; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][0],\n                               temp_kNearstDist[i*2 + 1][0],\n                               temp_kNearstId  [i*2 + 0][0],\n                               temp_kNearstId  [i*2 + 1][0],\n                               temp_kNearstDist[i][D2L_FACTOR_W],\n                               temp_kNearstId  [i][D2L_FACTOR_W]);\n        }\n        for (int i = 0; i < 2; ++i){\n        #pragma HLS unroll\n            merge_dual_all_PEs(temp_kNearstDist[i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstDist[i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 0][D2L_FACTOR_W],\n                               temp_kNearstId  [i*2 + 1][D2L_FACTOR_W],\n                               temp_kNearstDist[i][0],\n                               temp_kNearstId  [i][0]);\n        }\n        for (int i = 0; i < NUM_PART; ++i)\n        {\n        #pragma HLS UNROLL\n            merge_dual(temp_kNearstDist[0][0][i],\n                       temp_kNearstDist[1][0][i],\n                       temp_kNearstId  [0][0][i],\n                       temp_kNearstId  [1][0][i],\n                       local_kNearstDist[i],\n                       local_kNearstId  [i]);\n        }\n\n        // Copy the data to the global buffer.\n        for (int j = 0; j < TOP+1; ++j){\n            global_kNearstDist[j] = local_kNearstDist[0][j];\n            global_kNearstId[j] = local_kNearstId[0][j];\n        }\n    }\n\n    STREAM_WIDTH v_data;\n    DATA_TYPE temp_data;\n    DIST_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        temp_data = global_kNearstDist[i];\n\n        v_data = *((STREAM_WIDTH*)(&temp_data));\n\n        pkt v;\n        v.data = v_data;\n        out_dist.write(v);\n    }\n    ID_OUT: for (int i = 1; i < TOP+1; ++i)\n    {\n    #pragma HLS PIPELINE II=1\n        id_pkt v_id;\n        v_id.data = global_kNearstId[i];\n        out_id.write(v_id);\n    }\n    return;\n}\n\n\n\nvoid krnl_partialKnn_wrapper_0(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_1(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_2(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_3(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_4(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_5(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_6(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_7(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_8(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_9(\n    tapa::async_mmap<INTERFACE_WIDTH>& searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n{\n#pragma HLS disaggregate variable = searchSpace_0\n#pragma HLS interface ap_fifo port = searchSpace_0.read_addr._\n#pragma HLS aggregate variable = searchSpace_0.read_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._\n#pragma HLS aggregate variable = searchSpace_0.read_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_addr._\n#pragma HLS aggregate variable = searchSpace_0.write_addr._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_data._\n#pragma HLS aggregate variable = searchSpace_0.write_data._  bit\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._\n#pragma HLS aggregate variable = searchSpace_0.write_resp._  bit\n#pragma HLS disaggregate variable = searchSpace_0 .read_data\n#pragma HLS interface ap_fifo port = searchSpace_0.read_data._peek\n#pragma HLS aggregate variable = searchSpace_0.read_data._peek bit\n#pragma HLS disaggregate variable = searchSpace_0 .write_resp\n#pragma HLS interface ap_fifo port = searchSpace_0.write_resp._peek\n#pragma HLS aggregate variable = searchSpace_0.write_resp._peek bit\nvoid(searchSpace_0.read_addr._.full());\nvoid(searchSpace_0.read_data._.empty());\nvoid(searchSpace_0.read_data._peek.empty());\nvoid(searchSpace_0.write_addr._.full());\nvoid(searchSpace_0.write_data._.full());\nvoid(searchSpace_0.write_resp._.empty());\nvoid(searchSpace_0.write_resp._peek.empty());\n\n\n#pragma HLS disaggregate variable = out_dist\n#pragma HLS interface ap_fifo port = out_dist._\n#pragma HLS aggregate variable = out_dist._ bit\nvoid(out_dist._.full());\n\n#pragma HLS disaggregate variable = out_id\n#pragma HLS interface ap_fifo port = out_id._\n#pragma HLS aggregate variable = out_id._ bit\nvoid(out_id._.full());\n\n  krnl_partialKnn<9>(searchSpace_0, start_id_0, out_dist, out_id);\n}\n\n\nvoid krnl_partialKnn_wrapper_10(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_11(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_12(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_13(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_14(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_15(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_16(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\nvoid krnl_partialKnn_wrapper_17(\n    uint64_t  searchSpace_0,\n    int start_id_0,\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id)\n;\n\n\n// L1 & L2 Global Merge - 3 stream pairs : 1 stream pair\nvoid seq_global_merge_L1_L2(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L1_L2][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L1_L2][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L1_L2];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L1_L2; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L1_L2; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L1_L2(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    tapa::istream<pkt> &in_dist2,    // Internal Stream\n    tapa::istream<id_pkt> &in_id2,    // Internal Stream\n    tapa::ostream<pkt> &out_dist,\n    tapa::ostream<id_pkt> &out_id\n) ;\n\n// L3 Global Merge - 2 stream pairs : 1 mmap pair\nvoid seq_global_merge_L3(DATA_TYPE local_kNearstDist_partial[NUM_KERNEL_L3][TOP],\n                        int local_kNearstId_partial[NUM_KERNEL_L3][TOP],\n                        DATA_TYPE* dist, int* id)\n{\n#pragma HLS INLINE OFF\n    int idx[NUM_KERNEL_L3];\n    #pragma HLS ARRAY_PARTITION variable=idx complete dim=0\n    for (int i = 0; i < NUM_KERNEL_L3; ++i)\n    {\n    #pragma HLS UNROLL\n        idx[i] = TOP-1;\n    }\n    for (int i = TOP-1; i >= 0; --i)\n    {\n        DATA_TYPE min_value = MAX_DATA_TYPE_VAL;\n        int min_idx = -1;\n        for (int j = 0; j < NUM_KERNEL_L3; ++j)\n        {\n        #pragma HLS PIPELINE II=1\n            if (local_kNearstDist_partial[j][idx[j]] < min_value){\n                min_value = local_kNearstDist_partial[j][idx[j]];\n                min_idx = j;\n            }\n        }\n        dist[i] = min_value;\n        id[i] = local_kNearstId_partial[min_idx][idx[min_idx]];\n        idx[min_idx] = idx[min_idx] - 1;\n    }\n}\n\nvoid krnl_globalSort_L3(\n    tapa::istream<pkt> &in_dist0,    // Internal Stream\n    tapa::istream<id_pkt> &in_id0,    // Internal Stream\n    tapa::istream<pkt> &in_dist1,    // Internal Stream\n    tapa::istream<id_pkt> &in_id1,    // Internal Stream\n    uint64_t  output_knnDist,   // Output Result\n    uint64_t  output_knnId            // Output Result\n) ;\n\nvoid Knn(\n  uint64_t  in_0,\n  uint64_t  in_1,\n  uint64_t  in_2,\n  uint64_t  in_3,\n  uint64_t  in_4,\n  uint64_t  in_5,\n  uint64_t  in_6,\n  uint64_t  in_7,\n  uint64_t  in_8,\n  uint64_t  in_9,\n  uint64_t  in_10,\n  uint64_t  in_11,\n  uint64_t  in_12,\n  uint64_t  in_13,\n  uint64_t  in_14,\n  uint64_t  in_15,\n  uint64_t  in_16,\n  uint64_t  in_17,\n  uint64_t  L3_out_dist,\n  uint64_t  L3_out_id\n) ;\n",
      "level": "lower",
      "target": "hls",
      "vendor": "xilinx"
    }
  },
  "top": "Knn",
  "cflags": [
    "-std=c++17"
  ]
}