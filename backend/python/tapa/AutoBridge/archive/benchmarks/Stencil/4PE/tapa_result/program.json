{
  "tasks": {
    "compute": {
      "code": "#include<float.h>\n#include<math.h>\n#include<stdbool.h>\n#include<stddef.h>\n#include<stdint.h>\n#include<stdio.h>\n#include<string.h>\n#include \"ap_int.h\"\n#include <tlp.h>\n\n#define BURST_WIDTH 512\n#define UNROLL_FACTOR 64\n#define TILE_SIZE_DIM_0 8000\n#ifndef BURST_WIDTH\n#define BURST_WIDTH 512\n#endif//BURST_WIDTH\n\n#if UNROLL_FACTOR != 64\n#error UNROLL_FACTOR != 64\n#endif//UNROLL_FACTOR != 64\n#if TILE_SIZE_DIM_0 != 8000\n#error TILE_SIZE_DIM_0 != 8000\n#endif//TILE_SIZE_DIM_0 != 8000\n#if BURST_WIDTH != 512\n#error BURST_WIDTH != 512\n#endif//BURST_WIDTH != 512\n\n\n\n\n\nvoid compute(\n    tlp::ostream<ap_uint<BURST_WIDTH> >& to_chan_0_bank_0,\n    tlp::ostream<ap_uint<BURST_WIDTH> >& to_chan_0_bank_1,\n    tlp::ostream<ap_uint<BURST_WIDTH> >& to_chan_0_bank_2,\n    tlp::ostream<ap_uint<BURST_WIDTH> >& to_chan_0_bank_3,\n    tlp::istream<ap_uint<BURST_WIDTH> >& from_chan_0_bank_0,\n    tlp::istream<ap_uint<BURST_WIDTH> >& from_chan_0_bank_1,\n    tlp::istream<ap_uint<BURST_WIDTH> >& from_chan_0_bank_2,\n    tlp::istream<ap_uint<BURST_WIDTH> >& from_chan_0_bank_3,\n    int64_t coalesced_data_num,\n    int64_t tile_data_num,\n    int32_t tile_num_dim_0,\n    int32_t input_size_dim_0,\n    int32_t input_size_dim_1)\n{\n#pragma HLS data_pack variable = to_chan_0_bank_0.fifo\n#pragma HLS data_pack variable = to_chan_0_bank_1.fifo\n#pragma HLS data_pack variable = to_chan_0_bank_2.fifo\n#pragma HLS data_pack variable = to_chan_0_bank_3.fifo\n#pragma HLS data_pack variable = from_chan_0_bank_0.fifo\n#pragma HLS data_pack variable = from_chan_0_bank_0.peek_val\n#pragma HLS data_pack variable = from_chan_0_bank_1.fifo\n#pragma HLS data_pack variable = from_chan_0_bank_1.peek_val\n#pragma HLS data_pack variable = from_chan_0_bank_2.fifo\n#pragma HLS data_pack variable = from_chan_0_bank_2.peek_val\n#pragma HLS data_pack variable = from_chan_0_bank_3.fifo\n#pragma HLS data_pack variable = from_chan_0_bank_3.peek_val\n\n\n    int32_t tile_index_dim_0 = 0;\n\n    // reuse chains for t1\n    float FF_t1_chan_0[2];\n    float FIFO_125_t1_chan_0[126][125];\n    float FIFO_124_t1_chan_0[2][124];\n#pragma HLS array_partition variable=FF_t1_chan_0 complete\n#pragma HLS resource variable=FF_t1_chan_0 latency=1\n#pragma HLS array_partition variable=FIFO_125_t1_chan_0 complete dim=1\n#pragma HLS array_partition variable=FIFO_124_t1_chan_0 complete dim=1\n\n    uint8_t FIFO_125_t1_ptr = 0;\n    uint8_t FIFO_124_t1_ptr = 0;\n\n    // points aliases for t1\n    float points_from_t1_to_t0_chan_0[UNROLL_FACTOR][5];\n    //    points_from_t1_to_t0_chan_x[UNROLL_FACTOR][0] <=> t1[x](1, 0)\n    //    points_from_t1_to_t0_chan_x[UNROLL_FACTOR][1] <=> t1[x](0, 1)\n    //    points_from_t1_to_t0_chan_x[UNROLL_FACTOR][2] <=> t1[x](1, 1)\n    //    points_from_t1_to_t0_chan_x[UNROLL_FACTOR][3] <=> t1[x](2, 1)\n    //    points_from_t1_to_t0_chan_x[UNROLL_FACTOR][4] <=> t1[x](1, 2)\n#pragma HLS array_partition variable=points_from_t1_to_t0_chan_0 complete dim=0\n\n    // input buffer\n    float buffer_t1_chan_0[UNROLL_FACTOR];\n#pragma HLS array_partition variable=buffer_t1_chan_0 complete dim=0\n#pragma HLS resource variable=buffer_t1_chan_0 latency=1\n\n    // intermediate buffer for t1\n    // output buffer\n    float buffer_t0_chan_0[UNROLL_FACTOR];\n#pragma HLS array_partition variable=buffer_t0_chan_0 complete dim=0\n#pragma HLS resource variable=buffer_t0_chan_0 latency=1\n\n    // produce output\ncompute_epoch:\n    for(int32_t epoch = 0; epoch < coalesced_data_num*1; ++epoch)\n    {\n#pragma HLS dependence variable=FF_t1_chan_0 inter false\n#pragma HLS dependence variable=FIFO_125_t1_chan_0 inter false\n#pragma HLS dependence variable=FIFO_124_t1_chan_0 inter false\n#pragma HLS pipeline II=1\n        {\n            ap_uint<BURST_WIDTH> tmp_chan_0_bank_0, tmp_chan_0_bank_1, tmp_chan_0_bank_2, tmp_chan_0_bank_3;\n            tmp_chan_0_bank_0 = from_chan_0_bank_0.read();\n            tmp_chan_0_bank_1 = from_chan_0_bank_1.read();\n            tmp_chan_0_bank_2 = from_chan_0_bank_2.read();\n            tmp_chan_0_bank_3 = from_chan_0_bank_3.read();\nload_coalesced:\n            for(int j = 0; j < BURST_WIDTH/32; ++j)\n            {\n#pragma HLS unroll\n                uint32_t raw_bits_chan_0_bank_0 = tmp_chan_0_bank_0((j+1)*32-1, j*32);\n                buffer_t1_chan_0[BURST_WIDTH/32*4*0+j*4+0] = *(float*)(&raw_bits_chan_0_bank_0);\n                uint32_t raw_bits_chan_0_bank_1 = tmp_chan_0_bank_1((j+1)*32-1, j*32);\n                buffer_t1_chan_0[BURST_WIDTH/32*4*0+j*4+1] = *(float*)(&raw_bits_chan_0_bank_1);\n                uint32_t raw_bits_chan_0_bank_2 = tmp_chan_0_bank_2((j+1)*32-1, j*32);\n                buffer_t1_chan_0[BURST_WIDTH/32*4*0+j*4+2] = *(float*)(&raw_bits_chan_0_bank_2);\n                uint32_t raw_bits_chan_0_bank_3 = tmp_chan_0_bank_3((j+1)*32-1, j*32);\n                buffer_t1_chan_0[BURST_WIDTH/32*4*0+j*4+3] = *(float*)(&raw_bits_chan_0_bank_3);\n            }\n        }\n\n        float& FIFO_125_t1_chan_0_fifo_0 = FIFO_125_t1_chan_0[0][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_1 = FIFO_125_t1_chan_0[1][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_2 = FIFO_125_t1_chan_0[2][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_3 = FIFO_125_t1_chan_0[3][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_4 = FIFO_125_t1_chan_0[4][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_5 = FIFO_125_t1_chan_0[5][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_6 = FIFO_125_t1_chan_0[6][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_7 = FIFO_125_t1_chan_0[7][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_8 = FIFO_125_t1_chan_0[8][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_9 = FIFO_125_t1_chan_0[9][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_10 = FIFO_125_t1_chan_0[10][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_11 = FIFO_125_t1_chan_0[11][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_12 = FIFO_125_t1_chan_0[12][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_13 = FIFO_125_t1_chan_0[13][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_14 = FIFO_125_t1_chan_0[14][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_15 = FIFO_125_t1_chan_0[15][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_16 = FIFO_125_t1_chan_0[16][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_17 = FIFO_125_t1_chan_0[17][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_18 = FIFO_125_t1_chan_0[18][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_19 = FIFO_125_t1_chan_0[19][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_20 = FIFO_125_t1_chan_0[20][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_21 = FIFO_125_t1_chan_0[21][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_22 = FIFO_125_t1_chan_0[22][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_23 = FIFO_125_t1_chan_0[23][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_24 = FIFO_125_t1_chan_0[24][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_25 = FIFO_125_t1_chan_0[25][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_26 = FIFO_125_t1_chan_0[26][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_27 = FIFO_125_t1_chan_0[27][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_28 = FIFO_125_t1_chan_0[28][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_29 = FIFO_125_t1_chan_0[29][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_30 = FIFO_125_t1_chan_0[30][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_31 = FIFO_125_t1_chan_0[31][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_32 = FIFO_125_t1_chan_0[32][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_33 = FIFO_125_t1_chan_0[33][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_34 = FIFO_125_t1_chan_0[34][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_35 = FIFO_125_t1_chan_0[35][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_36 = FIFO_125_t1_chan_0[36][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_37 = FIFO_125_t1_chan_0[37][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_38 = FIFO_125_t1_chan_0[38][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_39 = FIFO_125_t1_chan_0[39][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_40 = FIFO_125_t1_chan_0[40][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_41 = FIFO_125_t1_chan_0[41][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_42 = FIFO_125_t1_chan_0[42][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_43 = FIFO_125_t1_chan_0[43][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_44 = FIFO_125_t1_chan_0[44][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_45 = FIFO_125_t1_chan_0[45][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_46 = FIFO_125_t1_chan_0[46][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_47 = FIFO_125_t1_chan_0[47][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_48 = FIFO_125_t1_chan_0[48][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_49 = FIFO_125_t1_chan_0[49][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_50 = FIFO_125_t1_chan_0[50][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_51 = FIFO_125_t1_chan_0[51][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_52 = FIFO_125_t1_chan_0[52][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_53 = FIFO_125_t1_chan_0[53][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_54 = FIFO_125_t1_chan_0[54][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_55 = FIFO_125_t1_chan_0[55][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_56 = FIFO_125_t1_chan_0[56][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_57 = FIFO_125_t1_chan_0[57][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_58 = FIFO_125_t1_chan_0[58][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_59 = FIFO_125_t1_chan_0[59][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_60 = FIFO_125_t1_chan_0[60][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_61 = FIFO_125_t1_chan_0[61][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_62 = FIFO_125_t1_chan_0[62][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_63 = FIFO_125_t1_chan_0[63][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_64 = FIFO_125_t1_chan_0[64][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_65 = FIFO_125_t1_chan_0[65][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_66 = FIFO_125_t1_chan_0[66][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_67 = FIFO_125_t1_chan_0[67][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_68 = FIFO_125_t1_chan_0[68][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_69 = FIFO_125_t1_chan_0[69][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_70 = FIFO_125_t1_chan_0[70][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_71 = FIFO_125_t1_chan_0[71][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_72 = FIFO_125_t1_chan_0[72][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_73 = FIFO_125_t1_chan_0[73][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_74 = FIFO_125_t1_chan_0[74][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_75 = FIFO_125_t1_chan_0[75][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_76 = FIFO_125_t1_chan_0[76][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_77 = FIFO_125_t1_chan_0[77][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_78 = FIFO_125_t1_chan_0[78][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_79 = FIFO_125_t1_chan_0[79][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_80 = FIFO_125_t1_chan_0[80][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_81 = FIFO_125_t1_chan_0[81][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_82 = FIFO_125_t1_chan_0[82][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_83 = FIFO_125_t1_chan_0[83][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_84 = FIFO_125_t1_chan_0[84][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_85 = FIFO_125_t1_chan_0[85][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_86 = FIFO_125_t1_chan_0[86][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_87 = FIFO_125_t1_chan_0[87][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_88 = FIFO_125_t1_chan_0[88][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_89 = FIFO_125_t1_chan_0[89][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_90 = FIFO_125_t1_chan_0[90][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_91 = FIFO_125_t1_chan_0[91][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_92 = FIFO_125_t1_chan_0[92][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_93 = FIFO_125_t1_chan_0[93][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_94 = FIFO_125_t1_chan_0[94][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_95 = FIFO_125_t1_chan_0[95][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_96 = FIFO_125_t1_chan_0[96][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_97 = FIFO_125_t1_chan_0[97][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_98 = FIFO_125_t1_chan_0[98][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_99 = FIFO_125_t1_chan_0[99][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_100 = FIFO_125_t1_chan_0[100][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_101 = FIFO_125_t1_chan_0[101][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_102 = FIFO_125_t1_chan_0[102][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_103 = FIFO_125_t1_chan_0[103][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_104 = FIFO_125_t1_chan_0[104][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_105 = FIFO_125_t1_chan_0[105][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_106 = FIFO_125_t1_chan_0[106][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_107 = FIFO_125_t1_chan_0[107][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_108 = FIFO_125_t1_chan_0[108][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_109 = FIFO_125_t1_chan_0[109][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_110 = FIFO_125_t1_chan_0[110][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_111 = FIFO_125_t1_chan_0[111][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_112 = FIFO_125_t1_chan_0[112][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_113 = FIFO_125_t1_chan_0[113][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_114 = FIFO_125_t1_chan_0[114][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_115 = FIFO_125_t1_chan_0[115][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_116 = FIFO_125_t1_chan_0[116][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_117 = FIFO_125_t1_chan_0[117][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_118 = FIFO_125_t1_chan_0[118][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_119 = FIFO_125_t1_chan_0[119][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_120 = FIFO_125_t1_chan_0[120][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_121 = FIFO_125_t1_chan_0[121][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_122 = FIFO_125_t1_chan_0[122][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_123 = FIFO_125_t1_chan_0[123][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_124 = FIFO_125_t1_chan_0[124][FIFO_125_t1_ptr];\n        float& FIFO_125_t1_chan_0_fifo_125 = FIFO_125_t1_chan_0[125][FIFO_125_t1_ptr];\n        float& FIFO_124_t1_chan_0_fifo_0 = FIFO_124_t1_chan_0[0][FIFO_124_t1_ptr];\n        float& FIFO_124_t1_chan_0_fifo_1 = FIFO_124_t1_chan_0[1][FIFO_124_t1_ptr];\n\n        points_from_t1_to_t0_chan_0[0][4] = buffer_t1_chan_0[0]; // t1[0](1, 2) @ unroll_index=0\n        points_from_t1_to_t0_chan_0[1][4] = buffer_t1_chan_0[1]; // t1[0](1, 2) @ unroll_index=1\n        points_from_t1_to_t0_chan_0[2][4] = buffer_t1_chan_0[2]; // t1[0](1, 2) @ unroll_index=2\n        points_from_t1_to_t0_chan_0[3][4] = buffer_t1_chan_0[3]; // t1[0](1, 2) @ unroll_index=3\n        points_from_t1_to_t0_chan_0[4][4] = buffer_t1_chan_0[4]; // t1[0](1, 2) @ unroll_index=4\n        points_from_t1_to_t0_chan_0[5][4] = buffer_t1_chan_0[5]; // t1[0](1, 2) @ unroll_index=5\n        points_from_t1_to_t0_chan_0[6][4] = buffer_t1_chan_0[6]; // t1[0](1, 2) @ unroll_index=6\n        points_from_t1_to_t0_chan_0[7][4] = buffer_t1_chan_0[7]; // t1[0](1, 2) @ unroll_index=7\n        points_from_t1_to_t0_chan_0[8][4] = buffer_t1_chan_0[8]; // t1[0](1, 2) @ unroll_index=8\n        points_from_t1_to_t0_chan_0[9][4] = buffer_t1_chan_0[9]; // t1[0](1, 2) @ unroll_index=9\n        points_from_t1_to_t0_chan_0[10][4] = buffer_t1_chan_0[10]; // t1[0](1, 2) @ unroll_index=10\n        points_from_t1_to_t0_chan_0[11][4] = buffer_t1_chan_0[11]; // t1[0](1, 2) @ unroll_index=11\n        points_from_t1_to_t0_chan_0[12][4] = buffer_t1_chan_0[12]; // t1[0](1, 2) @ unroll_index=12\n        points_from_t1_to_t0_chan_0[13][4] = buffer_t1_chan_0[13]; // t1[0](1, 2) @ unroll_index=13\n        points_from_t1_to_t0_chan_0[14][4] = buffer_t1_chan_0[14]; // t1[0](1, 2) @ unroll_index=14\n        points_from_t1_to_t0_chan_0[15][4] = buffer_t1_chan_0[15]; // t1[0](1, 2) @ unroll_index=15\n        points_from_t1_to_t0_chan_0[16][4] = buffer_t1_chan_0[16]; // t1[0](1, 2) @ unroll_index=16\n        points_from_t1_to_t0_chan_0[17][4] = buffer_t1_chan_0[17]; // t1[0](1, 2) @ unroll_index=17\n        points_from_t1_to_t0_chan_0[18][4] = buffer_t1_chan_0[18]; // t1[0](1, 2) @ unroll_index=18\n        points_from_t1_to_t0_chan_0[19][4] = buffer_t1_chan_0[19]; // t1[0](1, 2) @ unroll_index=19\n        points_from_t1_to_t0_chan_0[20][4] = buffer_t1_chan_0[20]; // t1[0](1, 2) @ unroll_index=20\n        points_from_t1_to_t0_chan_0[21][4] = buffer_t1_chan_0[21]; // t1[0](1, 2) @ unroll_index=21\n        points_from_t1_to_t0_chan_0[22][4] = buffer_t1_chan_0[22]; // t1[0](1, 2) @ unroll_index=22\n        points_from_t1_to_t0_chan_0[23][4] = buffer_t1_chan_0[23]; // t1[0](1, 2) @ unroll_index=23\n        points_from_t1_to_t0_chan_0[24][4] = buffer_t1_chan_0[24]; // t1[0](1, 2) @ unroll_index=24\n        points_from_t1_to_t0_chan_0[25][4] = buffer_t1_chan_0[25]; // t1[0](1, 2) @ unroll_index=25\n        points_from_t1_to_t0_chan_0[26][4] = buffer_t1_chan_0[26]; // t1[0](1, 2) @ unroll_index=26\n        points_from_t1_to_t0_chan_0[27][4] = buffer_t1_chan_0[27]; // t1[0](1, 2) @ unroll_index=27\n        points_from_t1_to_t0_chan_0[28][4] = buffer_t1_chan_0[28]; // t1[0](1, 2) @ unroll_index=28\n        points_from_t1_to_t0_chan_0[29][4] = buffer_t1_chan_0[29]; // t1[0](1, 2) @ unroll_index=29\n        points_from_t1_to_t0_chan_0[30][4] = buffer_t1_chan_0[30]; // t1[0](1, 2) @ unroll_index=30\n        points_from_t1_to_t0_chan_0[31][4] = buffer_t1_chan_0[31]; // t1[0](1, 2) @ unroll_index=31\n        points_from_t1_to_t0_chan_0[32][4] = buffer_t1_chan_0[32]; // t1[0](1, 2) @ unroll_index=32\n        points_from_t1_to_t0_chan_0[33][4] = buffer_t1_chan_0[33]; // t1[0](1, 2) @ unroll_index=33\n        points_from_t1_to_t0_chan_0[34][4] = buffer_t1_chan_0[34]; // t1[0](1, 2) @ unroll_index=34\n        points_from_t1_to_t0_chan_0[35][4] = buffer_t1_chan_0[35]; // t1[0](1, 2) @ unroll_index=35\n        points_from_t1_to_t0_chan_0[36][4] = buffer_t1_chan_0[36]; // t1[0](1, 2) @ unroll_index=36\n        points_from_t1_to_t0_chan_0[37][4] = buffer_t1_chan_0[37]; // t1[0](1, 2) @ unroll_index=37\n        points_from_t1_to_t0_chan_0[38][4] = buffer_t1_chan_0[38]; // t1[0](1, 2) @ unroll_index=38\n        points_from_t1_to_t0_chan_0[39][4] = buffer_t1_chan_0[39]; // t1[0](1, 2) @ unroll_index=39\n        points_from_t1_to_t0_chan_0[40][4] = buffer_t1_chan_0[40]; // t1[0](1, 2) @ unroll_index=40\n        points_from_t1_to_t0_chan_0[41][4] = buffer_t1_chan_0[41]; // t1[0](1, 2) @ unroll_index=41\n        points_from_t1_to_t0_chan_0[42][4] = buffer_t1_chan_0[42]; // t1[0](1, 2) @ unroll_index=42\n        points_from_t1_to_t0_chan_0[43][4] = buffer_t1_chan_0[43]; // t1[0](1, 2) @ unroll_index=43\n        points_from_t1_to_t0_chan_0[44][4] = buffer_t1_chan_0[44]; // t1[0](1, 2) @ unroll_index=44\n        points_from_t1_to_t0_chan_0[45][4] = buffer_t1_chan_0[45]; // t1[0](1, 2) @ unroll_index=45\n        points_from_t1_to_t0_chan_0[46][4] = buffer_t1_chan_0[46]; // t1[0](1, 2) @ unroll_index=46\n        points_from_t1_to_t0_chan_0[47][4] = buffer_t1_chan_0[47]; // t1[0](1, 2) @ unroll_index=47\n        points_from_t1_to_t0_chan_0[48][4] = buffer_t1_chan_0[48]; // t1[0](1, 2) @ unroll_index=48\n        points_from_t1_to_t0_chan_0[49][4] = buffer_t1_chan_0[49]; // t1[0](1, 2) @ unroll_index=49\n        points_from_t1_to_t0_chan_0[50][4] = buffer_t1_chan_0[50]; // t1[0](1, 2) @ unroll_index=50\n        points_from_t1_to_t0_chan_0[51][4] = buffer_t1_chan_0[51]; // t1[0](1, 2) @ unroll_index=51\n        points_from_t1_to_t0_chan_0[52][4] = buffer_t1_chan_0[52]; // t1[0](1, 2) @ unroll_index=52\n        points_from_t1_to_t0_chan_0[53][4] = buffer_t1_chan_0[53]; // t1[0](1, 2) @ unroll_index=53\n        points_from_t1_to_t0_chan_0[54][4] = buffer_t1_chan_0[54]; // t1[0](1, 2) @ unroll_index=54\n        points_from_t1_to_t0_chan_0[55][4] = buffer_t1_chan_0[55]; // t1[0](1, 2) @ unroll_index=55\n        points_from_t1_to_t0_chan_0[56][4] = buffer_t1_chan_0[56]; // t1[0](1, 2) @ unroll_index=56\n        points_from_t1_to_t0_chan_0[57][4] = buffer_t1_chan_0[57]; // t1[0](1, 2) @ unroll_index=57\n        points_from_t1_to_t0_chan_0[58][4] = buffer_t1_chan_0[58]; // t1[0](1, 2) @ unroll_index=58\n        points_from_t1_to_t0_chan_0[59][4] = buffer_t1_chan_0[59]; // t1[0](1, 2) @ unroll_index=59\n        points_from_t1_to_t0_chan_0[60][4] = buffer_t1_chan_0[60]; // t1[0](1, 2) @ unroll_index=60\n        points_from_t1_to_t0_chan_0[61][4] = buffer_t1_chan_0[61]; // t1[0](1, 2) @ unroll_index=61\n        points_from_t1_to_t0_chan_0[62][4] = buffer_t1_chan_0[62]; // t1[0](1, 2) @ unroll_index=62\n        points_from_t1_to_t0_chan_0[63][4] = buffer_t1_chan_0[63]; // t1[0](1, 2) @ unroll_index=63\n        points_from_t1_to_t0_chan_0[0][2] = FF_t1_chan_0[0]; // t1[0](1, 1) @ unroll_index=0\n        points_from_t1_to_t0_chan_0[1][1] = FF_t1_chan_0[0]; // t1[0](0, 1) @ unroll_index=1\n        points_from_t1_to_t0_chan_0[0][1] = FF_t1_chan_0[1]; // t1[0](0, 1) @ unroll_index=0\n        points_from_t1_to_t0_chan_0[62][3] = FIFO_125_t1_chan_0_fifo_0; // t1[0](2, 1) @ unroll_index=62\n        points_from_t1_to_t0_chan_0[63][2] = FIFO_125_t1_chan_0_fifo_0; // t1[0](1, 1) @ unroll_index=63\n        points_from_t1_to_t0_chan_0[61][3] = FIFO_125_t1_chan_0_fifo_1; // t1[0](2, 1) @ unroll_index=61\n        points_from_t1_to_t0_chan_0[62][2] = FIFO_125_t1_chan_0_fifo_1; // t1[0](1, 1) @ unroll_index=62\n        points_from_t1_to_t0_chan_0[63][1] = FIFO_125_t1_chan_0_fifo_1; // t1[0](0, 1) @ unroll_index=63\n        points_from_t1_to_t0_chan_0[60][3] = FIFO_125_t1_chan_0_fifo_2; // t1[0](2, 1) @ unroll_index=60\n        points_from_t1_to_t0_chan_0[61][2] = FIFO_125_t1_chan_0_fifo_2; // t1[0](1, 1) @ unroll_index=61\n        points_from_t1_to_t0_chan_0[62][1] = FIFO_125_t1_chan_0_fifo_2; // t1[0](0, 1) @ unroll_index=62\n        points_from_t1_to_t0_chan_0[59][3] = FIFO_125_t1_chan_0_fifo_3; // t1[0](2, 1) @ unroll_index=59\n        points_from_t1_to_t0_chan_0[60][2] = FIFO_125_t1_chan_0_fifo_3; // t1[0](1, 1) @ unroll_index=60\n        points_from_t1_to_t0_chan_0[61][1] = FIFO_125_t1_chan_0_fifo_3; // t1[0](0, 1) @ unroll_index=61\n        points_from_t1_to_t0_chan_0[58][3] = FIFO_125_t1_chan_0_fifo_4; // t1[0](2, 1) @ unroll_index=58\n        points_from_t1_to_t0_chan_0[59][2] = FIFO_125_t1_chan_0_fifo_4; // t1[0](1, 1) @ unroll_index=59\n        points_from_t1_to_t0_chan_0[60][1] = FIFO_125_t1_chan_0_fifo_4; // t1[0](0, 1) @ unroll_index=60\n        points_from_t1_to_t0_chan_0[57][3] = FIFO_125_t1_chan_0_fifo_5; // t1[0](2, 1) @ unroll_index=57\n        points_from_t1_to_t0_chan_0[58][2] = FIFO_125_t1_chan_0_fifo_5; // t1[0](1, 1) @ unroll_index=58\n        points_from_t1_to_t0_chan_0[59][1] = FIFO_125_t1_chan_0_fifo_5; // t1[0](0, 1) @ unroll_index=59\n        points_from_t1_to_t0_chan_0[56][3] = FIFO_125_t1_chan_0_fifo_6; // t1[0](2, 1) @ unroll_index=56\n        points_from_t1_to_t0_chan_0[57][2] = FIFO_125_t1_chan_0_fifo_6; // t1[0](1, 1) @ unroll_index=57\n        points_from_t1_to_t0_chan_0[58][1] = FIFO_125_t1_chan_0_fifo_6; // t1[0](0, 1) @ unroll_index=58\n        points_from_t1_to_t0_chan_0[56][2] = FIFO_125_t1_chan_0_fifo_7; // t1[0](1, 1) @ unroll_index=56\n        points_from_t1_to_t0_chan_0[57][1] = FIFO_125_t1_chan_0_fifo_7; // t1[0](0, 1) @ unroll_index=57\n        points_from_t1_to_t0_chan_0[55][3] = FIFO_125_t1_chan_0_fifo_7; // t1[0](2, 1) @ unroll_index=55\n        points_from_t1_to_t0_chan_0[56][1] = FIFO_125_t1_chan_0_fifo_8; // t1[0](0, 1) @ unroll_index=56\n        points_from_t1_to_t0_chan_0[54][3] = FIFO_125_t1_chan_0_fifo_8; // t1[0](2, 1) @ unroll_index=54\n        points_from_t1_to_t0_chan_0[55][2] = FIFO_125_t1_chan_0_fifo_8; // t1[0](1, 1) @ unroll_index=55\n        points_from_t1_to_t0_chan_0[53][3] = FIFO_125_t1_chan_0_fifo_9; // t1[0](2, 1) @ unroll_index=53\n        points_from_t1_to_t0_chan_0[54][2] = FIFO_125_t1_chan_0_fifo_9; // t1[0](1, 1) @ unroll_index=54\n        points_from_t1_to_t0_chan_0[55][1] = FIFO_125_t1_chan_0_fifo_9; // t1[0](0, 1) @ unroll_index=55\n        points_from_t1_to_t0_chan_0[52][3] = FIFO_125_t1_chan_0_fifo_10; // t1[0](2, 1) @ unroll_index=52\n        points_from_t1_to_t0_chan_0[53][2] = FIFO_125_t1_chan_0_fifo_10; // t1[0](1, 1) @ unroll_index=53\n        points_from_t1_to_t0_chan_0[54][1] = FIFO_125_t1_chan_0_fifo_10; // t1[0](0, 1) @ unroll_index=54\n        points_from_t1_to_t0_chan_0[51][3] = FIFO_125_t1_chan_0_fifo_11; // t1[0](2, 1) @ unroll_index=51\n        points_from_t1_to_t0_chan_0[52][2] = FIFO_125_t1_chan_0_fifo_11; // t1[0](1, 1) @ unroll_index=52\n        points_from_t1_to_t0_chan_0[53][1] = FIFO_125_t1_chan_0_fifo_11; // t1[0](0, 1) @ unroll_index=53\n        points_from_t1_to_t0_chan_0[50][3] = FIFO_125_t1_chan_0_fifo_12; // t1[0](2, 1) @ unroll_index=50\n        points_from_t1_to_t0_chan_0[51][2] = FIFO_125_t1_chan_0_fifo_12; // t1[0](1, 1) @ unroll_index=51\n        points_from_t1_to_t0_chan_0[52][1] = FIFO_125_t1_chan_0_fifo_12; // t1[0](0, 1) @ unroll_index=52\n        points_from_t1_to_t0_chan_0[49][3] = FIFO_125_t1_chan_0_fifo_13; // t1[0](2, 1) @ unroll_index=49\n        points_from_t1_to_t0_chan_0[50][2] = FIFO_125_t1_chan_0_fifo_13; // t1[0](1, 1) @ unroll_index=50\n        points_from_t1_to_t0_chan_0[51][1] = FIFO_125_t1_chan_0_fifo_13; // t1[0](0, 1) @ unroll_index=51\n        points_from_t1_to_t0_chan_0[48][3] = FIFO_125_t1_chan_0_fifo_14; // t1[0](2, 1) @ unroll_index=48\n        points_from_t1_to_t0_chan_0[49][2] = FIFO_125_t1_chan_0_fifo_14; // t1[0](1, 1) @ unroll_index=49\n        points_from_t1_to_t0_chan_0[50][1] = FIFO_125_t1_chan_0_fifo_14; // t1[0](0, 1) @ unroll_index=50\n        points_from_t1_to_t0_chan_0[48][2] = FIFO_125_t1_chan_0_fifo_15; // t1[0](1, 1) @ unroll_index=48\n        points_from_t1_to_t0_chan_0[49][1] = FIFO_125_t1_chan_0_fifo_15; // t1[0](0, 1) @ unroll_index=49\n        points_from_t1_to_t0_chan_0[47][3] = FIFO_125_t1_chan_0_fifo_15; // t1[0](2, 1) @ unroll_index=47\n        points_from_t1_to_t0_chan_0[48][1] = FIFO_125_t1_chan_0_fifo_16; // t1[0](0, 1) @ unroll_index=48\n        points_from_t1_to_t0_chan_0[46][3] = FIFO_125_t1_chan_0_fifo_16; // t1[0](2, 1) @ unroll_index=46\n        points_from_t1_to_t0_chan_0[47][2] = FIFO_125_t1_chan_0_fifo_16; // t1[0](1, 1) @ unroll_index=47\n        points_from_t1_to_t0_chan_0[45][3] = FIFO_125_t1_chan_0_fifo_17; // t1[0](2, 1) @ unroll_index=45\n        points_from_t1_to_t0_chan_0[46][2] = FIFO_125_t1_chan_0_fifo_17; // t1[0](1, 1) @ unroll_index=46\n        points_from_t1_to_t0_chan_0[47][1] = FIFO_125_t1_chan_0_fifo_17; // t1[0](0, 1) @ unroll_index=47\n        points_from_t1_to_t0_chan_0[44][3] = FIFO_125_t1_chan_0_fifo_18; // t1[0](2, 1) @ unroll_index=44\n        points_from_t1_to_t0_chan_0[45][2] = FIFO_125_t1_chan_0_fifo_18; // t1[0](1, 1) @ unroll_index=45\n        points_from_t1_to_t0_chan_0[46][1] = FIFO_125_t1_chan_0_fifo_18; // t1[0](0, 1) @ unroll_index=46\n        points_from_t1_to_t0_chan_0[43][3] = FIFO_125_t1_chan_0_fifo_19; // t1[0](2, 1) @ unroll_index=43\n        points_from_t1_to_t0_chan_0[44][2] = FIFO_125_t1_chan_0_fifo_19; // t1[0](1, 1) @ unroll_index=44\n        points_from_t1_to_t0_chan_0[45][1] = FIFO_125_t1_chan_0_fifo_19; // t1[0](0, 1) @ unroll_index=45\n        points_from_t1_to_t0_chan_0[42][3] = FIFO_125_t1_chan_0_fifo_20; // t1[0](2, 1) @ unroll_index=42\n        points_from_t1_to_t0_chan_0[43][2] = FIFO_125_t1_chan_0_fifo_20; // t1[0](1, 1) @ unroll_index=43\n        points_from_t1_to_t0_chan_0[44][1] = FIFO_125_t1_chan_0_fifo_20; // t1[0](0, 1) @ unroll_index=44\n        points_from_t1_to_t0_chan_0[41][3] = FIFO_125_t1_chan_0_fifo_21; // t1[0](2, 1) @ unroll_index=41\n        points_from_t1_to_t0_chan_0[42][2] = FIFO_125_t1_chan_0_fifo_21; // t1[0](1, 1) @ unroll_index=42\n        points_from_t1_to_t0_chan_0[43][1] = FIFO_125_t1_chan_0_fifo_21; // t1[0](0, 1) @ unroll_index=43\n        points_from_t1_to_t0_chan_0[40][3] = FIFO_125_t1_chan_0_fifo_22; // t1[0](2, 1) @ unroll_index=40\n        points_from_t1_to_t0_chan_0[41][2] = FIFO_125_t1_chan_0_fifo_22; // t1[0](1, 1) @ unroll_index=41\n        points_from_t1_to_t0_chan_0[42][1] = FIFO_125_t1_chan_0_fifo_22; // t1[0](0, 1) @ unroll_index=42\n        points_from_t1_to_t0_chan_0[40][2] = FIFO_125_t1_chan_0_fifo_23; // t1[0](1, 1) @ unroll_index=40\n        points_from_t1_to_t0_chan_0[41][1] = FIFO_125_t1_chan_0_fifo_23; // t1[0](0, 1) @ unroll_index=41\n        points_from_t1_to_t0_chan_0[39][3] = FIFO_125_t1_chan_0_fifo_23; // t1[0](2, 1) @ unroll_index=39\n        points_from_t1_to_t0_chan_0[40][1] = FIFO_125_t1_chan_0_fifo_24; // t1[0](0, 1) @ unroll_index=40\n        points_from_t1_to_t0_chan_0[38][3] = FIFO_125_t1_chan_0_fifo_24; // t1[0](2, 1) @ unroll_index=38\n        points_from_t1_to_t0_chan_0[39][2] = FIFO_125_t1_chan_0_fifo_24; // t1[0](1, 1) @ unroll_index=39\n        points_from_t1_to_t0_chan_0[37][3] = FIFO_125_t1_chan_0_fifo_25; // t1[0](2, 1) @ unroll_index=37\n        points_from_t1_to_t0_chan_0[38][2] = FIFO_125_t1_chan_0_fifo_25; // t1[0](1, 1) @ unroll_index=38\n        points_from_t1_to_t0_chan_0[39][1] = FIFO_125_t1_chan_0_fifo_25; // t1[0](0, 1) @ unroll_index=39\n        points_from_t1_to_t0_chan_0[36][3] = FIFO_125_t1_chan_0_fifo_26; // t1[0](2, 1) @ unroll_index=36\n        points_from_t1_to_t0_chan_0[37][2] = FIFO_125_t1_chan_0_fifo_26; // t1[0](1, 1) @ unroll_index=37\n        points_from_t1_to_t0_chan_0[38][1] = FIFO_125_t1_chan_0_fifo_26; // t1[0](0, 1) @ unroll_index=38\n        points_from_t1_to_t0_chan_0[35][3] = FIFO_125_t1_chan_0_fifo_27; // t1[0](2, 1) @ unroll_index=35\n        points_from_t1_to_t0_chan_0[36][2] = FIFO_125_t1_chan_0_fifo_27; // t1[0](1, 1) @ unroll_index=36\n        points_from_t1_to_t0_chan_0[37][1] = FIFO_125_t1_chan_0_fifo_27; // t1[0](0, 1) @ unroll_index=37\n        points_from_t1_to_t0_chan_0[34][3] = FIFO_125_t1_chan_0_fifo_28; // t1[0](2, 1) @ unroll_index=34\n        points_from_t1_to_t0_chan_0[35][2] = FIFO_125_t1_chan_0_fifo_28; // t1[0](1, 1) @ unroll_index=35\n        points_from_t1_to_t0_chan_0[36][1] = FIFO_125_t1_chan_0_fifo_28; // t1[0](0, 1) @ unroll_index=36\n        points_from_t1_to_t0_chan_0[33][3] = FIFO_125_t1_chan_0_fifo_29; // t1[0](2, 1) @ unroll_index=33\n        points_from_t1_to_t0_chan_0[34][2] = FIFO_125_t1_chan_0_fifo_29; // t1[0](1, 1) @ unroll_index=34\n        points_from_t1_to_t0_chan_0[35][1] = FIFO_125_t1_chan_0_fifo_29; // t1[0](0, 1) @ unroll_index=35\n        points_from_t1_to_t0_chan_0[32][3] = FIFO_125_t1_chan_0_fifo_30; // t1[0](2, 1) @ unroll_index=32\n        points_from_t1_to_t0_chan_0[33][2] = FIFO_125_t1_chan_0_fifo_30; // t1[0](1, 1) @ unroll_index=33\n        points_from_t1_to_t0_chan_0[34][1] = FIFO_125_t1_chan_0_fifo_30; // t1[0](0, 1) @ unroll_index=34\n        points_from_t1_to_t0_chan_0[32][2] = FIFO_125_t1_chan_0_fifo_31; // t1[0](1, 1) @ unroll_index=32\n        points_from_t1_to_t0_chan_0[33][1] = FIFO_125_t1_chan_0_fifo_31; // t1[0](0, 1) @ unroll_index=33\n        points_from_t1_to_t0_chan_0[31][3] = FIFO_125_t1_chan_0_fifo_31; // t1[0](2, 1) @ unroll_index=31\n        points_from_t1_to_t0_chan_0[32][1] = FIFO_125_t1_chan_0_fifo_32; // t1[0](0, 1) @ unroll_index=32\n        points_from_t1_to_t0_chan_0[30][3] = FIFO_125_t1_chan_0_fifo_32; // t1[0](2, 1) @ unroll_index=30\n        points_from_t1_to_t0_chan_0[31][2] = FIFO_125_t1_chan_0_fifo_32; // t1[0](1, 1) @ unroll_index=31\n        points_from_t1_to_t0_chan_0[29][3] = FIFO_125_t1_chan_0_fifo_33; // t1[0](2, 1) @ unroll_index=29\n        points_from_t1_to_t0_chan_0[30][2] = FIFO_125_t1_chan_0_fifo_33; // t1[0](1, 1) @ unroll_index=30\n        points_from_t1_to_t0_chan_0[31][1] = FIFO_125_t1_chan_0_fifo_33; // t1[0](0, 1) @ unroll_index=31\n        points_from_t1_to_t0_chan_0[28][3] = FIFO_125_t1_chan_0_fifo_34; // t1[0](2, 1) @ unroll_index=28\n        points_from_t1_to_t0_chan_0[29][2] = FIFO_125_t1_chan_0_fifo_34; // t1[0](1, 1) @ unroll_index=29\n        points_from_t1_to_t0_chan_0[30][1] = FIFO_125_t1_chan_0_fifo_34; // t1[0](0, 1) @ unroll_index=30\n        points_from_t1_to_t0_chan_0[27][3] = FIFO_125_t1_chan_0_fifo_35; // t1[0](2, 1) @ unroll_index=27\n        points_from_t1_to_t0_chan_0[28][2] = FIFO_125_t1_chan_0_fifo_35; // t1[0](1, 1) @ unroll_index=28\n        points_from_t1_to_t0_chan_0[29][1] = FIFO_125_t1_chan_0_fifo_35; // t1[0](0, 1) @ unroll_index=29\n        points_from_t1_to_t0_chan_0[26][3] = FIFO_125_t1_chan_0_fifo_36; // t1[0](2, 1) @ unroll_index=26\n        points_from_t1_to_t0_chan_0[27][2] = FIFO_125_t1_chan_0_fifo_36; // t1[0](1, 1) @ unroll_index=27\n        points_from_t1_to_t0_chan_0[28][1] = FIFO_125_t1_chan_0_fifo_36; // t1[0](0, 1) @ unroll_index=28\n        points_from_t1_to_t0_chan_0[25][3] = FIFO_125_t1_chan_0_fifo_37; // t1[0](2, 1) @ unroll_index=25\n        points_from_t1_to_t0_chan_0[26][2] = FIFO_125_t1_chan_0_fifo_37; // t1[0](1, 1) @ unroll_index=26\n        points_from_t1_to_t0_chan_0[27][1] = FIFO_125_t1_chan_0_fifo_37; // t1[0](0, 1) @ unroll_index=27\n        points_from_t1_to_t0_chan_0[24][3] = FIFO_125_t1_chan_0_fifo_38; // t1[0](2, 1) @ unroll_index=24\n        points_from_t1_to_t0_chan_0[25][2] = FIFO_125_t1_chan_0_fifo_38; // t1[0](1, 1) @ unroll_index=25\n        points_from_t1_to_t0_chan_0[26][1] = FIFO_125_t1_chan_0_fifo_38; // t1[0](0, 1) @ unroll_index=26\n        points_from_t1_to_t0_chan_0[24][2] = FIFO_125_t1_chan_0_fifo_39; // t1[0](1, 1) @ unroll_index=24\n        points_from_t1_to_t0_chan_0[25][1] = FIFO_125_t1_chan_0_fifo_39; // t1[0](0, 1) @ unroll_index=25\n        points_from_t1_to_t0_chan_0[23][3] = FIFO_125_t1_chan_0_fifo_39; // t1[0](2, 1) @ unroll_index=23\n        points_from_t1_to_t0_chan_0[24][1] = FIFO_125_t1_chan_0_fifo_40; // t1[0](0, 1) @ unroll_index=24\n        points_from_t1_to_t0_chan_0[22][3] = FIFO_125_t1_chan_0_fifo_40; // t1[0](2, 1) @ unroll_index=22\n        points_from_t1_to_t0_chan_0[23][2] = FIFO_125_t1_chan_0_fifo_40; // t1[0](1, 1) @ unroll_index=23\n        points_from_t1_to_t0_chan_0[21][3] = FIFO_125_t1_chan_0_fifo_41; // t1[0](2, 1) @ unroll_index=21\n        points_from_t1_to_t0_chan_0[22][2] = FIFO_125_t1_chan_0_fifo_41; // t1[0](1, 1) @ unroll_index=22\n        points_from_t1_to_t0_chan_0[23][1] = FIFO_125_t1_chan_0_fifo_41; // t1[0](0, 1) @ unroll_index=23\n        points_from_t1_to_t0_chan_0[20][3] = FIFO_125_t1_chan_0_fifo_42; // t1[0](2, 1) @ unroll_index=20\n        points_from_t1_to_t0_chan_0[21][2] = FIFO_125_t1_chan_0_fifo_42; // t1[0](1, 1) @ unroll_index=21\n        points_from_t1_to_t0_chan_0[22][1] = FIFO_125_t1_chan_0_fifo_42; // t1[0](0, 1) @ unroll_index=22\n        points_from_t1_to_t0_chan_0[19][3] = FIFO_125_t1_chan_0_fifo_43; // t1[0](2, 1) @ unroll_index=19\n        points_from_t1_to_t0_chan_0[20][2] = FIFO_125_t1_chan_0_fifo_43; // t1[0](1, 1) @ unroll_index=20\n        points_from_t1_to_t0_chan_0[21][1] = FIFO_125_t1_chan_0_fifo_43; // t1[0](0, 1) @ unroll_index=21\n        points_from_t1_to_t0_chan_0[18][3] = FIFO_125_t1_chan_0_fifo_44; // t1[0](2, 1) @ unroll_index=18\n        points_from_t1_to_t0_chan_0[19][2] = FIFO_125_t1_chan_0_fifo_44; // t1[0](1, 1) @ unroll_index=19\n        points_from_t1_to_t0_chan_0[20][1] = FIFO_125_t1_chan_0_fifo_44; // t1[0](0, 1) @ unroll_index=20\n        points_from_t1_to_t0_chan_0[17][3] = FIFO_125_t1_chan_0_fifo_45; // t1[0](2, 1) @ unroll_index=17\n        points_from_t1_to_t0_chan_0[18][2] = FIFO_125_t1_chan_0_fifo_45; // t1[0](1, 1) @ unroll_index=18\n        points_from_t1_to_t0_chan_0[19][1] = FIFO_125_t1_chan_0_fifo_45; // t1[0](0, 1) @ unroll_index=19\n        points_from_t1_to_t0_chan_0[16][3] = FIFO_125_t1_chan_0_fifo_46; // t1[0](2, 1) @ unroll_index=16\n        points_from_t1_to_t0_chan_0[17][2] = FIFO_125_t1_chan_0_fifo_46; // t1[0](1, 1) @ unroll_index=17\n        points_from_t1_to_t0_chan_0[18][1] = FIFO_125_t1_chan_0_fifo_46; // t1[0](0, 1) @ unroll_index=18\n        points_from_t1_to_t0_chan_0[16][2] = FIFO_125_t1_chan_0_fifo_47; // t1[0](1, 1) @ unroll_index=16\n        points_from_t1_to_t0_chan_0[17][1] = FIFO_125_t1_chan_0_fifo_47; // t1[0](0, 1) @ unroll_index=17\n        points_from_t1_to_t0_chan_0[15][3] = FIFO_125_t1_chan_0_fifo_47; // t1[0](2, 1) @ unroll_index=15\n        points_from_t1_to_t0_chan_0[16][1] = FIFO_125_t1_chan_0_fifo_48; // t1[0](0, 1) @ unroll_index=16\n        points_from_t1_to_t0_chan_0[14][3] = FIFO_125_t1_chan_0_fifo_48; // t1[0](2, 1) @ unroll_index=14\n        points_from_t1_to_t0_chan_0[15][2] = FIFO_125_t1_chan_0_fifo_48; // t1[0](1, 1) @ unroll_index=15\n        points_from_t1_to_t0_chan_0[13][3] = FIFO_125_t1_chan_0_fifo_49; // t1[0](2, 1) @ unroll_index=13\n        points_from_t1_to_t0_chan_0[14][2] = FIFO_125_t1_chan_0_fifo_49; // t1[0](1, 1) @ unroll_index=14\n        points_from_t1_to_t0_chan_0[15][1] = FIFO_125_t1_chan_0_fifo_49; // t1[0](0, 1) @ unroll_index=15\n        points_from_t1_to_t0_chan_0[12][3] = FIFO_125_t1_chan_0_fifo_50; // t1[0](2, 1) @ unroll_index=12\n        points_from_t1_to_t0_chan_0[13][2] = FIFO_125_t1_chan_0_fifo_50; // t1[0](1, 1) @ unroll_index=13\n        points_from_t1_to_t0_chan_0[14][1] = FIFO_125_t1_chan_0_fifo_50; // t1[0](0, 1) @ unroll_index=14\n        points_from_t1_to_t0_chan_0[11][3] = FIFO_125_t1_chan_0_fifo_51; // t1[0](2, 1) @ unroll_index=11\n        points_from_t1_to_t0_chan_0[12][2] = FIFO_125_t1_chan_0_fifo_51; // t1[0](1, 1) @ unroll_index=12\n        points_from_t1_to_t0_chan_0[13][1] = FIFO_125_t1_chan_0_fifo_51; // t1[0](0, 1) @ unroll_index=13\n        points_from_t1_to_t0_chan_0[10][3] = FIFO_125_t1_chan_0_fifo_52; // t1[0](2, 1) @ unroll_index=10\n        points_from_t1_to_t0_chan_0[11][2] = FIFO_125_t1_chan_0_fifo_52; // t1[0](1, 1) @ unroll_index=11\n        points_from_t1_to_t0_chan_0[12][1] = FIFO_125_t1_chan_0_fifo_52; // t1[0](0, 1) @ unroll_index=12\n        points_from_t1_to_t0_chan_0[9][3] = FIFO_125_t1_chan_0_fifo_53; // t1[0](2, 1) @ unroll_index=9\n        points_from_t1_to_t0_chan_0[10][2] = FIFO_125_t1_chan_0_fifo_53; // t1[0](1, 1) @ unroll_index=10\n        points_from_t1_to_t0_chan_0[11][1] = FIFO_125_t1_chan_0_fifo_53; // t1[0](0, 1) @ unroll_index=11\n        points_from_t1_to_t0_chan_0[8][3] = FIFO_125_t1_chan_0_fifo_54; // t1[0](2, 1) @ unroll_index=8\n        points_from_t1_to_t0_chan_0[9][2] = FIFO_125_t1_chan_0_fifo_54; // t1[0](1, 1) @ unroll_index=9\n        points_from_t1_to_t0_chan_0[10][1] = FIFO_125_t1_chan_0_fifo_54; // t1[0](0, 1) @ unroll_index=10\n        points_from_t1_to_t0_chan_0[8][2] = FIFO_125_t1_chan_0_fifo_55; // t1[0](1, 1) @ unroll_index=8\n        points_from_t1_to_t0_chan_0[9][1] = FIFO_125_t1_chan_0_fifo_55; // t1[0](0, 1) @ unroll_index=9\n        points_from_t1_to_t0_chan_0[7][3] = FIFO_125_t1_chan_0_fifo_55; // t1[0](2, 1) @ unroll_index=7\n        points_from_t1_to_t0_chan_0[8][1] = FIFO_125_t1_chan_0_fifo_56; // t1[0](0, 1) @ unroll_index=8\n        points_from_t1_to_t0_chan_0[6][3] = FIFO_125_t1_chan_0_fifo_56; // t1[0](2, 1) @ unroll_index=6\n        points_from_t1_to_t0_chan_0[7][2] = FIFO_125_t1_chan_0_fifo_56; // t1[0](1, 1) @ unroll_index=7\n        points_from_t1_to_t0_chan_0[5][3] = FIFO_125_t1_chan_0_fifo_57; // t1[0](2, 1) @ unroll_index=5\n        points_from_t1_to_t0_chan_0[6][2] = FIFO_125_t1_chan_0_fifo_57; // t1[0](1, 1) @ unroll_index=6\n        points_from_t1_to_t0_chan_0[7][1] = FIFO_125_t1_chan_0_fifo_57; // t1[0](0, 1) @ unroll_index=7\n        points_from_t1_to_t0_chan_0[4][3] = FIFO_125_t1_chan_0_fifo_58; // t1[0](2, 1) @ unroll_index=4\n        points_from_t1_to_t0_chan_0[5][2] = FIFO_125_t1_chan_0_fifo_58; // t1[0](1, 1) @ unroll_index=5\n        points_from_t1_to_t0_chan_0[6][1] = FIFO_125_t1_chan_0_fifo_58; // t1[0](0, 1) @ unroll_index=6\n        points_from_t1_to_t0_chan_0[3][3] = FIFO_125_t1_chan_0_fifo_59; // t1[0](2, 1) @ unroll_index=3\n        points_from_t1_to_t0_chan_0[4][2] = FIFO_125_t1_chan_0_fifo_59; // t1[0](1, 1) @ unroll_index=4\n        points_from_t1_to_t0_chan_0[5][1] = FIFO_125_t1_chan_0_fifo_59; // t1[0](0, 1) @ unroll_index=5\n        points_from_t1_to_t0_chan_0[2][3] = FIFO_125_t1_chan_0_fifo_60; // t1[0](2, 1) @ unroll_index=2\n        points_from_t1_to_t0_chan_0[3][2] = FIFO_125_t1_chan_0_fifo_60; // t1[0](1, 1) @ unroll_index=3\n        points_from_t1_to_t0_chan_0[4][1] = FIFO_125_t1_chan_0_fifo_60; // t1[0](0, 1) @ unroll_index=4\n        points_from_t1_to_t0_chan_0[1][3] = FIFO_125_t1_chan_0_fifo_61; // t1[0](2, 1) @ unroll_index=1\n        points_from_t1_to_t0_chan_0[2][2] = FIFO_125_t1_chan_0_fifo_61; // t1[0](1, 1) @ unroll_index=2\n        points_from_t1_to_t0_chan_0[3][1] = FIFO_125_t1_chan_0_fifo_61; // t1[0](0, 1) @ unroll_index=3\n        points_from_t1_to_t0_chan_0[0][3] = FIFO_125_t1_chan_0_fifo_62; // t1[0](2, 1) @ unroll_index=0\n        points_from_t1_to_t0_chan_0[1][2] = FIFO_125_t1_chan_0_fifo_62; // t1[0](1, 1) @ unroll_index=1\n        points_from_t1_to_t0_chan_0[2][1] = FIFO_125_t1_chan_0_fifo_62; // t1[0](0, 1) @ unroll_index=2\n        points_from_t1_to_t0_chan_0[62][0] = FIFO_125_t1_chan_0_fifo_63; // t1[0](1, 0) @ unroll_index=62\n        points_from_t1_to_t0_chan_0[61][0] = FIFO_125_t1_chan_0_fifo_64; // t1[0](1, 0) @ unroll_index=61\n        points_from_t1_to_t0_chan_0[60][0] = FIFO_125_t1_chan_0_fifo_65; // t1[0](1, 0) @ unroll_index=60\n        points_from_t1_to_t0_chan_0[59][0] = FIFO_125_t1_chan_0_fifo_66; // t1[0](1, 0) @ unroll_index=59\n        points_from_t1_to_t0_chan_0[58][0] = FIFO_125_t1_chan_0_fifo_67; // t1[0](1, 0) @ unroll_index=58\n        points_from_t1_to_t0_chan_0[57][0] = FIFO_125_t1_chan_0_fifo_68; // t1[0](1, 0) @ unroll_index=57\n        points_from_t1_to_t0_chan_0[56][0] = FIFO_125_t1_chan_0_fifo_69; // t1[0](1, 0) @ unroll_index=56\n        points_from_t1_to_t0_chan_0[55][0] = FIFO_125_t1_chan_0_fifo_70; // t1[0](1, 0) @ unroll_index=55\n        points_from_t1_to_t0_chan_0[54][0] = FIFO_125_t1_chan_0_fifo_71; // t1[0](1, 0) @ unroll_index=54\n        points_from_t1_to_t0_chan_0[53][0] = FIFO_125_t1_chan_0_fifo_72; // t1[0](1, 0) @ unroll_index=53\n        points_from_t1_to_t0_chan_0[52][0] = FIFO_125_t1_chan_0_fifo_73; // t1[0](1, 0) @ unroll_index=52\n        points_from_t1_to_t0_chan_0[51][0] = FIFO_125_t1_chan_0_fifo_74; // t1[0](1, 0) @ unroll_index=51\n        points_from_t1_to_t0_chan_0[50][0] = FIFO_125_t1_chan_0_fifo_75; // t1[0](1, 0) @ unroll_index=50\n        points_from_t1_to_t0_chan_0[49][0] = FIFO_125_t1_chan_0_fifo_76; // t1[0](1, 0) @ unroll_index=49\n        points_from_t1_to_t0_chan_0[48][0] = FIFO_125_t1_chan_0_fifo_77; // t1[0](1, 0) @ unroll_index=48\n        points_from_t1_to_t0_chan_0[47][0] = FIFO_125_t1_chan_0_fifo_78; // t1[0](1, 0) @ unroll_index=47\n        points_from_t1_to_t0_chan_0[46][0] = FIFO_125_t1_chan_0_fifo_79; // t1[0](1, 0) @ unroll_index=46\n        points_from_t1_to_t0_chan_0[45][0] = FIFO_125_t1_chan_0_fifo_80; // t1[0](1, 0) @ unroll_index=45\n        points_from_t1_to_t0_chan_0[44][0] = FIFO_125_t1_chan_0_fifo_81; // t1[0](1, 0) @ unroll_index=44\n        points_from_t1_to_t0_chan_0[43][0] = FIFO_125_t1_chan_0_fifo_82; // t1[0](1, 0) @ unroll_index=43\n        points_from_t1_to_t0_chan_0[42][0] = FIFO_125_t1_chan_0_fifo_83; // t1[0](1, 0) @ unroll_index=42\n        points_from_t1_to_t0_chan_0[41][0] = FIFO_125_t1_chan_0_fifo_84; // t1[0](1, 0) @ unroll_index=41\n        points_from_t1_to_t0_chan_0[40][0] = FIFO_125_t1_chan_0_fifo_85; // t1[0](1, 0) @ unroll_index=40\n        points_from_t1_to_t0_chan_0[39][0] = FIFO_125_t1_chan_0_fifo_86; // t1[0](1, 0) @ unroll_index=39\n        points_from_t1_to_t0_chan_0[38][0] = FIFO_125_t1_chan_0_fifo_87; // t1[0](1, 0) @ unroll_index=38\n        points_from_t1_to_t0_chan_0[37][0] = FIFO_125_t1_chan_0_fifo_88; // t1[0](1, 0) @ unroll_index=37\n        points_from_t1_to_t0_chan_0[36][0] = FIFO_125_t1_chan_0_fifo_89; // t1[0](1, 0) @ unroll_index=36\n        points_from_t1_to_t0_chan_0[35][0] = FIFO_125_t1_chan_0_fifo_90; // t1[0](1, 0) @ unroll_index=35\n        points_from_t1_to_t0_chan_0[34][0] = FIFO_125_t1_chan_0_fifo_91; // t1[0](1, 0) @ unroll_index=34\n        points_from_t1_to_t0_chan_0[33][0] = FIFO_125_t1_chan_0_fifo_92; // t1[0](1, 0) @ unroll_index=33\n        points_from_t1_to_t0_chan_0[32][0] = FIFO_125_t1_chan_0_fifo_93; // t1[0](1, 0) @ unroll_index=32\n        points_from_t1_to_t0_chan_0[31][0] = FIFO_125_t1_chan_0_fifo_94; // t1[0](1, 0) @ unroll_index=31\n        points_from_t1_to_t0_chan_0[30][0] = FIFO_125_t1_chan_0_fifo_95; // t1[0](1, 0) @ unroll_index=30\n        points_from_t1_to_t0_chan_0[29][0] = FIFO_125_t1_chan_0_fifo_96; // t1[0](1, 0) @ unroll_index=29\n        points_from_t1_to_t0_chan_0[28][0] = FIFO_125_t1_chan_0_fifo_97; // t1[0](1, 0) @ unroll_index=28\n        points_from_t1_to_t0_chan_0[27][0] = FIFO_125_t1_chan_0_fifo_98; // t1[0](1, 0) @ unroll_index=27\n        points_from_t1_to_t0_chan_0[26][0] = FIFO_125_t1_chan_0_fifo_99; // t1[0](1, 0) @ unroll_index=26\n        points_from_t1_to_t0_chan_0[25][0] = FIFO_125_t1_chan_0_fifo_100; // t1[0](1, 0) @ unroll_index=25\n        points_from_t1_to_t0_chan_0[24][0] = FIFO_125_t1_chan_0_fifo_101; // t1[0](1, 0) @ unroll_index=24\n        points_from_t1_to_t0_chan_0[23][0] = FIFO_125_t1_chan_0_fifo_102; // t1[0](1, 0) @ unroll_index=23\n        points_from_t1_to_t0_chan_0[22][0] = FIFO_125_t1_chan_0_fifo_103; // t1[0](1, 0) @ unroll_index=22\n        points_from_t1_to_t0_chan_0[21][0] = FIFO_125_t1_chan_0_fifo_104; // t1[0](1, 0) @ unroll_index=21\n        points_from_t1_to_t0_chan_0[20][0] = FIFO_125_t1_chan_0_fifo_105; // t1[0](1, 0) @ unroll_index=20\n        points_from_t1_to_t0_chan_0[19][0] = FIFO_125_t1_chan_0_fifo_106; // t1[0](1, 0) @ unroll_index=19\n        points_from_t1_to_t0_chan_0[18][0] = FIFO_125_t1_chan_0_fifo_107; // t1[0](1, 0) @ unroll_index=18\n        points_from_t1_to_t0_chan_0[17][0] = FIFO_125_t1_chan_0_fifo_108; // t1[0](1, 0) @ unroll_index=17\n        points_from_t1_to_t0_chan_0[16][0] = FIFO_125_t1_chan_0_fifo_109; // t1[0](1, 0) @ unroll_index=16\n        points_from_t1_to_t0_chan_0[15][0] = FIFO_125_t1_chan_0_fifo_110; // t1[0](1, 0) @ unroll_index=15\n        points_from_t1_to_t0_chan_0[14][0] = FIFO_125_t1_chan_0_fifo_111; // t1[0](1, 0) @ unroll_index=14\n        points_from_t1_to_t0_chan_0[13][0] = FIFO_125_t1_chan_0_fifo_112; // t1[0](1, 0) @ unroll_index=13\n        points_from_t1_to_t0_chan_0[12][0] = FIFO_125_t1_chan_0_fifo_113; // t1[0](1, 0) @ unroll_index=12\n        points_from_t1_to_t0_chan_0[11][0] = FIFO_125_t1_chan_0_fifo_114; // t1[0](1, 0) @ unroll_index=11\n        points_from_t1_to_t0_chan_0[10][0] = FIFO_125_t1_chan_0_fifo_115; // t1[0](1, 0) @ unroll_index=10\n        points_from_t1_to_t0_chan_0[9][0] = FIFO_125_t1_chan_0_fifo_116; // t1[0](1, 0) @ unroll_index=9\n        points_from_t1_to_t0_chan_0[8][0] = FIFO_125_t1_chan_0_fifo_117; // t1[0](1, 0) @ unroll_index=8\n        points_from_t1_to_t0_chan_0[7][0] = FIFO_125_t1_chan_0_fifo_118; // t1[0](1, 0) @ unroll_index=7\n        points_from_t1_to_t0_chan_0[6][0] = FIFO_125_t1_chan_0_fifo_119; // t1[0](1, 0) @ unroll_index=6\n        points_from_t1_to_t0_chan_0[5][0] = FIFO_125_t1_chan_0_fifo_120; // t1[0](1, 0) @ unroll_index=5\n        points_from_t1_to_t0_chan_0[4][0] = FIFO_125_t1_chan_0_fifo_121; // t1[0](1, 0) @ unroll_index=4\n        points_from_t1_to_t0_chan_0[3][0] = FIFO_125_t1_chan_0_fifo_122; // t1[0](1, 0) @ unroll_index=3\n        points_from_t1_to_t0_chan_0[2][0] = FIFO_125_t1_chan_0_fifo_123; // t1[0](1, 0) @ unroll_index=2\n        points_from_t1_to_t0_chan_0[1][0] = FIFO_125_t1_chan_0_fifo_124; // t1[0](1, 0) @ unroll_index=1\n        points_from_t1_to_t0_chan_0[0][0] = FIFO_125_t1_chan_0_fifo_125; // t1[0](1, 0) @ unroll_index=0\n        points_from_t1_to_t0_chan_0[63][3] = FIFO_124_t1_chan_0_fifo_0; // t1[0](2, 1) @ unroll_index=63\n        points_from_t1_to_t0_chan_0[63][0] = FIFO_124_t1_chan_0_fifo_1; // t1[0](1, 0) @ unroll_index=63\n\ncompute_t0_unrolled:\n        for(int32_t unroll_index = 0; unroll_index < UNROLL_FACTOR; ++unroll_index)\n        {\n#pragma HLS unroll\n#pragma HLS latency min=1\n            float& load_t1_for_t0_chan_0_at_1_0 = points_from_t1_to_t0_chan_0[unroll_index][0];\n            float& load_t1_for_t0_chan_0_at_0_1 = points_from_t1_to_t0_chan_0[unroll_index][1];\n            float& load_t1_for_t0_chan_0_at_1_1 = points_from_t1_to_t0_chan_0[unroll_index][2];\n            float& load_t1_for_t0_chan_0_at_2_1 = points_from_t1_to_t0_chan_0[unroll_index][3];\n            float& load_t1_for_t0_chan_0_at_1_2 = points_from_t1_to_t0_chan_0[unroll_index][4];\n\n            float result_chan_0;\n            float assign_0 = load_t1_for_t0_chan_0_at_1_2;\n            float assign_1 = load_t1_for_t0_chan_0_at_2_1;\n            float assign_2[1];\n#pragma HLS resource variable=assign_2 latency=1 core=RAM_2P_LUTRAM\n            {\n#pragma HLS latency min=1\n                assign_2[0] = assign_0 + assign_1;\n            }\n            float assign_3 = assign_2[0];\n            float assign_4 = load_t1_for_t0_chan_0_at_1_1;\n            float assign_5[1];\n#pragma HLS resource variable=assign_5 latency=1 core=RAM_2P_LUTRAM\n            {\n#pragma HLS latency min=1\n                assign_5[0] = assign_3 + assign_4;\n            }\n            float assign_6 = assign_5[0];\n            float assign_7 = load_t1_for_t0_chan_0_at_1_0;\n            float assign_8[1];\n#pragma HLS resource variable=assign_8 latency=1 core=RAM_2P_LUTRAM\n            {\n#pragma HLS latency min=1\n                assign_8[0] = assign_6 + assign_7;\n            }\n            float assign_9 = assign_8[0];\n            float assign_10 = load_t1_for_t0_chan_0_at_0_1;\n            float assign_11[1];\n#pragma HLS resource variable=assign_11 latency=1 core=RAM_2P_LUTRAM\n            {\n#pragma HLS latency min=1\n                assign_11[0] = assign_9 + assign_10;\n            }\n            float assign_12 = assign_11[0];\n            float assign_13 = (assign_12);\n            float assign_14 = 0.2f;\n            float assign_15[1];\n#pragma HLS resource variable=assign_15 latency=1 core=RAM_2P_LUTRAM\n            {\n#pragma HLS latency min=10\n                assign_15[0] = assign_13 * assign_14;\n            }\n            float assign_16 = assign_15[0];\n            result_chan_0 = assign_16;\n\n            buffer_t0_chan_0[unroll_index] = result_chan_0;\n        } // unroll_index\n\n        // move reuse chain 0 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[125][FIFO_125_t1_ptr] = FF_t1_chan_0[0];\n        }\n        {\n#pragma HLS latency min=1\n            FF_t1_chan_0[0] = FIFO_124_t1_chan_0_fifo_0;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_124_t1_chan_0[0][FIFO_124_t1_ptr] = buffer_t1_chan_0[0];\n        }\n\n        // move reuse chain 1 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[124][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_62;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[62][FIFO_125_t1_ptr] = buffer_t1_chan_0[1];\n        }\n\n        // move reuse chain 2 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[123][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_61;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[61][FIFO_125_t1_ptr] = buffer_t1_chan_0[2];\n        }\n\n        // move reuse chain 3 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[122][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_60;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[60][FIFO_125_t1_ptr] = buffer_t1_chan_0[3];\n        }\n\n        // move reuse chain 4 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[121][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_59;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[59][FIFO_125_t1_ptr] = buffer_t1_chan_0[4];\n        }\n\n        // move reuse chain 5 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[120][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_58;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[58][FIFO_125_t1_ptr] = buffer_t1_chan_0[5];\n        }\n\n        // move reuse chain 6 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[119][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_57;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[57][FIFO_125_t1_ptr] = buffer_t1_chan_0[6];\n        }\n\n        // move reuse chain 7 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[118][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_56;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[56][FIFO_125_t1_ptr] = buffer_t1_chan_0[7];\n        }\n\n        // move reuse chain 8 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[117][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_55;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[55][FIFO_125_t1_ptr] = buffer_t1_chan_0[8];\n        }\n\n        // move reuse chain 9 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[116][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_54;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[54][FIFO_125_t1_ptr] = buffer_t1_chan_0[9];\n        }\n\n        // move reuse chain 10 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[115][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_53;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[53][FIFO_125_t1_ptr] = buffer_t1_chan_0[10];\n        }\n\n        // move reuse chain 11 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[114][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_52;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[52][FIFO_125_t1_ptr] = buffer_t1_chan_0[11];\n        }\n\n        // move reuse chain 12 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[113][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_51;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[51][FIFO_125_t1_ptr] = buffer_t1_chan_0[12];\n        }\n\n        // move reuse chain 13 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[112][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_50;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[50][FIFO_125_t1_ptr] = buffer_t1_chan_0[13];\n        }\n\n        // move reuse chain 14 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[111][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_49;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[49][FIFO_125_t1_ptr] = buffer_t1_chan_0[14];\n        }\n\n        // move reuse chain 15 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[110][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_48;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[48][FIFO_125_t1_ptr] = buffer_t1_chan_0[15];\n        }\n\n        // move reuse chain 16 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[109][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_47;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[47][FIFO_125_t1_ptr] = buffer_t1_chan_0[16];\n        }\n\n        // move reuse chain 17 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[108][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_46;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[46][FIFO_125_t1_ptr] = buffer_t1_chan_0[17];\n        }\n\n        // move reuse chain 18 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[107][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_45;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[45][FIFO_125_t1_ptr] = buffer_t1_chan_0[18];\n        }\n\n        // move reuse chain 19 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[106][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_44;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[44][FIFO_125_t1_ptr] = buffer_t1_chan_0[19];\n        }\n\n        // move reuse chain 20 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[105][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_43;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[43][FIFO_125_t1_ptr] = buffer_t1_chan_0[20];\n        }\n\n        // move reuse chain 21 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[104][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_42;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[42][FIFO_125_t1_ptr] = buffer_t1_chan_0[21];\n        }\n\n        // move reuse chain 22 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[103][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_41;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[41][FIFO_125_t1_ptr] = buffer_t1_chan_0[22];\n        }\n\n        // move reuse chain 23 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[102][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_40;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[40][FIFO_125_t1_ptr] = buffer_t1_chan_0[23];\n        }\n\n        // move reuse chain 24 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[101][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_39;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[39][FIFO_125_t1_ptr] = buffer_t1_chan_0[24];\n        }\n\n        // move reuse chain 25 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[100][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_38;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[38][FIFO_125_t1_ptr] = buffer_t1_chan_0[25];\n        }\n\n        // move reuse chain 26 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[99][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_37;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[37][FIFO_125_t1_ptr] = buffer_t1_chan_0[26];\n        }\n\n        // move reuse chain 27 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[98][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_36;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[36][FIFO_125_t1_ptr] = buffer_t1_chan_0[27];\n        }\n\n        // move reuse chain 28 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[97][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_35;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[35][FIFO_125_t1_ptr] = buffer_t1_chan_0[28];\n        }\n\n        // move reuse chain 29 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[96][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_34;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[34][FIFO_125_t1_ptr] = buffer_t1_chan_0[29];\n        }\n\n        // move reuse chain 30 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[95][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_33;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[33][FIFO_125_t1_ptr] = buffer_t1_chan_0[30];\n        }\n\n        // move reuse chain 31 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[94][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_32;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[32][FIFO_125_t1_ptr] = buffer_t1_chan_0[31];\n        }\n\n        // move reuse chain 32 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[93][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_31;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[31][FIFO_125_t1_ptr] = buffer_t1_chan_0[32];\n        }\n\n        // move reuse chain 33 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[92][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_30;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[30][FIFO_125_t1_ptr] = buffer_t1_chan_0[33];\n        }\n\n        // move reuse chain 34 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[91][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_29;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[29][FIFO_125_t1_ptr] = buffer_t1_chan_0[34];\n        }\n\n        // move reuse chain 35 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[90][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_28;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[28][FIFO_125_t1_ptr] = buffer_t1_chan_0[35];\n        }\n\n        // move reuse chain 36 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[89][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_27;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[27][FIFO_125_t1_ptr] = buffer_t1_chan_0[36];\n        }\n\n        // move reuse chain 37 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[88][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_26;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[26][FIFO_125_t1_ptr] = buffer_t1_chan_0[37];\n        }\n\n        // move reuse chain 38 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[87][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_25;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[25][FIFO_125_t1_ptr] = buffer_t1_chan_0[38];\n        }\n\n        // move reuse chain 39 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[86][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_24;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[24][FIFO_125_t1_ptr] = buffer_t1_chan_0[39];\n        }\n\n        // move reuse chain 40 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[85][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_23;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[23][FIFO_125_t1_ptr] = buffer_t1_chan_0[40];\n        }\n\n        // move reuse chain 41 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[84][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_22;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[22][FIFO_125_t1_ptr] = buffer_t1_chan_0[41];\n        }\n\n        // move reuse chain 42 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[83][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_21;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[21][FIFO_125_t1_ptr] = buffer_t1_chan_0[42];\n        }\n\n        // move reuse chain 43 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[82][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_20;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[20][FIFO_125_t1_ptr] = buffer_t1_chan_0[43];\n        }\n\n        // move reuse chain 44 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[81][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_19;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[19][FIFO_125_t1_ptr] = buffer_t1_chan_0[44];\n        }\n\n        // move reuse chain 45 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[80][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_18;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[18][FIFO_125_t1_ptr] = buffer_t1_chan_0[45];\n        }\n\n        // move reuse chain 46 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[79][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_17;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[17][FIFO_125_t1_ptr] = buffer_t1_chan_0[46];\n        }\n\n        // move reuse chain 47 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[78][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_16;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[16][FIFO_125_t1_ptr] = buffer_t1_chan_0[47];\n        }\n\n        // move reuse chain 48 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[77][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_15;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[15][FIFO_125_t1_ptr] = buffer_t1_chan_0[48];\n        }\n\n        // move reuse chain 49 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[76][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_14;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[14][FIFO_125_t1_ptr] = buffer_t1_chan_0[49];\n        }\n\n        // move reuse chain 50 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[75][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_13;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[13][FIFO_125_t1_ptr] = buffer_t1_chan_0[50];\n        }\n\n        // move reuse chain 51 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[74][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_12;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[12][FIFO_125_t1_ptr] = buffer_t1_chan_0[51];\n        }\n\n        // move reuse chain 52 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[73][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_11;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[11][FIFO_125_t1_ptr] = buffer_t1_chan_0[52];\n        }\n\n        // move reuse chain 53 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[72][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_10;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[10][FIFO_125_t1_ptr] = buffer_t1_chan_0[53];\n        }\n\n        // move reuse chain 54 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[71][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_9;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[9][FIFO_125_t1_ptr] = buffer_t1_chan_0[54];\n        }\n\n        // move reuse chain 55 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[70][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_8;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[8][FIFO_125_t1_ptr] = buffer_t1_chan_0[55];\n        }\n\n        // move reuse chain 56 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[69][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_7;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[7][FIFO_125_t1_ptr] = buffer_t1_chan_0[56];\n        }\n\n        // move reuse chain 57 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[68][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_6;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[6][FIFO_125_t1_ptr] = buffer_t1_chan_0[57];\n        }\n\n        // move reuse chain 58 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[67][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_5;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[5][FIFO_125_t1_ptr] = buffer_t1_chan_0[58];\n        }\n\n        // move reuse chain 59 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[66][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_4;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[4][FIFO_125_t1_ptr] = buffer_t1_chan_0[59];\n        }\n\n        // move reuse chain 60 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[65][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_3;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[3][FIFO_125_t1_ptr] = buffer_t1_chan_0[60];\n        }\n\n        // move reuse chain 61 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[64][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_2;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[2][FIFO_125_t1_ptr] = buffer_t1_chan_0[61];\n        }\n\n        // move reuse chain 62 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[63][FIFO_125_t1_ptr] = FIFO_125_t1_chan_0_fifo_1;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[1][FIFO_125_t1_ptr] = buffer_t1_chan_0[62];\n        }\n\n        // move reuse chain 63 for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_124_t1_chan_0[1][FIFO_124_t1_ptr] = FF_t1_chan_0[1];\n        }\n        {\n#pragma HLS latency min=1\n            FF_t1_chan_0[1] = FIFO_125_t1_chan_0_fifo_0;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_chan_0[0][FIFO_125_t1_ptr] = buffer_t1_chan_0[63];\n        }\n\n        // move FIFO ptrs for buffer t1\n        {\n#pragma HLS latency min=1\n            FIFO_125_t1_ptr = FIFO_125_t1_ptr==uint8_t(125-1) ? 0 : FIFO_125_t1_ptr+1;\n        }\n        {\n#pragma HLS latency min=1\n            FIFO_124_t1_ptr = FIFO_124_t1_ptr==uint8_t(124-1) ? 0 : FIFO_124_t1_ptr+1;\n        }\n        {\n            ap_uint<BURST_WIDTH> tmp_chan_0_bank_0, tmp_chan_0_bank_1, tmp_chan_0_bank_2, tmp_chan_0_bank_3;\nstore_coalesced:\n            for(int j = 0; j < BURST_WIDTH/32; ++j)\n            {\n#pragma HLS unroll\n                float raw_bits_chan_0_bank_0 = buffer_t0_chan_0[BURST_WIDTH/32*4*0+j*4+0];\n                tmp_chan_0_bank_0((j+1)*32-1, j*32) = *(uint32_t*)(&raw_bits_chan_0_bank_0);\n                float raw_bits_chan_0_bank_1 = buffer_t0_chan_0[BURST_WIDTH/32*4*0+j*4+1];\n                tmp_chan_0_bank_1((j+1)*32-1, j*32) = *(uint32_t*)(&raw_bits_chan_0_bank_1);\n                float raw_bits_chan_0_bank_2 = buffer_t0_chan_0[BURST_WIDTH/32*4*0+j*4+2];\n                tmp_chan_0_bank_2((j+1)*32-1, j*32) = *(uint32_t*)(&raw_bits_chan_0_bank_2);\n                float raw_bits_chan_0_bank_3 = buffer_t0_chan_0[BURST_WIDTH/32*4*0+j*4+3];\n                tmp_chan_0_bank_3((j+1)*32-1, j*32) = *(uint32_t*)(&raw_bits_chan_0_bank_3);\n            }\n            to_chan_0_bank_0.write(tmp_chan_0_bank_0);\n            to_chan_0_bank_1.write(tmp_chan_0_bank_1);\n            to_chan_0_bank_2.write(tmp_chan_0_bank_2);\n            to_chan_0_bank_3.write(tmp_chan_0_bank_3);\n        }\n    }\n}\n\n\n\n",
      "level": "lower"
    },
    "jacobi2d_kernel": {
      "code": "#include<float.h>\n#include<math.h>\n#include<stdbool.h>\n#include<stddef.h>\n#include<stdint.h>\n#include<stdio.h>\n#include<string.h>\n#include \"ap_int.h\"\n#include <tlp.h>\n\n#define BURST_WIDTH 512\n#define UNROLL_FACTOR 64\n#define TILE_SIZE_DIM_0 8000\n#ifndef BURST_WIDTH\n#define BURST_WIDTH 512\n#endif//BURST_WIDTH\n\n#if UNROLL_FACTOR != 64\n#error UNROLL_FACTOR != 64\n#endif//UNROLL_FACTOR != 64\n#if TILE_SIZE_DIM_0 != 8000\n#error TILE_SIZE_DIM_0 != 8000\n#endif//TILE_SIZE_DIM_0 != 8000\n#if BURST_WIDTH != 512\n#error BURST_WIDTH != 512\n#endif//BURST_WIDTH != 512\n\n\n\n\n\n\n\n\nextern \"C\" {\n\nvoid jacobi2d_kernel(\n    uint64_t var_output_0_0,\n    uint64_t var_input_0_0,\n    int64_t coalesced_data_num,\n    int64_t tile_data_num,\n    int32_t tile_num_dim_0,\n    int32_t input_size_dim_0,\n    int32_t input_size_dim_1)\n{\n#pragma HLS interface s_axilite port = var_output_0_0 bundle = control\n#pragma HLS interface s_axilite port = var_input_0_0 bundle = control\n#pragma HLS interface s_axilite port = coalesced_data_num bundle = control\n#pragma HLS interface s_axilite port = tile_data_num bundle = control\n#pragma HLS interface s_axilite port = tile_num_dim_0 bundle = control\n#pragma HLS interface s_axilite port = input_size_dim_0 bundle = control\n#pragma HLS interface s_axilite port = input_size_dim_1 bundle = control\n#pragma HLS interface s_axilite port = return bundle = control\n\n{ auto val = reinterpret_cast<volatile uint8_t&>(var_output_0_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(var_input_0_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(coalesced_data_num); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(tile_data_num); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(tile_num_dim_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(input_size_dim_0); }\n{ auto val = reinterpret_cast<volatile uint8_t&>(input_size_dim_1); }\n}\n\n\n}  // extern \"C\"\n\n",
      "fifos": {
        "input_stream_0_0": {
          "consumed_by": [
            "compute",
            0
          ],
          "depth": 32,
          "produced_by": [
            "load",
            0
          ]
        },
        "input_stream_0_1": {
          "consumed_by": [
            "compute",
            0
          ],
          "depth": 32,
          "produced_by": [
            "load",
            0
          ]
        },
        "input_stream_0_2": {
          "consumed_by": [
            "compute",
            0
          ],
          "depth": 32,
          "produced_by": [
            "load",
            0
          ]
        },
        "input_stream_0_3": {
          "consumed_by": [
            "compute",
            0
          ],
          "depth": 32,
          "produced_by": [
            "load",
            0
          ]
        },
        "output_stream_0_0": {
          "consumed_by": [
            "compute",
            1
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            0
          ]
        },
        "output_stream_0_1": {
          "consumed_by": [
            "compute",
            1
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            0
          ]
        },
        "output_stream_0_2": {
          "consumed_by": [
            "compute",
            1
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            0
          ]
        },
        "output_stream_0_3": {
          "consumed_by": [
            "compute",
            1
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            0
          ]
        },
        "output_stream_1_0": {
          "consumed_by": [
            "compute",
            2
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            1
          ]
        },
        "output_stream_1_1": {
          "consumed_by": [
            "compute",
            2
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            1
          ]
        },
        "output_stream_1_2": {
          "consumed_by": [
            "compute",
            2
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            1
          ]
        },
        "output_stream_1_3": {
          "consumed_by": [
            "compute",
            2
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            1
          ]
        },
        "output_stream_2_0": {
          "consumed_by": [
            "compute",
            3
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            2
          ]
        },
        "output_stream_2_1": {
          "consumed_by": [
            "compute",
            3
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            2
          ]
        },
        "output_stream_2_2": {
          "consumed_by": [
            "compute",
            3
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            2
          ]
        },
        "output_stream_2_3": {
          "consumed_by": [
            "compute",
            3
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            2
          ]
        },
        "output_stream_3_0": {
          "consumed_by": [
            "store",
            0
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            3
          ]
        },
        "output_stream_3_1": {
          "consumed_by": [
            "store",
            0
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            3
          ]
        },
        "output_stream_3_2": {
          "consumed_by": [
            "store",
            0
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            3
          ]
        },
        "output_stream_3_3": {
          "consumed_by": [
            "store",
            0
          ],
          "depth": 32,
          "produced_by": [
            "compute",
            3
          ]
        }
      },
      "level": "upper",
      "ports": [
        {
          "cat": "mmap",
          "name": "var_output_0_0",
          "type": "ap_uint<512>*",
          "width": 512
        },
        {
          "cat": "mmap",
          "name": "var_input_0_0",
          "type": "ap_uint<512>*",
          "width": 512
        },
        {
          "cat": "scalar",
          "name": "coalesced_data_num",
          "type": "int64_t",
          "width": 64
        },
        {
          "cat": "scalar",
          "name": "tile_data_num",
          "type": "int64_t",
          "width": 64
        },
        {
          "cat": "scalar",
          "name": "tile_num_dim_0",
          "type": "int32_t",
          "width": 32
        },
        {
          "cat": "scalar",
          "name": "input_size_dim_0",
          "type": "int32_t",
          "width": 32
        },
        {
          "cat": "scalar",
          "name": "input_size_dim_1",
          "type": "int32_t",
          "width": 32
        }
      ],
      "tasks": {
        "compute": [
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "coalesced_data_num"
              },
              "input_size_dim_0": {
                "cat": "scalar",
                "port": "input_size_dim_0"
              },
              "input_size_dim_1": {
                "cat": "scalar",
                "port": "input_size_dim_1"
              },
              "input_stream_0_0": {
                "cat": "istream",
                "port": "from_chan_0_bank_0"
              },
              "input_stream_0_1": {
                "cat": "istream",
                "port": "from_chan_0_bank_1"
              },
              "input_stream_0_2": {
                "cat": "istream",
                "port": "from_chan_0_bank_2"
              },
              "input_stream_0_3": {
                "cat": "istream",
                "port": "from_chan_0_bank_3"
              },
              "output_stream_0_0": {
                "cat": "ostream",
                "port": "to_chan_0_bank_0"
              },
              "output_stream_0_1": {
                "cat": "ostream",
                "port": "to_chan_0_bank_1"
              },
              "output_stream_0_2": {
                "cat": "ostream",
                "port": "to_chan_0_bank_2"
              },
              "output_stream_0_3": {
                "cat": "ostream",
                "port": "to_chan_0_bank_3"
              },
              "tile_data_num": {
                "cat": "scalar",
                "port": "tile_data_num"
              },
              "tile_num_dim_0": {
                "cat": "scalar",
                "port": "tile_num_dim_0"
              }
            },
            "step": 0
          },
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "coalesced_data_num"
              },
              "input_size_dim_0": {
                "cat": "scalar",
                "port": "input_size_dim_0"
              },
              "input_size_dim_1": {
                "cat": "scalar",
                "port": "input_size_dim_1"
              },
              "output_stream_0_0": {
                "cat": "istream",
                "port": "from_chan_0_bank_0"
              },
              "output_stream_0_1": {
                "cat": "istream",
                "port": "from_chan_0_bank_1"
              },
              "output_stream_0_2": {
                "cat": "istream",
                "port": "from_chan_0_bank_2"
              },
              "output_stream_0_3": {
                "cat": "istream",
                "port": "from_chan_0_bank_3"
              },
              "output_stream_1_0": {
                "cat": "ostream",
                "port": "to_chan_0_bank_0"
              },
              "output_stream_1_1": {
                "cat": "ostream",
                "port": "to_chan_0_bank_1"
              },
              "output_stream_1_2": {
                "cat": "ostream",
                "port": "to_chan_0_bank_2"
              },
              "output_stream_1_3": {
                "cat": "ostream",
                "port": "to_chan_0_bank_3"
              },
              "tile_data_num": {
                "cat": "scalar",
                "port": "tile_data_num"
              },
              "tile_num_dim_0": {
                "cat": "scalar",
                "port": "tile_num_dim_0"
              }
            },
            "step": 0
          },
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "coalesced_data_num"
              },
              "input_size_dim_0": {
                "cat": "scalar",
                "port": "input_size_dim_0"
              },
              "input_size_dim_1": {
                "cat": "scalar",
                "port": "input_size_dim_1"
              },
              "output_stream_1_0": {
                "cat": "istream",
                "port": "from_chan_0_bank_0"
              },
              "output_stream_1_1": {
                "cat": "istream",
                "port": "from_chan_0_bank_1"
              },
              "output_stream_1_2": {
                "cat": "istream",
                "port": "from_chan_0_bank_2"
              },
              "output_stream_1_3": {
                "cat": "istream",
                "port": "from_chan_0_bank_3"
              },
              "output_stream_2_0": {
                "cat": "ostream",
                "port": "to_chan_0_bank_0"
              },
              "output_stream_2_1": {
                "cat": "ostream",
                "port": "to_chan_0_bank_1"
              },
              "output_stream_2_2": {
                "cat": "ostream",
                "port": "to_chan_0_bank_2"
              },
              "output_stream_2_3": {
                "cat": "ostream",
                "port": "to_chan_0_bank_3"
              },
              "tile_data_num": {
                "cat": "scalar",
                "port": "tile_data_num"
              },
              "tile_num_dim_0": {
                "cat": "scalar",
                "port": "tile_num_dim_0"
              }
            },
            "step": 0
          },
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "coalesced_data_num"
              },
              "input_size_dim_0": {
                "cat": "scalar",
                "port": "input_size_dim_0"
              },
              "input_size_dim_1": {
                "cat": "scalar",
                "port": "input_size_dim_1"
              },
              "output_stream_2_0": {
                "cat": "istream",
                "port": "from_chan_0_bank_0"
              },
              "output_stream_2_1": {
                "cat": "istream",
                "port": "from_chan_0_bank_1"
              },
              "output_stream_2_2": {
                "cat": "istream",
                "port": "from_chan_0_bank_2"
              },
              "output_stream_2_3": {
                "cat": "istream",
                "port": "from_chan_0_bank_3"
              },
              "output_stream_3_0": {
                "cat": "ostream",
                "port": "to_chan_0_bank_0"
              },
              "output_stream_3_1": {
                "cat": "ostream",
                "port": "to_chan_0_bank_1"
              },
              "output_stream_3_2": {
                "cat": "ostream",
                "port": "to_chan_0_bank_2"
              },
              "output_stream_3_3": {
                "cat": "ostream",
                "port": "to_chan_0_bank_3"
              },
              "tile_data_num": {
                "cat": "scalar",
                "port": "tile_data_num"
              },
              "tile_num_dim_0": {
                "cat": "scalar",
                "port": "tile_num_dim_0"
              }
            },
            "step": 0
          }
        ],
        "load": [
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "data_num"
              },
              "input_stream_0_0": {
                "cat": "ostream",
                "port": "sink_0"
              },
              "input_stream_0_1": {
                "cat": "ostream",
                "port": "sink_1"
              },
              "input_stream_0_2": {
                "cat": "ostream",
                "port": "sink_2"
              },
              "input_stream_0_3": {
                "cat": "ostream",
                "port": "sink_3"
              },
              "var_input_0_0": {
                "cat": "mmap",
                "port": "source"
              }
            },
            "step": 0
          }
        ],
        "store": [
          {
            "args": {
              "coalesced_data_num": {
                "cat": "scalar",
                "port": "data_num"
              },
              "output_stream_3_0": {
                "cat": "istream",
                "port": "source_0"
              },
              "output_stream_3_1": {
                "cat": "istream",
                "port": "source_1"
              },
              "output_stream_3_2": {
                "cat": "istream",
                "port": "source_2"
              },
              "output_stream_3_3": {
                "cat": "istream",
                "port": "source_3"
              },
              "var_output_0_0": {
                "cat": "mmap",
                "port": "sink"
              }
            },
            "step": 0
          }
        ]
      }
    },
    "load": {
      "code": "#include<float.h>\n#include<math.h>\n#include<stdbool.h>\n#include<stddef.h>\n#include<stdint.h>\n#include<stdio.h>\n#include<string.h>\n#include \"ap_int.h\"\n#include <tlp.h>\n\n#define BURST_WIDTH 512\n#define UNROLL_FACTOR 64\n#define TILE_SIZE_DIM_0 8000\n#ifndef BURST_WIDTH\n#define BURST_WIDTH 512\n#endif//BURST_WIDTH\n\n#if UNROLL_FACTOR != 64\n#error UNROLL_FACTOR != 64\n#endif//UNROLL_FACTOR != 64\n#if TILE_SIZE_DIM_0 != 8000\n#error TILE_SIZE_DIM_0 != 8000\n#endif//TILE_SIZE_DIM_0 != 8000\n#if BURST_WIDTH != 512\n#error BURST_WIDTH != 512\n#endif//BURST_WIDTH != 512\n\nvoid load(\n    tlp::ostream<ap_uint<BURST_WIDTH> > &sink_0, \n    tlp::ostream<ap_uint<BURST_WIDTH> > &sink_1, \n    tlp::ostream<ap_uint<BURST_WIDTH> > &sink_2, \n    tlp::ostream<ap_uint<BURST_WIDTH> > &sink_3, \n    tlp::mmap< ap_uint<BURST_WIDTH> > source, \n    int data_num)\n{\n#pragma HLS interface m_axi port = source offset = direct bundle = source\n#pragma HLS data_pack variable = sink_0.fifo\n#pragma HLS data_pack variable = sink_1.fifo\n#pragma HLS data_pack variable = sink_2.fifo\n#pragma HLS data_pack variable = sink_3.fifo\n#pragma HLS data_pack variable = source\n\n\nload_epoch:\n    for(int i = 0; i < data_num; ++i)\n    {\n#pragma HLS pipeline II = 1\n#pragma HLS pipeline II=1\n        sink_0.write(source[i]);\n        sink_1.write(source[i]+1);\n        sink_2.write(source[i]+2);\n        sink_3.write(source[i]+3);\n    }\n}\n\n\n\n\n\n\n\n",
      "level": "lower"
    },
    "store": {
      "code": "#include<float.h>\n#include<math.h>\n#include<stdbool.h>\n#include<stddef.h>\n#include<stdint.h>\n#include<stdio.h>\n#include<string.h>\n#include \"ap_int.h\"\n#include <tlp.h>\n\n#define BURST_WIDTH 512\n#define UNROLL_FACTOR 64\n#define TILE_SIZE_DIM_0 8000\n#ifndef BURST_WIDTH\n#define BURST_WIDTH 512\n#endif//BURST_WIDTH\n\n#if UNROLL_FACTOR != 64\n#error UNROLL_FACTOR != 64\n#endif//UNROLL_FACTOR != 64\n#if TILE_SIZE_DIM_0 != 8000\n#error TILE_SIZE_DIM_0 != 8000\n#endif//TILE_SIZE_DIM_0 != 8000\n#if BURST_WIDTH != 512\n#error BURST_WIDTH != 512\n#endif//BURST_WIDTH != 512\n\n\n\nvoid store(\n    tlp::mmap< ap_uint<BURST_WIDTH> > sink, \n    tlp::istream< ap_uint<BURST_WIDTH> > &source_0, \n    tlp::istream< ap_uint<BURST_WIDTH> > &source_1, \n    tlp::istream< ap_uint<BURST_WIDTH> > &source_2, \n    tlp::istream< ap_uint<BURST_WIDTH> > &source_3, \n    int data_num)\n{\n#pragma HLS interface m_axi port = sink offset = direct bundle = sink\n#pragma HLS data_pack variable = source_0.fifo\n#pragma HLS data_pack variable = source_0.peek_val\n#pragma HLS data_pack variable = source_1.fifo\n#pragma HLS data_pack variable = source_1.peek_val\n#pragma HLS data_pack variable = source_2.fifo\n#pragma HLS data_pack variable = source_2.peek_val\n#pragma HLS data_pack variable = source_3.fifo\n#pragma HLS data_pack variable = source_3.peek_val\n#pragma HLS data_pack variable = sink\n\n\nstore_epoch:\n    for(int i = 0; i < data_num; ++i)\n    {\n#pragma HLS pipeline II = 1\n#pragma HLS pipeline II=1\n        sink[i] = source_0.read() + source_1.read() + source_2.read() + source_3.read();\n    }\n}\n\n\n\n\n\n",
      "level": "lower"
    }
  },
  "top": "jacobi2d_kernel",
  "headers": {
    "hls_half.h": "// half - IEEE 754-based half-precision floating point library.\n//\n// Copyright (c) 2012-2013 Christian Rau <rauy@users.sourceforge.net>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation \n// files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, \n// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the \n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR \n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Version 1.11.0\n\n/// \\file\n/// Main header file for half precision functionality.\n\n#ifndef __HLS_HALF_H__\n#define __HLS_HALF_H__\n\n#ifndef __cplusplus\n#ifndef __SYNTHESIS__ \n#error C++ is required to include this header file\n#endif\n#endif\n#ifndef __SYNTHESIS__\n#include \"cmath\"\n#endif\n\n#ifdef __SYNTHESIS__ \n\n#ifndef _HLS_HALF_DEFINED_\ntypedef __fp16 half;\n#endif\n\n#else // AESL_SYN\n\n// XXX work-around old version of GMP with C++11 <cstddef> used by fpo.\n#include \"cstddef\"\n#include \"hls_fpo.h\"\n\n//Forward declaration of ap_fixed_base.\n#include \"ap_decl.h\"\n\n#ifdef HLS_NO_XIL_FPO_LIB\n//#warning \"Xilinx Floating Point Operator IP core does not provide simulation models for ARM architecture. Then there may be mismatch between simulation model and FPGA implementation\" \n\n#else\n\n// Fiddle an MPFR variable to contain the same information as an xip_fpo_t variable without allocating memory\n// m is the mpfr_t variable (destination), x is the xip_fpo_t variable (source)\n// First variant: copy all information\n#define XIP_FPO_2_MPFR(m, x) \\\n(m)->_mpfr_prec = (x)->_xip_fpo_mant_prec; \\\n(m)->_mpfr_sign = (x)->_xip_fpo_sign;      \\\n(m)->_mpfr_exp  = (x)->_xip_fpo_exp;       \\\n(m)->_mpfr_d    = (x)->_xip_fpo_d;\n\n#endif\n\n/// Combined gcc version number.\n#define HALF_GNUC_VERSION (__GNUC__*100+__GNUC_MINOR__)\n\n//check C++11 language features\n#if defined(__clang__)\t\t\t\t\t\t\t\t\t\t//clang\n\t#if __has_feature(cxx_static_assert) && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if __has_feature(cxx_constexpr) && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t#endif\n\t#if __has_feature(cxx_noexcept) && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t#endif\n\t#if __has_feature(cxx_user_literals) && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n\t\t#define HALF_ENABLE_CPP11_USER_LITERALS 1\n\t#endif\n\t#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L) && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif\n/*#elif defined(__INTEL_COMPILER)\t\t\t\t\t\t\t\t//Intel C++\n\t#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\t\t????????\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_LONG_LONG)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif*/\n#elif defined(__GNUC__)\t\t\t\t\t\t\t\t\t\t//gcc\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L\n\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n\t\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n\t\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 407 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n\t\t\t#define HALF_ENABLE_CPP11_USER_LITERALS 1\n\t\t#endif\n\t\t#if !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t\t#endif\n\t#endif\n#elif defined(_MSC_VER)\t\t\t\t\t\t\t\t\t\t//Visual C++\n\t#if _MSC_VER >= 1600 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if _MSC_VER >= 1310 && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif\n\t#define HALF_POP_WARNINGS 1\n\t#pragma warning(push)\n\t#pragma warning(disable : 4099 4127 4146)\t//struct vs class, constant in if, negative unsigned\n#endif\n\n//check C++11 library features\n#include \"utility\"\n#if defined(_LIBCPP_VERSION)\t\t\t\t\t\t\t\t//libc++\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n\t\t#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CSTDINT\n\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CMATH\n\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_HASH\n\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t#endif\n\t#endif\n#elif defined(__GLIBCXX__)\t\t\t\t\t\t\t\t\t//libstdc++\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n\t\t#ifdef __clang__\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)\n\t\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n\t\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CMATH)\n\t\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_HASH)\n\t\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t\t#endif\n\t\t#else\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n\t\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t\t#endif\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CMATH)\n\t\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t\t#endif\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_HASH)\n\t\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t\t#endif\n\t\t#endif\n\t#endif\n#elif defined(_CPPLIB_VER)\t\t\t\t\t\t\t\t\t//Dinkumware/Visual C++\n\t#if _CPPLIB_VER >= 520\n\t\t#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CSTDINT\n\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_HASH\n\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t#endif\n\t#endif\n\t#if _CPPLIB_VER >= 610\n\t\t#ifndef HALF_ENABLE_CPP11_CMATH\n\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t#endif\n\t#endif\n#endif\n#undef HALF_GNUC_VERSION\n\n//support constexpr\n#if HALF_ENABLE_CPP11_CONSTEXPR\n\t#define HALF_CONSTEXPR\t\t\tconstexpr\n\t#define HALF_CONSTEXPR_CONST\tconstexpr\n#else\n\t#define HALF_CONSTEXPR\n\t#define HALF_CONSTEXPR_CONST\tconst\n#endif\n\n//support noexcept\n#if HALF_ENABLE_CPP11_NOEXCEPT\n\t#define HALF_NOEXCEPT\tnoexcept\n\t#define HALF_NOTHROW\tnoexcept\n#else\n\t#define HALF_NOEXCEPT\n\t#define HALF_NOTHROW\tthrow()\n#endif\n\n#include \"algorithm\"\n#include \"iostream\"\n#include \"limits\"\n#include \"climits\"\n//#include \"cmath\"\n#include \"cstring\"\n#if HALF_ENABLE_CPP11_TYPE_TRAITS\n\t#include \"type_traits\"\n#endif\n#if HALF_ENABLE_CPP11_CSTDINT\n\t#include \"cstdint\"\n#endif\n#if HALF_ENABLE_CPP11_HASH\n\t#include \"functional\"\n#endif\n\n\n/// Default rounding mode.\n/// This specifies the rounding mode used for all conversions between [half](\\ref half)s and `float`s as well as \n/// for the half_cast() if not specifying a rounding mode explicitly. It can be redefined (before including half.hpp) to one \n/// of the standard rounding modes using their respective constants or the equivalent values of `std::float_round_style`:\n///\n/// `std::float_round_style`         | value | rounding\n/// ---------------------------------|-------|-------------------------\n/// `std::round_indeterminate`       | -1    | fastest (default)\n/// `std::round_toward_zero`         | 0     | toward zero\n/// `std::round_to_nearest`          | 1     | to nearest\n/// `std::round_toward_infinity`     | 2     | toward positive infinity\n/// `std::round_toward_neg_infinity` | 3     | toward negative infinity\n///\n/// By default this is set to `-1` (`std::round_indeterminate`), which uses truncation (round toward zero, but with overflows \n/// set to infinity) and is the fastest rounding mode possible. It can even be set to `std::numeric_limits<float>::round_style` \n/// to synchronize the rounding mode with that of the underlying single-precision implementation.\n#ifndef HALF_ROUND_STYLE\n\t#define HALF_ROUND_STYLE\t1\t\t\t// = std::round_indeterminate\n#endif\n\n/// Tie-breaking behaviour for round to nearest.\n/// This specifies if ties in round to nearest should be resolved by rounding to the nearest even value. By default this is \n/// defined to `0` resulting in the faster but slightly more biased behaviour of rounding away from zero in half-way cases (and \n/// thus equal to the round() function), but can be redefined to `1` (before including half.hpp) if more IEEE-conformant \n/// behaviour is needed.\n#ifndef HALF_ROUND_TIES_TO_EVEN\n\t#define HALF_ROUND_TIES_TO_EVEN\t1\t\t// ties away from zero\n#endif\n\n/// Value signaling overflow.\n/// In correspondence with `HUGE_VAL[F|L]` from `<cmath>` this symbol expands to a positive value signaling the overflow of an \n/// operation, in particular it just evaluates to positive infinity.\n#define HUGE_VALH\tstd::numeric_limits<half>::infinity()\n\n/// Fast half-precision fma function.\n/// This symbol is only defined if the fma() function generally executes as fast as, or faster than, a separate \n/// half-precision multiplication followed by an addition. Due to the internal single-precision implementation of all \n/// arithmetic operations, this is in fact always the case.\n#define FP_FAST_FMAH\t1\n\n#ifndef FP_ILOGB0\n\t#define FP_ILOGB0\t\tINT_MIN\n#endif\n#ifndef FP_ILOGBNAN\n\t#define FP_ILOGBNAN\t\tINT_MAX\n#endif\n#ifndef FP_SUBNORMAL\n\t#define FP_SUBNORMAL\t0\n#endif\n#ifndef FP_ZERO\n\t#define FP_ZERO\t\t\t1\n#endif\n#ifndef FP_NAN\n\t#define FP_NAN\t\t\t2\n#endif\n#ifndef FP_INFINITE\n\t#define FP_INFINITE\t\t3\n#endif\n#ifndef FP_NORMAL\n\t#define FP_NORMAL\t\t4\n#endif\n\n\n/// Main namespace for half precision functionality.\n/// This namespace contains all the functionality provided by the library.\n\tclass half;\n\n\t/// \\internal\n\t/// \\brief Implementation details.\n\tnamespace detail\n\t{\n\t#if HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t/// Conditional type.\n\t\ttemplate<bool B,typename T,typename F> struct conditional : std::conditional<B,T,F> {};\n\n\t\t/// Helper for tag dispatching.\n\t\ttemplate<bool B> struct bool_type : std::integral_constant<bool,B> {};\n\t\tusing std::true_type;\n\t\tusing std::false_type;\n\n\t\t/// Type traits for floating point types.\n\t\ttemplate<typename T> struct is_float : std::is_floating_point<T> {};\n\t#else\n\t\t/// Conditional type.\n\t\ttemplate<bool,typename T,typename> struct conditional { typedef T type; };\n\t\ttemplate<typename T,typename F> struct conditional<false,T,F> { typedef F type; };\n\n\t\t/// Helper for tag dispatching.\n\t\ttemplate<bool> struct bool_type {};\n\t\ttypedef bool_type<true> true_type;\n\t\ttypedef bool_type<false> false_type;\n\n\t\t/// Type traits for floating point types.\n\t\ttemplate<typename> struct is_float : false_type {};\n\t\ttemplate<typename T> struct is_float<const T> : is_float<T> {};\n\t\ttemplate<typename T> struct is_float<volatile T> : is_float<T> {};\n\t\ttemplate<typename T> struct is_float<const volatile T> : is_float<T> {};\n\t\ttemplate<> struct is_float<float> : true_type {};\n\t\ttemplate<> struct is_float<double> : true_type {};\n\t\ttemplate<> struct is_float<long double> : true_type {};\n\t#endif\n\n\t#if HALF_ENABLE_CPP11_CSTDINT\n\t\t/// Unsigned integer of (at least) 16 bits width.\n\t\ttypedef std::uint_least16_t uint16;\n\n\t\t/// Unsigned integer of (at least) 32 bits width.\n\t\ttypedef std::uint_least32_t uint32;\n\n\t\t/// Fastest signed integer capable of holding all values of type uint16.\n\t\ttypedef std::int_fast32_t int17;\n\t#else\n\t\t/// Unsigned integer of (at least) 16 bits width.\n\t\ttypedef unsigned short uint16;\n\n\t\t/// Unsigned integer of (at least) 32 bits width.\n\t\ttypedef conditional<std::numeric_limits<unsigned int>::digits>=32,unsigned int,unsigned long>::type uint32;\n\n\t\t/// Fastest signed integer capable of holding all values of type uint16.\n\t\ttypedef conditional<std::numeric_limits<int>::digits>=16,int,long>::type int17;\n\t#endif\n\n\t\t/// Tag type for binary construction.\n\t\tstruct binary_t {};\n\n\t\t/// Tag for binary construction.\n\t\tHALF_CONSTEXPR_CONST binary_t binary = binary_t();\n\n\t\t/// Temporary half-precision expression.\n\t\t/// This class represents a half-precision expression which just stores a single-precision value internally.\n\t\tstruct expr\n\t\t{\n\t\t\t/// Conversion constructor.\n\t\t\t/// \\param f single-precision value to convert\n\t\t\texplicit HALF_CONSTEXPR expr(float f) : value_(f) {}\n\n\t\t\t/// Conversion to single-precision.\n\t\t\t/// \\return single precision value representing expression value\n\t\t\tHALF_CONSTEXPR operator float() const { return value_; }\n\n\t\tprivate:\n\t\t\t/// Internal expression value stored in single-precision.\n\t\t\tfloat value_;\n\t\t};\n\n\t\t/// SFINAE helper for generic half-precision functions.\n\t\t/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n\t\t/// `type` member equivalent to \\a T.\n\t\t/// \\tparam T type to return\n\t\ttemplate<typename T,typename,typename=void,typename=void> struct enable {};\n\t\ttemplate<typename T> struct enable<T,half,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,float,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,double,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,long long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,int,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,short,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,char,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,long long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,int,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,short,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,char,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,float,half,void> { typedef float type; };\n\t\ttemplate<typename T> struct enable<T,half,float,void> { typedef float type; };\n\t\ttemplate<typename T> struct enable<T,double,half,void> { typedef double type; };\n\t\ttemplate<typename T> struct enable<T,half,double,void> { typedef double type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,expr> { typedef T type; };\n\n\t\t/// Return type for specialized generic 2-argument half-precision functions.\n\t\t/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n\t\t/// `type` member denoting the appropriate return type.\n\t\t/// \\tparam T first argument type\n\t\t/// \\tparam U first argument type\n\t\ttemplate<typename T,typename U> struct result : enable<expr,T,U> {};\n\t\ttemplate<> struct result<half,half> { typedef half type; };\n\n\t\t/// \\name Classification helpers\n\t\t/// \\{\n\n\t\t/// Check for infinity.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if infinity\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_isinf(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::isinf(arg);\n\t\t#elif defined(_MSC_VER)\n\t\t\treturn !_finite(static_cast<double>(arg)) && !_isnan(static_cast<double>(arg));\n\t\t#else\n\t\t\treturn arg == std::numeric_limits<T>::infinity() || arg == -std::numeric_limits<T>::infinity();\n\t\t#endif\n\t\t}\n\n\t\t/// Check for NaN.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if not a number\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_isnan(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::isnan(arg);\n\t\t#elif defined(_MSC_VER)\n\t\t\treturn _isnan(static_cast<double>(arg)) != 0;\n\t\t#else\n\t\t\treturn arg != arg;\n\t\t#endif\n\t\t}\n\n\t\t/// Check sign.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if signbit set\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_signbit(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::signbit(arg);\n\t\t#else\n\t\t\treturn arg < T() || (arg == T() && T(1)/arg < T());\n\t\t#endif\n\t\t}\n\n\t\t/// \\}\n\t\t/// \\name Conversion\n\t\t/// \\{\n\n\t\t/// Convert IEEE single-precision to half-precision.\n\t\t/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half_impl(float value, true_type)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT\n\t\t\tstatic_assert(std::numeric_limits<float>::is_iec559, \"float to half conversion needs IEEE 754 conformant 'float' type\");\n\t\t\tstatic_assert(sizeof(uint32)==sizeof(float), \"float to half conversion needs unsigned integer type of exactly the size of a 'float'\");\n\t\t#endif\n\t\t\tstatic const uint16 base_table[512] = { \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, \n\t\t\t\t0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00, \n\t\t\t\t0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100, \n\t\t\t\t0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00, \n\t\t\t\t0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };\n\t\t\tstatic const unsigned char shift_table[512] = { \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n\t\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n\t\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };\n\t\t\tuint32 bits;// = *reinterpret_cast<uint32*>(&value);\t\t//violating strict aliasing!\n\t\t\tstd::memcpy(&bits, &value, sizeof(float));\n\t\t\tuint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);\n\t\t\tif(R == std::round_to_nearest)\n\t\t\t\thbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)\n\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t& (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)\n\t\t\t\t#endif\n\t\t\t\t;\n\t\t\telse if(R == std::round_toward_zero)\n\t\t\t\thbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];\n\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\thbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&\n\t\t\t\t\t((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));\n\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\thbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&\n\t\t\t\t\t((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));\n\t\t\treturn hbits;\n\t\t}\n\n\t\t/// Convert non-IEEE single-precision to half-precision.\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half_impl(float value, false_type)\n\t\t{\n\t\t\tuint16 hbits = builtin_signbit(value) << 15;\n\t\t\tif(value == 0.0f)\n\t\t\t\treturn hbits;\n\t\t\tif(builtin_isnan(value))\n\t\t\t\treturn hbits | 0x7FFF;\n\t\t\tif(builtin_isinf(value))\n\t\t\t\treturn hbits | 0x7C00;\n\t\t\tint exp;\n\t\t\tstd::frexp(value, &exp);\n\t\t\tif(exp > 16)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_zero)\n\t\t\t\t\treturn hbits | 0x7BFF;\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\treturn hbits | 0x7C00 - (hbits>>15);\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\treturn hbits | 0x7BFF + (hbits>>15);\n\t\t\t\treturn hbits | 0x7C00;\n\t\t\t}\n\t\t\tif(exp < -13)\n\t\t\t\tvalue = std::ldexp(value, 24);\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = std::ldexp(value, 11-exp);\n\t\t\t\thbits |= ((exp+14)<<10);\n\t\t\t}\n\t\t\tint ival = static_cast<int>(value);\n\t\t\thbits |= static_cast<uint16>(std::abs(ival)&0x3FF);\n\t\t\tif(R == std::round_to_nearest)\n\t\t\t{\n\t\t\t\tfloat diff = std::abs(value-static_cast<float>(ival));\n\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\thbits += (diff>0.5f) | ((diff==0.5f)&hbits);\n\t\t\t\t#else\n\t\t\t\t\thbits += diff >= 0.5f;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\thbits += value > static_cast<float>(ival);\n\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\thbits += value < static_cast<float>(ival);\n\t\t\treturn hbits;\n\t\t}\n\n\t\t/// Convert single-precision to half-precision.\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half(float value)\n\t\t{\n\t\t\treturn float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n\t\t}\n\n\t\t/// Convert integer to half-precision floating point.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam S `true` if value negative, `false` else\n\t\t/// \\tparam T type to convert (builtin integer type)\n\t\t/// \\param value non-negative integral value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)\n\t\t{\n\t\t\tif(S)\n\t\t\t\tvalue = -value;\n\t\t\tuint16 bits = S << 15;\n\t\t\tif(value > 65504)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_infinity)\n\t\t\t\t\tbits |= 0x7C00 - S;\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tbits |= 0x7BFF + S;\n\t\t\t\telse\n\t\t\t\t\tbits |= 0x7BFF + (R!=std::round_toward_zero);\n\t\t\t}\n\t\t\telse if(value)\n\t\t\t{\n\t\t\t\tunsigned int m = value, exp = 25;\n\t\t\t\tfor(; m<0x400; m<<=1,--exp) ;\n\t\t\t\tfor(; m>0x7FF; m>>=1,++exp) ;\n\t\t\t\tbits |= (exp<<10) | (m&0x3FF);\n\t\t\t\tif(exp > 25)\n\t\t\t\t{\n\t\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\t\tbits += (value>>(exp-26)) & 1\n\t\t\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t\t\t& (((((1<<(exp-26))-1)&value)!=0)|bits)\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t;\n\t\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\t\tbits += ((value&((1<<(exp-25))-1))!=0) & !S;\n\t\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\t\tbits += ((value&((1<<(exp-25))-1))!=0) & S;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bits;\n\t\t}\n\n\t\t/// Convert integer to half-precision floating point.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam T type to convert (builtin integer type)\n\t\t/// \\param value integral value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R,typename T> uint16 int2half(T value)\n\t\t{\n\t\t\treturn (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);\n\t\t}\n\n\t\t/// Convert half-precision to IEEE single-precision.\n\t\t/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float_impl(uint16 value, true_type)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT\n\t\t\tstatic_assert(std::numeric_limits<float>::is_iec559, \"half to float conversion needs IEEE 754 conformant 'float' type\");\n\t\t\tstatic_assert(sizeof(uint32)==sizeof(float), \"half to float conversion needs unsigned integer type of exactly the size of a 'float'\");\n\t\t#endif\n\t\t\tstatic const uint32 mantissa_table[2048] = { \n\t\t\t\t0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000, \n\t\t\t\t0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000, \n\t\t\t\t0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000, \n\t\t\t\t0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000, \n\t\t\t\t0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000, \n\t\t\t\t0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000, \n\t\t\t\t0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000, \n\t\t\t\t0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000, \n\t\t\t\t0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000, \n\t\t\t\t0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000, \n\t\t\t\t0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000, \n\t\t\t\t0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000, \n\t\t\t\t0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000, \n\t\t\t\t0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000, \n\t\t\t\t0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000, \n\t\t\t\t0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000, \n\t\t\t\t0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000, \n\t\t\t\t0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000, \n\t\t\t\t0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000, \n\t\t\t\t0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000, \n\t\t\t\t0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000, \n\t\t\t\t0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000, \n\t\t\t\t0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000, \n\t\t\t\t0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000, \n\t\t\t\t0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000, \n\t\t\t\t0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000, \n\t\t\t\t0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000, \n\t\t\t\t0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000, \n\t\t\t\t0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000, \n\t\t\t\t0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000, \n\t\t\t\t0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000, \n\t\t\t\t0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000, \n\t\t\t\t0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000, \n\t\t\t\t0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000, \n\t\t\t\t0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000, \n\t\t\t\t0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000, \n\t\t\t\t0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000, \n\t\t\t\t0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000, \n\t\t\t\t0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000, \n\t\t\t\t0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000, \n\t\t\t\t0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000, \n\t\t\t\t0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000, \n\t\t\t\t0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000, \n\t\t\t\t0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000, \n\t\t\t\t0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000, \n\t\t\t\t0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000, \n\t\t\t\t0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000, \n\t\t\t\t0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000, \n\t\t\t\t0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000, \n\t\t\t\t0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000, \n\t\t\t\t0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000, \n\t\t\t\t0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000, \n\t\t\t\t0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000, \n\t\t\t\t0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000, \n\t\t\t\t0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000, \n\t\t\t\t0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000, \n\t\t\t\t0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000, \n\t\t\t\t0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000, \n\t\t\t\t0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000, \n\t\t\t\t0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000, \n\t\t\t\t0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000, \n\t\t\t\t0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000, \n\t\t\t\t0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000, \n\t\t\t\t0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000, \n\t\t\t\t0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000, \n\t\t\t\t0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000, \n\t\t\t\t0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000, \n\t\t\t\t0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000, \n\t\t\t\t0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000, \n\t\t\t\t0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000, \n\t\t\t\t0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000, \n\t\t\t\t0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000, \n\t\t\t\t0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000, \n\t\t\t\t0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000, \n\t\t\t\t0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000, \n\t\t\t\t0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000, \n\t\t\t\t0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000, \n\t\t\t\t0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000, \n\t\t\t\t0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000, \n\t\t\t\t0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000, \n\t\t\t\t0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000, \n\t\t\t\t0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000, \n\t\t\t\t0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000, \n\t\t\t\t0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000, \n\t\t\t\t0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000, \n\t\t\t\t0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000, \n\t\t\t\t0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000, \n\t\t\t\t0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000, \n\t\t\t\t0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000, \n\t\t\t\t0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000, \n\t\t\t\t0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000, \n\t\t\t\t0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000, \n\t\t\t\t0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000, \n\t\t\t\t0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000, \n\t\t\t\t0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000, \n\t\t\t\t0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000, \n\t\t\t\t0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000, \n\t\t\t\t0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000, \n\t\t\t\t0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000, \n\t\t\t\t0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000, \n\t\t\t\t0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000, \n\t\t\t\t0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000, \n\t\t\t\t0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000, \n\t\t\t\t0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000, \n\t\t\t\t0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000, \n\t\t\t\t0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000, \n\t\t\t\t0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000, \n\t\t\t\t0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000, \n\t\t\t\t0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000, \n\t\t\t\t0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000, \n\t\t\t\t0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000, \n\t\t\t\t0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000, \n\t\t\t\t0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000, \n\t\t\t\t0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000, \n\t\t\t\t0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000, \n\t\t\t\t0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000, \n\t\t\t\t0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000, \n\t\t\t\t0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000, \n\t\t\t\t0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000, \n\t\t\t\t0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000, \n\t\t\t\t0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000, \n\t\t\t\t0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000, \n\t\t\t\t0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000, \n\t\t\t\t0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000, \n\t\t\t\t0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000, \n\t\t\t\t0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000, \n\t\t\t\t0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000, \n\t\t\t\t0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };\n\t\t\tstatic const uint32 exponent_table[64] = { \n\t\t\t\t0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000, \n\t\t\t\t0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000, \n\t\t\t\t0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000, \n\t\t\t\t0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };\n\t\t\tstatic const unsigned short offset_table[64] = { \n\t\t\t\t   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, \n\t\t\t\t   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };\n\t\t\tuint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];\n//\t\t\tuint32 bits = mantissa_table[(((value&0x7C00)!=0)<<10)+(value&0x3FF)] + exponent_table[value>>10];\n//\t\t\treturn *reinterpret_cast<float*>(&bits);\t\t\t//violating strict aliasing!\n\t\t\tfloat out;\n\t\t\tstd::memcpy(&out, &bits, sizeof(float));\n\t\t\treturn out;\n\t\t}\n\n\t\t/// Convert half-precision to non-IEEE single-precision.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float_impl(uint16 value, false_type)\n\t\t{\n\t\t\tfloat out;\n\t\t\tint abs = value & 0x7FFF;\n\t\t\tif(abs > 0x7C00)\n\t\t\t\tout = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;\n\t\t\telse if(abs == 0x7C00)\n\t\t\t\tout = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();\n\t\t\telse if(abs > 0x3FF)\n\t\t\t\tout = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);\n\t\t\telse\n\t\t\t\tout = std::ldexp(static_cast<float>(abs), -24);\n\t\t\treturn (value&0x8000) ? -out : out;\n\t\t}\n\n\t\t/// Convert half-precision to single-precision.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float(uint16 value)\n\t\t{\n\t\t\treturn half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n\t\t}\n\n\t\t/// Convert half-precision floating point to integer.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam E `true` for round to even, `false` for round away from zero\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)\n\t\t{\n\t\t\tunsigned int e = value & 0x7FFF;\n\t\t\tif(e >= 0x7C00)\n\t\t\t\treturn (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();\n\t\t\tif(e < 0x3800)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_infinity)\n\t\t\t\t\treturn T(~(value>>15)&(e!=0));\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\treturn -T(value>0x8000);\n\t\t\t\treturn T();\n\t\t\t}\n\t\t\tint17 m = (value&0x3FF) | 0x400;\n\t\t\te >>= 10;\n\t\t\tif(e < 25)\n\t\t\t{\n\t\t\t\tif(R == std::round_indeterminate || R == std::round_toward_zero)\n\t\t\t\t\tm >>= 25 - e;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\t\tm += (1<<(24-e)) - (~(m>>(25-e))&E);\n\t\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\t\tm += ((value>>15)-1) & ((1<<(25-e))-1U);\n\t\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\t\tm += -(value>>15) & ((1<<(25-e))-1U);\n\t\t\t\t\tm >>= 25 - e;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tm <<= e - 25;\n//\t\t\tif(std::numeric_limits<T>::digits < 16)\n//\t\t\t\treturn std::min(std::max(m, static_cast<int17>(std::numeric_limits<T>::min())), static_cast<int17>(std::numeric_limits<T>::max()));\n\t\t\treturn static_cast<T>((value&0x8000) ? -m : m);\n\t\t}\n\n\t\t/// Convert half-precision floating point to integer.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,HALF_ROUND_TIES_TO_EVEN,T>(value); }\n\n\t\t/// Convert half-precision floating point to integer using round-to-nearest-away-from-zero.\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }\n\n\t\t/// Round half-precision number to nearest integer value.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam E `true` for round to even, `false` for round away from zero\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\ttemplate<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)\n\t\t{\n\t\t\tunsigned int e = value & 0x7FFF;\n\t\t\tuint16 result = value;\n\t\t\tif(e < 0x3C00)\n\t\t\t{\n\t\t\t\tresult &= 0x8000;\n\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\tresult |= 0x3C00U & -(e>=(0x3800+E));\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\tresult |= 0x3C00U & -(~(value>>15)&(e!=0));\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tresult |= 0x3C00U & -(value>0x8000);\n\t\t\t}\n\t\t\telse if(e < 0x6400)\n\t\t\t{\n\t\t\t\te = 25 - (e>>10);\n\t\t\t\tunsigned int mask = (1<<e) - 1;\n\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\tresult += (1<<(e-1)) - (~(result>>e)&E);\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\tresult += mask & ((value>>15)-1);\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tresult += mask & -(value>>15);\n\t\t\t\tresult &= ~mask;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// Round half-precision number to nearest integer value.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\ttemplate<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,HALF_ROUND_TIES_TO_EVEN>(value); }\n\n\t\t/// Round half-precision number to nearest integer value using round-to-nearest-away-from-zero.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\tinline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }\n\t\t/// \\}\n\n\t\tstruct functions;\n\t\ttemplate<typename> struct unary_specialized;\n\t\ttemplate<typename,typename> struct binary_specialized;\n\t\ttemplate<typename,typename,std::float_round_style> struct half_caster;\n\t}\n\n\t/// Half-precision floating point type.\n\t/// This class implements an IEEE-conformant half-precision floating point type with the usual arithmetic operators and \n\t/// conversions. It is implicitly convertible to single-precision floating point, which makes artihmetic expressions and \n\t/// functions with mixed-type operands to be of the most precise operand type. Additionally all arithmetic operations \n\t/// (and many mathematical functions) are carried out in single-precision internally. All conversions from single- to \n\t/// half-precision are done using truncation (round towards zero), but temporary results inside chained arithmetic \n\t/// expressions are kept in single-precision as long as possible (while of course still maintaining a strong half-precision type).\n\t///\n\t/// According to the C++98/03 definition, the half type is not a POD type. But according to C++11's less strict and \n\t/// extended definitions it is both a standard layout type and a trivially copyable type (even if not a POD type), which \n\t/// means it can be standard-conformantly copied using raw binary copies. But in this context some more words about the \n\t/// actual size of the type. Although the half is representing an IEEE 16-bit type, it does not neccessarily have to be of \n\t/// exactly 16-bits size. But on any reasonable implementation the actual binary representation of this type will most \n\t/// probably not ivolve any additional \"magic\" or padding beyond the simple binary representation of the underlying 16-bit \n\t/// IEEE number, even if not strictly guaranteed by the standard. But even then it only has an actual size of 16 bits if \n\t/// your C++ implementation supports an unsigned integer type of exactly 16 bits width. But this should be the case on \n\t/// nearly any reasonable platform.\n\t///\n\t/// So if your C++ implementation is not totally exotic or imposes special alignment requirements, it is a reasonable \n\t/// assumption that the data of a half is just comprised of the 2 bytes of the underlying IEEE representation.\n\tclass half\n\t{\n\t\tfriend struct detail::functions;\n\t\tfriend struct detail::unary_specialized<half>;\n\t\tfriend struct detail::binary_specialized<half,half>;\n\t\ttemplate<typename,typename,std::float_round_style> friend struct detail::half_caster;\n\t\tfriend struct std::numeric_limits<half>;\n\t#if HALF_ENABLE_CPP11_HASH\n\t\tfriend struct std::hash<half>;\n\t#endif\n\n\tpublic:\n\t\t/// Default constructor.\n\t\t/// This initializes the half to 0. Although this does not match the builtin types' default-initialization semantics \n\t\t/// and may be less efficient than no initialization, it is needed to provide proper value-initialization semantics.\n\t\tHALF_CONSTEXPR half() : data_() {}\n\n\t\t/// Copy constructor.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to copy from\n\t\thalf(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {\n#ifndef HLS_NO_XIL_FPO_LIB\n            xip_fpo_half_set_flt(rhs);\n#endif\n        }\n\n\t\t/// Conversion constructor.\n\t\t/// \\param rhs float to convert\n\t\thalf(float rhs) : data_(detail::float2half<round_style>(rhs)) {\n#ifndef HLS_NO_XIL_FPO_LIB\n            xip_fpo_half_set_flt(rhs);\n#endif\n        }\n\n        /// Conversion constructor from AP types.\n\t\ttemplate<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\n\t\thalf(const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& rhs) {\n\t\t\tstd::cout << \"WARNING: explicit method ap_fixed::to_half() should be used to convert ap_fixed to half.\" << std::endl;\n\t\t\t*this = rhs.to_half();\n\t\t}\n\n\t\t/// Conversion to single-precision.\n\t\t/// \\return single precision value representing expression value\n\t\toperator float() const {\n#ifdef HLS_NO_XIL_FPO_LIB\n            return detail::half2float(data_);\n#else\n            return xip_fpo_half_get_flt();\n#endif\n        }\n\n\t\t/// Assignment operator.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to copy from\n\t\t/// \\return reference to this half\n\t\thalf& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to add\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to subtract\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to multiply with\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to divide by\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }\n\n#if 0\n\t\t/* disable to avoid ambiguous overload. */\n\t\t/// Assignment operator.\n\t\t/// \\param rhs single-precision value to copy from\n\t\t/// \\return reference to this half\n\t\thalf& operator=(float rhs) { \n#ifdef HLS_NO_XIL_FPO_LIB\n                    data_ = detail::float2half<round_style>(rhs);\n#else\n                    xip_fpo_half_set_flt(rhs);\n#endif\n                    return *this; \n                }\n#endif\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to add\n\t\t/// \\return reference to this half\n\t\t//half& operator+=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)+rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to subtract\n\t\t/// \\return reference to this half\n\t\t//half& operator-=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)-rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to multiply with\n\t\t/// \\return reference to this half\n\t\t//half& operator*=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)*rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to divide by\n\t\t/// \\return reference to this half\n\t\t//half& operator/=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)/rhs); return *this; }\n\n\t\t/// Prefix increment.\n\t\t/// \\return incremented half value\n\t\thalf& operator++() { return *this += 1.0f; }\n\n\t\t/// Prefix decrement.\n\t\t/// \\return decremented half value\n\t\thalf& operator--() { return *this -= 1.0f; }\n\n\t\t/// Postfix increment.\n\t\t/// \\return non-incremented half value\n\t\thalf operator++(int) { half out(*this); ++*this; return out; }\n\n\t\t/// Postfix decrement.\n\t\t/// \\return non-decremented half value\n\t\thalf operator--(int) { half out(*this); --*this; return out; }\n\n        /// Get half internal uint16 representation\n        /// \\return packed uint16 data\n        detail::uint16 get_bits() { return data_; }\n\t\t\n        /// Set half internal uint16 representation\n        /// \\return\n        void set_bits(detail::uint16 bits) { data_ = bits; }\n\n\t\n#ifndef HLS_NO_XIL_FPO_LIB\n        /// Assign value from half data to xip_fpo struct\n        /// \\return xip_fpo exceptions\n        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {\n            int exc = 0;\n            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);\n            op->_xip_fpo_exp  = ((data_ & 0x7C00) >> 10) - 14;\n            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);\n            if ((data_ & 0x7C00) == 0) { // subnormal\n                exc |= 0x1;\n                xip_fpo_set_zero(op, op->_xip_fpo_sign);\n            } else if ((data_ & 0x7FFF) == 0x7C00) { // infinity\n                exc |= 0x2;\n                xip_fpo_set_inf(op, op->_xip_fpo_sign);\n            } else if ((data_ & 0x7FFF) > 0x7C00) { // NaN\n                exc |= 0x4;\n                xip_fpo_set_nan(op);\n            }\n            return exc;\n        }\n\n        /// Convert\n        float xip_fpo_half_get_flt() const {\n            xip_fpo_t op;\n            xip_fpo_init2(op, 5, 11);\n            xip_fpo_exc_t exc = xip_fpo_get_data(op);\n            float res;\n            if (exc & 0x1) {\n                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);\n            } else if (exc & 0x2) {\n                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());\n            } else if (exc & 0x4) {\n                res = std::numeric_limits<float>::quiet_NaN();\n            } else {\n                res = xip_fpo_get_flt(op);\n            }\n            xip_fpo_clear(op);\n            return res;\n        }\n\n        /// Assign value from xip_fpo struct to half data\n        /// \\return void\n        void xip_fpo_set_data(xip_fpo_ptr op) {\n            mpfr_t fr;\n            XIP_FPO_2_MPFR(fr, op);\n            data_ = 0;\n            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;\n            if (mpfr_zero_p(fr)) {\n                data_ &= 0x8000;\n            } else if (mpfr_inf_p(fr)) {\n                data_ |= 0x7C00;\n            } else if (mpfr_nan_p(fr)) {\n                data_ |= 0x7E00;\n            } else {\n                data_ |= (op->_xip_fpo_exp + 14) << 10;\n                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);\n            }\n        }\n        \n        /// Assignment\n        void xip_fpo_half_set_flt(float rhs) {\n            xip_fpo_t op;\n            xip_fpo_init2(op, 5, 11);\n            xip_fpo_set_flt(op, rhs);\n            xip_fpo_set_data(op);\n            xip_fpo_clear(op);\n        }\n#endif\n\n        private:\n\t\t/// Rounding mode to use (always `std::round_indeterminate`)\n\t\tstatic const std::float_round_style round_style = (std::float_round_style)(HALF_ROUND_STYLE);\n\n\t\t/// Constructor.\n\t\t/// \\param bits binary representation to set half to\n\t\tHALF_CONSTEXPR half(detail::binary_t, detail::uint16 bits) : data_(bits) {}\n\n\t\t/// Internal binary representation\n\t\tdetail::uint16 data_;\n\t};\n\n    // half simulation model with Xilinx Floating Point Operator IP core\n#ifndef HLS_NO_XIL_FPO_LIB\n    template<typename F>\n    half math_function_1arg(F f, half x) {\n        half res;\n        xip_fpo_t rop, xop;\n        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        f(rop, xop);\n        res.xip_fpo_set_data(rop);\n        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);\n        return res;\n    }\n\n    template<typename F>\n    half binary_operator(F f, half x, half y) {\n        half res;\n        xip_fpo_t op, xop, yop;\n        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        y.xip_fpo_get_data(yop);\n        f(op, xop, yop);\n        res.xip_fpo_set_data(op);\n        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);\n        return res;\n    }\n    // perform comparison\n    template<typename F>\n    bool binary_operator_compare(F f, half x, half y) {\n        int res;\n        xip_fpo_t xop, yop;\n        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        y.xip_fpo_get_data(yop);\n        f(&res, xop, yop);\n        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);\n        return res;\n    }\n#endif \n\n#if HALF_ENABLE_CPP11_USER_LITERALS\n\t/// Library-defined half-precision literals.\n\t/// Import this namespace to enable half-precision floating point literals:\n\t/// ~~~~{.cpp}\n\t/// using namespace literal;\n\t/// half = 4.2_h;\n\t/// ~~~~\n\tnamespace literal\n\t{\n\t\t/// Half literal.\n\t\t/// While this returns an actual half-precision value, half literals can unfortunately not be constant expressions due \n\t\t/// to rather involved single-to-half conversion.\n\t\t/// \\param value literal value\n\t\t/// \\return half with given value (if representable)\n\t\tinline half operator \"\" _h(long double value) { return half(static_cast<float>(value)); }\n\t}\n#endif\n\n\n\tnamespace detail\n\t{\n\t\t/// Wrapper implementing unspecialized half-precision functions.\n\t\tstruct functions\n\t\t{\n\t\t\t/// Addition implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision sum\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr plus(float x, float y) { return expr(x+y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }\n\t\t\tstatic float plus(float x, half y) { return HLS_FPO_ADDF(x,y); }\n\t\t\tstatic float plus(half x, float y) { return HLS_FPO_ADDF(x,y); }\n\t\t\tstatic double plus(double x, half y) { return HLS_FPO_ADD(x,y); }\n\t\t\tstatic double plus(half x, double y) { return HLS_FPO_ADD(x,y); }\n#endif\n\n\t\t\t/// Subtraction implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision difference \n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr minus(float x, float y) { return expr(x-y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }\n\t\t\tstatic float minus(float x, half y) { return HLS_FPO_SUBF(x,y); }\n\t\t\tstatic float minus(half x, float y) { return HLS_FPO_SUBF(x,y); }\n\t\t\tstatic double minus(double x, half y) { return HLS_FPO_SUB(x,y); }\n\t\t\tstatic double minus(half x, double y) { return HLS_FPO_SUB(x,y); }\n#endif\n\n\t\t\t/// Multiplication implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision product \n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr multiplies(float x, float y) { return expr(x*y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }\n\t\t\tstatic float multiplies(float x, half y) { return HLS_FPO_MULF(x,y); }\n\t\t\tstatic float multiplies(half x, float y) { return HLS_FPO_MULF(x,y); }\n\t\t\tstatic double multiplies(double x, half y) { return HLS_FPO_MUL(x,y); }\n\t\t\tstatic double multiplies(half x, double y) { return HLS_FPO_MUL(x,y); }\n#endif\n\n\t\t\t/// Division implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision quotient\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr divides(float x, float y) { return expr(x/y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }\n\t\t\tstatic float divides(float x, half y) { return HLS_FPO_DIVF(x,y); }\n\t\t\tstatic float divides(half x, float y) { return HLS_FPO_DIVF(x,y); }\n\t\t\tstatic double divides(double x, half y) { return HLS_FPO_DIV(x,y); }\n\t\t\tstatic double divides(half x, double y) { return HLS_FPO_DIV(x,y); }\n#endif\n\n\t\t\t/// Output implementation.\n\t\t\t/// \\param out stream to write to\n\t\t\t/// \\param arg value to write\n\t\t\t/// \\return reference to stream\n\t\t\ttemplate<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }\n\n\t\t\t/// Input implementation.\n\t\t\t/// \\param in stream to read from\n\t\t\t/// \\param arg half to read into\n\t\t\t/// \\return reference to stream\n\t\t\ttemplate<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)\n\t\t\t{\n\t\t\t\tfloat f;\n\t\t\t\tif(in >> f)\n\t\t\t\t\targ = f;\n\t\t\t\treturn in;\n\t\t\t}\n\n\t\t\t/// Modulo implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr fmod(float x, float y) { return expr(std::fmod(x, y)); }\n\n\t\t\t/// Remainder implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr remainder(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::remainder(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x) || builtin_isnan(y))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tfloat ax = std::fabs(x), ay = std::fabs(y);\n\t\t\t\tif(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tif(ay >= 65536.0f)\n\t\t\t\t\treturn expr(x);\n\t\t\t\tif(ax == ay)\n\t\t\t\t\treturn expr(builtin_signbit(x) ? -0.0f : 0.0f);\n\t\t\t\tax = std::fmod(ax, ay+ay);\n\t\t\t\tfloat y2 = 0.5f * ay;\n\t\t\t\tif(ax > y2)\n\t\t\t\t{\n\t\t\t\t\tax -= ay;\n\t\t\t\t\tif(ax >= y2)\n\t\t\t\t\t\tax -= ay;\n\t\t\t\t}\n\t\t\t\treturn expr(builtin_signbit(x) ? -ax : ax);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Remainder implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\param quo address to store quotient bits at\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr remquo(float x, float y, int *quo)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::remquo(x, y, quo));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x) || builtin_isnan(y))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tbool sign = builtin_signbit(x), qsign = static_cast<bool>(sign^builtin_signbit(y));\n\t\t\t\tfloat ax = std::fabs(x), ay = std::fabs(y);\n\t\t\t\tif(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tif(ay >= 65536.0f)\n\t\t\t\t\treturn expr(x);\n\t\t\t\tif(ax == ay)\n\t\t\t\t\treturn *quo = qsign ? -1 : 1, expr(sign ? -0.0f : 0.0f);\n\t\t\t\tax = std::fmod(ax, 8.0f*ay);\n\t\t\t\tint cquo = 0;\n\t\t\t\tif(ax >= 4.0f * ay)\n\t\t\t\t{\n\t\t\t\t\tax -= 4.0f * ay;\n\t\t\t\t\tcquo += 4;\n\t\t\t\t}\n\t\t\t\tif(ax >= 2.0f * ay)\n\t\t\t\t{\n\t\t\t\t\tax -= 2.0f * ay;\n\t\t\t\t\tcquo += 2;\n\t\t\t\t}\n\t\t\t\tfloat y2 = 0.5f * ay;\n\t\t\t\tif(ax > y2)\n\t\t\t\t{\n\t\t\t\t\tax -= ay;\n\t\t\t\t\t++cquo;\n\t\t\t\t\tif(ax >= y2)\n\t\t\t\t\t{\n\t\t\t\t\t\tax -= ay;\n\t\t\t\t\t\t++cquo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *quo = qsign ? -cquo : cquo, expr(sign ? -ax : ax);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Positive difference implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Positive difference stored in single-precision\n\t\t\tstatic expr fdim(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fdim(x, y));\n\t\t\t#else\n\t\t\t\treturn expr((x<=y) ? 0.0f : (x-y));\n\t\t\t#endif\n\t\t\t}\n\n                        static expr maxmag(float x, float y)\n                        {\n\t\t\t\tif (fabs(y)>fabs(x)) return expr(y);\n\t\t\t\telse return expr(x);\n                        }\n\n                        static expr minmag(float x, float y)\n                        {\n\t\t\t\tif (fabs(y)<fabs(x)) return expr(y);\n\t\t\t\telse return expr(x);\n                        }\n\n\t\t\t/// Fused multiply-add implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\param z third operand\n\t\t\t/// \\return \\a x * \\a y + \\a z stored in single-precision\n\t\t\tstatic expr fma(float x, float y, float z)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH && defined(FP_FAST_FMAF)\n\t\t\t\treturn expr(std::fma(x, y, z));\n\t\t\t#else\n\t\t\t\treturn expr(x*y+z);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Get NaN.\n\t\t\t/// \\return Half-precision quiet NaN\n\t\t\tstatic half nanh(const char*) { return half(binary, 0x7FFF); }\n\n\t\t\t/// Exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr exp(float arg) { return expr(std::exp(arg)); }\n\n\t\t\t/// Exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr expm1(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::expm1(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::exp(static_cast<double>(arg))-1.0));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Binary exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr exp2(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::exp2(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::exp(arg*0.69314718055994530941723212145818)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log(float arg) { return expr(std::log(arg)); }\n\n\t\t\t/// Common logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log10(float arg) { return expr(std::log10(arg)); }\n\n\t\t\t/// Logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log1p(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::log1p(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::log(1.0+arg)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Binary logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log2(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::log2(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::log(static_cast<double>(arg))*1.4426950408889634073599246810019));\n\t\t\t#endif\n\t\t\t}\n\n                        static expr logb(float arg)\n                        {\n                        #if HALF_ENABLE_CPP11_CMATH\n                                return expr(std::logb(arg));\n                        #else\n                                return expr(static_cast<float>(std::log(static_cast<double>(fabs(arg)))*1.4426950408889634073599246810019));\n                        #endif\n                        }\n\n\t\t\t/// Square root implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sqrt(float arg) { return expr(std::sqrt(arg)); }\n\n\t\t\t/// Cubic root implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cbrt(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::cbrt(arg));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(arg) || builtin_isinf(arg))\n\t\t\t\t\treturn expr(arg);\n\t\t\t\treturn expr(builtin_signbit(arg) ? -static_cast<float>(std::pow(std::fabs(static_cast<double>(arg)), 1.0/3.0)) : \n\t\t\t\t\tstatic_cast<float>(std::pow(static_cast<double>(arg), 1.0/3.0)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hypotenuse implementation.\n\t\t\t/// \\param x first argument\n\t\t\t/// \\param y second argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr hypot(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::hypot(x, y));\n\t\t\t#else\n\t\t\t\treturn expr((builtin_isinf(x) || builtin_isinf(y)) ? std::numeric_limits<float>::infinity() : \n\t\t\t\t\tstatic_cast<float>(std::sqrt(static_cast<double>(x)*x+static_cast<double>(y)*y)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Power implementation.\n\t\t\t/// \\param base value to exponentiate\n\t\t\t/// \\param exp power to expontiate to\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr pow(float base, float exp) { return expr(std::pow(base, exp)); }\n                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }\n                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }\n\t\t\tstatic expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }\n\n\t\t\t/// Sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sin(float arg) { return expr(std::sin(arg)); }\n\n\t\t\t/// Cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cos(float arg) { return expr(std::cos(arg)); }\n\n\t\t\t/// Tan implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tan(float arg) { return expr(std::tan(arg)); }\n\n\t\t\t/// Arc sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr asin(float arg) { return expr(std::asin(arg)); }\n\n\t\t\t/// Arc cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr acos(float arg) { return expr(std::acos(arg)); }\n\n\t\t\t/// Arc tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atan(float arg) { return expr(std::atan(arg)); }\n\n\t\t\t/// Arc tangent implementation.\n\t\t\t/// \\param x first argument\n\t\t\t/// \\param y second argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atan2(float x, float y) { return expr(std::atan2(x, y)); }\n\n\t\t\t/// Hyperbolic sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sinh(float arg) { return expr(std::sinh(arg)); }\n\n\t\t\t/// Hyperbolic cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cosh(float arg) { return expr(std::cosh(arg)); }\n\n\t\t\t/// Hyperbolic tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tanh(float arg) { return expr(std::tanh(arg)); }\n\n\t\t\t/// Hyperbolic area sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr asinh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::asinh(arg));\n\t\t\t#else\n\t\t\t\treturn expr((arg==-std::numeric_limits<float>::infinity()) ? arg : static_cast<float>(std::log(arg+std::sqrt(arg*arg+1.0))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hyperbolic area cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr acosh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::acosh(arg));\n\t\t\t#else\n\t\t\t\treturn expr((arg<-1.0f) ? std::numeric_limits<float>::quiet_NaN() : static_cast<float>(std::log(arg+std::sqrt(arg*arg-1.0))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hyperbolic area tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atanh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::atanh(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(0.5*std::log((1.0+arg)/(1.0-arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Error function implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr erf(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::erf(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(erf(static_cast<double>(arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Complementary implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr erfc(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::erfc(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(1.0-erf(static_cast<double>(arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Gamma logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr lgamma(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::lgamma(arg));\n\t\t\t#else\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::infinity());\n\t\t\t\tdouble z = static_cast<double>(arg);\n\t\t\t\tif(z < 0)\n\t\t\t\t{\n\t\t\t\t\tdouble i, f = std::modf(-z, &i);\n\t\t\t\t\tif(f == 0.0)\n\t\t\t\t\t\treturn expr(std::numeric_limits<float>::infinity());\n\t\t\t\t\treturn expr(static_cast<float>(1.1447298858494001741434273513531-std::log(std::abs(std::sin(3.1415926535897932384626433832795*f)))-lgamma(1.0-z)));\n\t\t\t\t}\n//\t\t\t\tif(z < 8.0)\n\t\t\t\t\treturn expr(static_cast<float>(lgamma(static_cast<double>(arg))));\n\t\t\t\treturn expr(static_cast<float>(0.5*(1.8378770664093454835606594728112-std::log(z))+z*(std::log(z+1.0/(12.0*z-1.0/(10.0*z)-1.0))-1.0)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Gamma implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tgamma(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::tgamma(arg));\n\t\t\t#else\n\t\t\t\tdouble z = static_cast<double>(arg);\n\t\t\t\tif(z == 0.0)\n\t\t\t\t\treturn builtin_signbit(z) ? expr(-std::numeric_limits<float>::infinity()) : expr(std::numeric_limits<float>::infinity());\n\t\t\t\tif(z < 0.0)\n\t\t\t\t{\n\t\t\t\t\tdouble i, f = std::modf(-z, &i);\n\t\t\t\t\tif(f == 0.0)\n\t\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\t\tdouble sign = (std::fmod(i, 2.0)==0.0) ? -1.0 : 1.0;\n\t\t\t\t\treturn expr(static_cast<float>(sign*3.1415926535897932384626433832795/(std::sin(3.1415926535897932384626433832795*f)*std::exp(lgamma(1.0-z)))));\n\t\t\t\t}\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn expr(arg);\n//\t\t\t\tif(arg < 8.0f)\n\t\t\t\t\treturn expr(static_cast<float>(std::exp(lgamma(z))));\n\t\t\t\treturn expr(static_cast<float>(std::sqrt(6.283185307179586476925286766559/z)*std::pow(0.36787944117144232159552377016146*(z+1.0/(12.0*z-1.0/(10.0*z))), z)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Floor implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }\n\n\t\t\t/// Ceiling implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }\n\n\t\t\t/// Truncation implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half round(half arg) { return half(binary, round_half_up(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long lround(half arg) { return detail::half2int_up<long>(arg.data_); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }\n\n\t\t#if HALF_ENABLE_CPP11_LONG_LONG\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }\n\t\t#endif\n\n\t\t\t/// Decompression implementation.\n\t\t\t/// \\param arg number to decompress\n\t\t\t/// \\param exp address to store exponent at\n\t\t\t/// \\return normalized significant\n\t\t\tstatic half frexp(half arg, int *exp)\n\t\t\t{\n\t\t\t\tunsigned int m = arg.data_ & 0x7FFF;\n\t\t\t\tif(m >= 0x7C00 || !m)\n\t\t\t\t\treturn *exp = 0, arg;\n\t\t\t\tint e = m >> 10;\n\t\t\t\tif(!e)\n\t\t\t\t\tfor(m<<=1; m<0x400; m<<=1,--e) ;\n\t\t\t\treturn *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));\n\t\t\t}\n\n\t\t\t/// Decompression implementation.\n\t\t\t/// \\param arg number to decompress\n\t\t\t/// \\param iptr address to store integer part at\n\t\t\t/// \\return fractional part\n\t\t\tstatic half modf(half arg, half *iptr)\n\t\t\t{\n\t\t\t\tunsigned int e = arg.data_ & 0x7C00;\n\t\t\t\tif(e > 0x6000)\n\t\t\t\t\treturn *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);\n\t\t\t\tif(e < 0x3C00)\n\t\t\t\t\treturn iptr->data_ = arg.data_ & 0x8000, arg;\n\t\t\t\te >>= 10;\n\t\t\t\tunsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;\n\t\t\t\tiptr->data_ = arg.data_ & ~mask;\n\t\t\t\tif(!m)\n\t\t\t\t\treturn half(binary, arg.data_&0x8000);\n\t\t\t\tfor(; m<0x400; m<<=1,--e) ;\n\t\t\t\treturn half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));\n\t\t\t}\n\n\t\t\t/// Scaling implementation.\n\t\t\t/// \\param arg number to scale\n\t\t\t/// \\param exp power of two to scale by\n\t\t\t/// \\return scaled number\n\t\t\tstatic half scalbln(half arg, long exp)\n\t\t\t{\n\t\t\t\tlong e = arg.data_ & 0x7C00;\n\t\t\t\tif(e == 0x7C00)\n\t\t\t\t\treturn arg;\n\t\t\t\tunsigned int m = arg.data_ & 0x3FF;\n\t\t\t\tif(e >>= 10)\n\t\t\t\t\tm |= 0x400;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(!m)\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\tfor(m<<=1; m<0x400; m<<=1,--e) ;\n\t\t\t\t}\n\t\t\t\te += exp;\n\t\t\t\tuint16 value = arg.data_ & 0x8000;\n\t\t\t\tif(e > 30)\n\t\t\t\t{\n\t\t\t\t\tif(half::round_style == std::round_toward_zero)\n\t\t\t\t\t\tvalue |= 0x7BFF;\n\t\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\t\tvalue |= 0x7C00 - (value>>15);\n\t\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\t\tvalue |= 0x7BFF + (value>>15);\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue |= 0x7C00;\n\t\t\t\t}\n\t\t\t\telse if(e > 0)\n\t\t\t\t\tvalue |= (e<<10) | (m&0x3FF);\n\t\t\t\telse if(e > -11)\n\t\t\t\t{\n\t\t\t\t\tif(half::round_style == std::round_to_nearest)\n\t\t\t\t\t{\n\t\t\t\t\t\tm += 1 << -e;\n\t\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t\tm -= (m>>(1-e)) & 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\t\tm += ((value>>15)-1) & ((1<<(1-e))-1U);\n\t\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\t\tm += -(value>>15) & ((1<<(1-e))-1U);\n\t\t\t\t\tvalue |= m >> (1-e);\n\t\t\t\t}\n\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\tvalue |= ((value>>15)-1) & 1;\n\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\tvalue |= value >> 15;\n\t\t\t\treturn half(binary, value);\n\t\t\t}\n\n\t\t\t/// Exponent implementation.\n\t\t\t/// \\param arg number to query\n\t\t\t/// \\return floating point exponent\n\t\t\tstatic int ilogb(half arg)\n\t\t\t{\n\t\t\t\tint exp = arg.data_ & 0x7FFF;\n\t\t\t\tif(!exp)\n\t\t\t\t\treturn FP_ILOGB0;\n\t\t\t\tif(exp < 0x7C00)\n\t\t\t\t{\n\t\t\t\t\tif(!(exp>>=10))\n\t\t\t\t\t\tfor(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;\n\t\t\t\t\treturn exp - 15;\n\t\t\t\t}\n\t\t\t\tif(exp > 0x7C00)\n\t\t\t\t\treturn FP_ILOGBNAN;\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\n\t\t\t/// \\param from number to increase/decrease\n\t\t\t/// \\param to direction to enumerate into\n\t\t\t/// \\return next representable number\n\t\t\tstatic half nextafter(half from, half to)\n\t\t\t{\n\t\t\t\tuint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;\n\t\t\t\tif(fabs > 0x7C00)\n\t\t\t\t\treturn from;\n\t\t\t\tif(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))\n\t\t\t\t\treturn to;\n\t\t\t\tif(!fabs)\n\t\t\t\t\treturn half(binary, (to.data_&0x8000)+1);\n\t\t\t\tbool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) < \n\t\t\t\t\t(signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));\n\t\t\t\treturn half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);\n\t\t\t}\n\n\t\t\t/// Enumeration implementation.\n\t\t\t/// \\param from number to increase/decrease\n\t\t\t/// \\param to direction to enumerate into\n\t\t\t/// \\return next representable number\n\t\t\tstatic half nexttoward(half from, long double to)\n\t\t\t{\n\t\t\t\tif(isnan(from))\n\t\t\t\t\treturn from;\n\t\t\t\tlong double lfrom = static_cast<long double>(from);\n\t\t\t\tif(builtin_isnan(to) || lfrom == to)\n\t\t\t\t\treturn half(static_cast<float>(to));\n\t\t\t\tif(!(from.data_&0x7FFF))\n\t\t\t\t\treturn half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);\n\t\t\t\treturn half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);\n\t\t\t}\n\n\t\t\t/// Sign implementation\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return composed value\n\t\t\tstatic half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if infinite number\n\t\t\t/// \\retval false else\n\t\t\tstatic int fpclassify(half arg)\n\t\t\t{\n\t\t\t\tunsigned int abs = arg.data_ & 0x7FFF;\n\t\t\t\tif(abs > 0x7C00)\n\t\t\t\t\treturn FP_NAN;\n\t\t\t\tif(abs == 0x7C00)\n\t\t\t\t\treturn FP_INFINITE;\n\t\t\t\tif(abs > 0x3FF)\n\t\t\t\t\treturn FP_NORMAL;\n\t\t\t\treturn abs ? FP_SUBNORMAL : FP_ZERO;\n\t\t\t}\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if finite number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if infinite number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if not a number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if normal number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }\n\n\t\t\t/// Sign bit implementation.\n\t\t\t/// \\param arg value to check\n\t\t\t/// \\retval true if signed\n\t\t\t/// \\retval false if unsigned\n\t\t\tstatic bool signbit(half arg) { return (arg.data_&0x8000) != 0; }\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operands equal\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isequal(half x, half y) { return (x.data_==y.data_ || !((x.data_|y.data_)&0x7FFF)) && !isnan(x); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }\n\t\t\tstatic bool isequal(float x, half y) { return HLS_FPO_EQUALF(x,y); }\n\t\t\tstatic bool isequal(half x, float y) { return HLS_FPO_EQUALF(x,y); }\n\t\t\tstatic bool isequal(double x, half y) { return HLS_FPO_EQUAL(x,y); }\n\t\t\tstatic bool isequal(half x, double y) { return HLS_FPO_EQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operands not equal\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isnotequal(half x, half y) { return (x.data_!=y.data_ && ((x.data_|y.data_)&0x7FFF)) || isnan(x); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }\n\t\t\tstatic bool isnotequal(float x, half y) { return HLS_FPO_NOTEQUALF(x,y); }\n\t\t\tstatic bool isnotequal(half x, float y) { return HLS_FPO_NOTEQUALF(x,y); }\n\t\t\tstatic bool isnotequal(double x, half y) { return HLS_FPO_NOTEQUAL(x,y); }\n\t\t\tstatic bool isnotequal(half x, double y) { return HLS_FPO_NOTEQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x > \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isgreater(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) > (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }\n\t\t\tstatic bool isgreater(float x, half y) { return HLS_FPO_GREATERF(x,y); }\n\t\t\tstatic bool isgreater(half x, float y) { return HLS_FPO_GREATERF(x,y); }\n\t\t\tstatic bool isgreater(double x, half y) { return HLS_FPO_GREATER(x,y); }\n\t\t\tstatic bool isgreater(half x, double y) { return HLS_FPO_GREATER(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x >= \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isgreaterequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) >= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }\n\t\t\tstatic bool isgreaterequal(float x, half y) { return HLS_FPO_GREATEREQUALF(x,y); }\n\t\t\tstatic bool isgreaterequal(half x, float y) { return HLS_FPO_GREATEREQUALF(x,y); }\n\t\t\tstatic bool isgreaterequal(double x, half y) { return HLS_FPO_GREATEREQUAL(x,y); }\n\t\t\tstatic bool isgreaterequal(half x, double y) { return HLS_FPO_GREATEREQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x < \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isless(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) < (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }\n\t\t\tstatic bool isless(float x, half y) { return HLS_FPO_LESSF(x,y); }\n\t\t\tstatic bool isless(half x, float y) { return HLS_FPO_LESSF(x,y); }\n\t\t\tstatic bool isless(double x, half y) { return HLS_FPO_LESS(x,y); }\n\t\t\tstatic bool isless(half x, double y) { return HLS_FPO_LESS(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x <= \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool islessequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) <= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }\n\t\t\tstatic bool islessequal(float x, half y) { return HLS_FPO_LESSEQUALF(x,y); }\n\t\t\tstatic bool islessequal(half x, float y) { return HLS_FPO_LESSEQUALF(x,y); }\n\t\t\tstatic bool islessequal(double x, half y) { return HLS_FPO_LESSEQUAL(x,y); }\n\t\t\tstatic bool islessequal(half x, double y) { return HLS_FPO_LESSEQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true neither \\a x > \\a y nor \\a x < \\a y\n\t\t\t/// \\retval false else\n\t\t\tstatic bool islessgreater(half x, half y)\n\t\t\t{\n\t\t\t\tif(isnan(x) || isnan(y))\n\t\t\t\t\treturn false;\n\t\t\t\t//int17 a = signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_);\n\t\t\t\t//int17 b = signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_);\n\t\t\t\t//return a < b || a > b;\n                return isless(x, y) || isgreater(x, y);\n\t\t\t}\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operand unordered\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isunordered(half x, half y) { return isnan(x) || isnan(y); }\n\n\t\tprivate:\n\t\t\tstatic double erf(double arg)\n\t\t\t{\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn (arg<0.0) ? -1.0 : 1.0;\n\t\t\t\tdouble x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;\n\t\t\t\tdouble value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));\n\t\t\t\treturn builtin_signbit(arg) ? -value : value;\n\t\t\t}\n\n\t\t\tstatic double lgamma(double arg)\n\t\t\t{\n\t\t\t\tdouble v = 1.0;\n\t\t\t\tfor(; arg<8.0; ++arg) v *= arg;\n\t\t\t\tdouble w = 1.0 / (arg * arg);\n\t\t\t\treturn (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+\n\t\t\t\t\t-0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+\n\t\t\t\t\t-5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+\n\t\t\t\t\t-0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg + \n\t\t\t\t\t0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);\n\t\t\t}\n\t\t};\n\n\t\t/// Wrapper for unary half-precision functions needing specialization for individual argument types.\n\t\t/// \\tparam T argument type\n\t\ttemplate<typename T> struct unary_specialized\n\t\t{\n\t\t\t/// Negation implementation.\n\t\t\t/// \\param arg value to negate\n\t\t\t/// \\return negated value\n\t\t\tstatic HALF_CONSTEXPR half negate(half arg) { return half(binary, arg.data_^0x8000); }\n\n\t\t\t/// Absolute value implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return absolute value\n\t\t\tstatic half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }\n\t\t};\n\t\ttemplate<> struct unary_specialized<expr>\n\t\t{\n\t\t\tstatic HALF_CONSTEXPR expr negate(float arg) { return expr(-arg); }\n\t\t\tstatic expr fabs(float arg) { return expr(std::fabs(arg)); }\n\t\t};\n\n\t\t/// Wrapper for binary half-precision functions needing specialization for individual argument types.\n\t\t/// \\tparam T first argument type\n\t\t/// \\tparam U first argument type\n\t\ttemplate<typename T,typename U> struct binary_specialized\n\t\t{\n\t\t\t/// Minimum implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return minimum value\n\t\t\tstatic expr fmin(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fmin(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x))\n\t\t\t\t\treturn expr(y);\n\t\t\t\tif(builtin_isnan(y))\n\t\t\t\t\treturn expr(x);\n\t\t\t\treturn expr(std::min(x, y));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Maximum implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return maximum value\n\t\t\tstatic expr fmax(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fmax(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x))\n\t\t\t\t\treturn expr(y);\n\t\t\t\tif(builtin_isnan(y))\n\t\t\t\t\treturn expr(x);\n\t\t\t\treturn expr(std::max(x, y));\n\t\t\t#endif\n\t\t\t}\n\t\t};\n\t\ttemplate<> struct binary_specialized<half,half>\n\t\t{\n\t\t\tstatic half fmin(half x, half y)\n\t\t\t{\n\t\t\t\tif(functions::isnan(x))\n\t\t\t\t\treturn y;\n\t\t\t\tif(functions::isnan(y))\n\t\t\t\t\treturn x;\n\t\t\t\treturn ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >\n\t\t\t\t\t\t(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n\t\t\t}\n\t\t\tstatic half fmax(half x, half y)\n\t\t\t{\n\t\t\t\tif(functions::isnan(x))\n\t\t\t\t\treturn y;\n\t\t\t\tif(functions::isnan(y))\n\t\t\t\t\treturn x;\n\t\t\t\treturn ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <\n\t\t\t\t\t\t(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n\t\t\t}\n\t\t};\n\n\t\t/// Helper class for half casts.\n\t\t/// This class template has to be specialized for all valid cast argument to define an appropriate static `cast` member \n\t\t/// function and a corresponding `type` member denoting its return type.\n\t\t/// \\tparam T destination type\n\t\t/// \\tparam U source type\n\t\t/// \\tparam R rounding mode to use\n\t\ttemplate<typename T,typename U,std::float_round_style R=(std::float_round_style)(HALF_ROUND_STYLE)> struct half_caster {};\n\t\ttemplate<typename U,std::float_round_style R> struct half_caster<half,U,R>\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\tstatic_assert(std::is_arithmetic<U>::value, \"half_cast from non-arithmetic type unsupported\");\n\t\t#endif\n\n\t\t\ttypedef half type;\n\t\t\tstatic half cast(U arg) { return cast_impl(arg, is_float<U>()); };\n\n\t\tprivate:\n\t\t\tstatic half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }\n\t\t\tstatic half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }\n\t\t};\n\t\ttemplate<typename T,std::float_round_style R> struct half_caster<T,half,R>\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\tstatic_assert(std::is_arithmetic<T>::value, \"half_cast to non-arithmetic type unsupported\");\n\t\t#endif\n\n\t\t\ttypedef T type;\n\t\t\ttemplate<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }\n\n\t\tprivate:\n\t\t\tstatic T cast_impl(float arg, true_type) { return static_cast<T>(arg); }\n\t\t\tstatic T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }\n\t\t};\n\t\ttemplate<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};\n\t\ttemplate<std::float_round_style R> struct half_caster<half,half,R>\n\t\t{\n\t\t\ttypedef half type;\n\t\t\tstatic half cast(half arg) { return arg; }\n\t\t};\n\t\ttemplate<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};\n\n\t\t/// \\name Comparison operators\n\t\t/// \\{\n\n        /// the behavior of comparison operators' simulation model is same with STD/following implmentation\n        /// so no need to call FPO model\n\n\t\t/// Comparison for equality.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if operands equal\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }\n\n\t\t/// Comparison for inequality.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if operands not equal\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }\n\n\t\t/// Comparison for less than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less than \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }\n\n\t\t/// Comparison for greater than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater than \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }\n\n\t\t/// Comparison for less equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less equal \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }\n\n\t\t/// Comparison for greater equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater equal \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Arithmetic operators\n\t\t/// \\{\n\n\t\t/// Add halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return sum of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }\n#endif\n\n\t\t/// Subtract halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return difference of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }\n#endif\n\n\t\t/// Multiply halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return product of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }\n#endif\n\n\t\t/// Divide halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return quotient of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }\n#endif\n\n\t\t/// Identity.\n\t\t/// \\param arg operand\n\t\t/// \\return uncahnged operand\n\t\ttemplate<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator+(T arg) { return arg; }\n\n\t\t/// Negation.\n\t\t/// \\param arg operand\n\t\t/// \\return negated operand\n\t\ttemplate<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Input and output\n\t\t/// \\{\n\n\t\t/// Output operator.\n\t\t/// \\param out output stream to write into\n\t\t/// \\param arg half expression to write\n\t\t/// \\return reference to output stream\n\t\ttemplate<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type\n\t\t\toperator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }\n\n\t\t/// Input operator.\n\t\t/// \\param in input stream to read from\n\t\t/// \\param arg half to read into\n\t\t/// \\return reference to input stream\n\t\ttemplate<typename charT,typename traits> std::basic_istream<charT,traits>&\n\t\t\toperator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }\n\n\t\t/// \\}\n\t\t/// \\name Basic mathematical operations\n\t\t/// \\{\n\n\t\t/// Absolute value.\n\t\t/// \\param arg operand\n\t\t/// \\return absolute value of \\a arg\n//\t\ttemplate<typename T> typename enable<T,T>::type abs(T arg) { return unary_specialized<T>::fabs(arg); }\n\t\tinline half abs(half arg) { return unary_specialized<half>::fabs(arg); }\n\t\tinline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n\t\t/// Absolute value.\n\t\t/// \\param arg operand\n\t\t/// \\return absolute value of \\a arg\n//\t\ttemplate<typename T> typename enable<T,T>::type fabs(T arg) { return unary_specialized<T>::fabs(arg); }\n\t\tinline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }\n\t\tinline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type fmod(T x, U y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(half x, half y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(half x, expr y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(expr x, half y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(expr x, expr y) { return functions::fmod(x, y); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type remainder(T x, U y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(half x, half y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(half x, expr y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(expr x, half y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(expr x, expr y) { return functions::remainder(x, y); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\param quo address to store some bits of quotient at\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type remquo(T x, U y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n\n\t\t/// Fused multiply add.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\param z third operand\n\t\t/// \\return ( \\a x * \\a y ) + \\a z rounded as one operation.\n//\t\ttemplate<typename T,typename U,typename V> typename enable<expr,T,U,V>::type fma(T x, U y, V z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }\n\n                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }\n\n\t\t/// Maximum of half expressions.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return maximum of operands\n//\t\ttemplate<typename T,typename U> typename result<T,U>::type fmax(T x, U y) { return binary_specialized<T,U>::fmax(x, y); }\n\t\tinline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }\n\t\tinline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }\n\t\tinline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }\n\t\tinline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }\n\n\t\t/// Minimum of half expressions.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return minimum of operands\n//\t\ttemplate<typename T,typename U> typename result<T,U>::type fmin(T x, U y) { return binary_specialized<T,U>::fmin(x, y); }\n\t\tinline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }\n\t\tinline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }\n\t\tinline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }\n\t\tinline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }\n\n\t\t/// Positive difference.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return \\a x - \\a y or 0 if difference negative\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type fdim(T x, U y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(half x, half y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(half x, expr y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(expr x, half y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(expr x, expr y) { return functions::fdim(x, y); }\n\n                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }\n                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }\n                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }\n                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }\n\n                inline expr minmag(half x, half y) { return functions::minmag(x, y); }\n                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }\n                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }\n                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }\n\n\t\t/// Get NaN value.\n\t\t/// \\param arg descriptive string (ignored)\n\t\t/// \\return quiet NaN\n\t\tinline half nanh(const char *arg) { return functions::nanh(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Exponential functions\n\t\t/// \\{\n\n\t\t/// Exponential function.\n\t\t/// \\param arg function argument\n\t\t/// \\return e raised to \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type exp(T arg) { return functions::exp(arg); }\n\t\tinline expr exp(half arg) { return functions::exp(arg); }\n\t\tinline expr exp(expr arg) { return functions::exp(arg); }\n\n\t\t/// Exponential minus one.\n\t\t/// \\param arg function argument\n\t\t/// \\return e raised to \\a arg subtracted by 1\n//\t\ttemplate<typename T> typename enable<expr,T>::type expm1(T arg) { return functions::expm1(arg); }\n\t\tinline expr expm1(half arg) { return functions::expm1(arg); }\n\t\tinline expr expm1(expr arg) { return functions::expm1(arg); }\n\n\t\t/// Binary exponential.\n\t\t/// \\param arg function argument\n\t\t/// \\return 2 raised to \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type exp2(T arg) { return functions::exp2(arg); }\n\t\tinline expr exp2(half arg) { return functions::exp2(arg); }\n\t\tinline expr exp2(expr arg) { return functions::exp2(arg); }\n\n\t\t/// Natural logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base e\n//\t\ttemplate<typename T> typename enable<expr,T>::type log(T arg) { return functions::log(arg); }\n\t\tinline expr log(half arg) { return functions::log(arg); }\n\t\tinline expr log(expr arg) { return functions::log(arg); }\n\n\t\t/// Common logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base 10\n//\t\ttemplate<typename T> typename enable<expr,T>::type log10(T arg) { return functions::log10(arg); }\n\t\tinline expr log10(half arg) { return functions::log10(arg); }\n\t\tinline expr log10(expr arg) { return functions::log10(arg); }\n\n\t\t/// Natural logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg plus 1 to base e\n//\t\ttemplate<typename T> typename enable<expr,T>::type log1p(T arg) { return functions::log1p(arg); }\n\t\tinline expr log1p(half arg) { return functions::log1p(arg); }\n\t\tinline expr log1p(expr arg) { return functions::log1p(arg); }\n\n\t\t/// Binary logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base 2\n//\t\ttemplate<typename T> typename enable<expr,T>::type log2(T arg) { return functions::log2(arg); }\n\t\tinline expr log2(half arg) { return functions::log2(arg); }\n\t\tinline expr log2(expr arg) { return functions::log2(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Power functions\n\t\t/// \\{\n\n\t\t/// Square root.\n\t\t/// \\param arg function argument\n\t\t/// \\return square root of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sqrt(T arg) { return functions::sqrt(arg); }\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\tinline expr sqrt(half arg) { return functions::sqrt(arg); }\n#else\n\t\tinline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }\n#endif\n\t\tinline expr sqrt(expr arg) { return functions::sqrt(arg); }\n\n\t\t/// Cubic root.\n\t\t/// \\param arg function argument\n\t\t/// \\return cubic root of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cbrt(T arg) { return functions::cbrt(arg); }\n\t\tinline expr cbrt(half arg) { return functions::cbrt(arg); }\n\t\tinline expr cbrt(expr arg) { return functions::cbrt(arg); }\n\n\t\t/// Hypotenuse function.\n\t\t/// \\param x first argument\n\t\t/// \\param y second argument\n\t\t/// \\return square root of sum of squares without internal over- or underflows\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type hypot(T x, U y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(half x, half y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(half x, expr y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(expr x, half y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(expr x, expr y) { return functions::hypot(x, y); }\n\n\t\t/// Power function.\n\t\t/// \\param base first argument\n\t\t/// \\param exp second argument\n\t\t/// \\return \\a base raised to \\a exp\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type pow(T base, U exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(half base, half exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(half base, expr exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(expr base, half exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(expr base, expr exp) { return functions::pow(base, exp); }\n                inline expr powr(half base, half exp) { return functions::powr(base, exp); }\n                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }\n                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }\n                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }\n                inline expr pown(half base, int exp) { return functions::pown(base, exp); }\n                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }\n\n\t\t/// \\}\n\t\t/// \\name Trigonometric functions\n\t\t/// \\{\n\n\t\t/// Sine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sin(T arg) { return functions::sin(arg); }\n\t\tinline expr sin(half arg) { return functions::sin(arg); }\n\t\tinline expr sin(expr arg) { return functions::sin(arg); }\n\n\t\t/// Cosine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cos(T arg) { return functions::cos(arg); }\n\t\tinline expr cos(half arg) { return functions::cos(arg); }\n\t\tinline expr cos(expr arg) { return functions::cos(arg); }\n\n\t\t/// Tangent function.\n\t\t/// \\param arg function argument\n\t\t/// \\return tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tan(T arg) { return functions::tan(arg); }\n\t\tinline expr tan(half arg) { return functions::tan(arg); }\n\t\tinline expr tan(expr arg) { return functions::tan(arg); }\n\n\t\t/// Arc sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type asin(T arg) { return functions::asin(arg); }\n\t\tinline expr asin(half arg) { return functions::asin(arg); }\n\t\tinline expr asin(expr arg) { return functions::asin(arg); }\n\n\t\t/// Arc cosine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type acos(T arg) { return functions::acos(arg); }\n\t\tinline expr acos(half arg) { return functions::acos(arg); }\n\t\tinline expr acos(expr arg) { return functions::acos(arg); }\n\n\t\t/// Arc tangent function.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type atan(T arg) { return functions::atan(arg); }\n\t\tinline expr atan(half arg) { return functions::atan(arg); }\n\t\tinline expr atan(expr arg) { return functions::atan(arg); }\n\n\t\t/// Arc tangent function.\n\t\t/// \\param x first argument\n\t\t/// \\param y second argument\n\t\t/// \\return arc tangent value\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type atan2(T x, U y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(half x, half y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(half x, expr y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(expr x, half y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(expr x, expr y) { return functions::atan2(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Hyperbolic functions\n\t\t/// \\{\n\n\t\t/// Hyperbolic sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sinh(T arg) { return functions::sinh(arg); }\n\t\tinline expr sinh(half arg) { return functions::sinh(arg); }\n\t\tinline expr sinh(expr arg) { return functions::sinh(arg); }\n\n\t\t/// Hyperbolic cosine.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cosh(T arg) { return functions::cosh(arg); }\n\t\tinline expr cosh(half arg) { return functions::cosh(arg); }\n\t\tinline expr cosh(expr arg) { return functions::cosh(arg); }\n\n\t\t/// Hyperbolic tangent.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tanh(T arg) { return functions::tanh(arg); }\n\t\tinline expr tanh(half arg) { return functions::tanh(arg); }\n\t\tinline expr tanh(expr arg) { return functions::tanh(arg); }\n\n\t\t/// Hyperbolic area sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return area sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type asinh(T arg) { return functions::asinh(arg); }\n\t\tinline expr asinh(half arg) { return functions::asinh(arg); }\n\t\tinline expr asinh(expr arg) { return functions::asinh(arg); }\n\n\t\t/// Hyperbolic area cosine.\n\t\t/// \\param arg function argument\n\t\t/// \\return area cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type acosh(T arg) { return functions::acosh(arg); }\n\t\tinline expr acosh(half arg) { return functions::acosh(arg); }\n\t\tinline expr acosh(expr arg) { return functions::acosh(arg); }\n\n\t\t/// Hyperbolic area tangent.\n\t\t/// \\param arg function argument\n\t\t/// \\return area tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type atanh(T arg) { return functions::atanh(arg); }\n\t\tinline expr atanh(half arg) { return functions::atanh(arg); }\n\t\tinline expr atanh(expr arg) { return functions::atanh(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Error and gamma functions\n\t\t/// \\{\n\n\t\t/// Error function.\n\t\t/// \\param arg function argument\n\t\t/// \\return error function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type erf(T arg) { return functions::erf(arg); }\n\t\tinline expr erf(half arg) { return functions::erf(arg); }\n\t\tinline expr erf(expr arg) { return functions::erf(arg); }\n\n\t\t/// Complementary error function.\n\t\t/// \\param arg function argument\n\t\t/// \\return 1 minus error function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type erfc(T arg) { return functions::erfc(arg); }\n\t\tinline expr erfc(half arg) { return functions::erfc(arg); }\n\t\tinline expr erfc(expr arg) { return functions::erfc(arg); }\n\n\t\t/// Natural logarithm of gamma function.\n\t\t/// \\param arg function argument\n\t\t/// \\return natural logarith of gamma function for \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type lgamma(T arg) { return functions::lgamma(arg); }\n                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }\n                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }\n\t\tinline expr lgamma(half arg) { return functions::lgamma(arg); }\n\t\tinline expr lgamma(expr arg) { return functions::lgamma(arg); }\n\n\t\t/// Gamma function.\n\t\t/// \\param arg function argument\n\t\t/// \\return gamma function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tgamma(T arg) { return functions::tgamma(arg); }\n\t\tinline expr tgamma(half arg) { return functions::tgamma(arg); }\n\t\tinline expr tgamma(expr arg) { return functions::tgamma(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Rounding\n\t\t/// \\{\n\n\t\t/// Nearest integer not less than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not less than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type ceil(T arg) { return functions::ceil(arg); }\n\t\tinline half ceil(half arg) { return functions::ceil(arg); }\n\t\tinline half ceil(expr arg) { return functions::ceil(arg); }\n\n\t\t/// Nearest integer not greater than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not greater than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type floor(T arg) { return functions::floor(arg); }\n\t\tinline half floor(half arg) { return functions::floor(arg); }\n\t\tinline half floor(expr arg) { return functions::floor(arg); }\n\n\t\t/// Nearest integer not greater in magnitude than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not greater in magnitude than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type trunc(T arg) { return functions::trunc(arg); }\n\t\tinline half trunc(half arg) { return functions::trunc(arg); }\n\t\tinline half trunc(expr arg) { return functions::trunc(arg); }\n\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<half,T>::type round(T arg) { return functions::round(arg); }\n\t\tinline half round(half arg) { return functions::round(arg); }\n\t\tinline half round(expr arg) { return functions::round(arg); }\n\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<long,T>::type lround(T arg) { return functions::lround(arg); }\n\t\tinline long lround(half arg) { return functions::lround(arg); }\n\t\tinline long lround(expr arg) { return functions::lround(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<half,T>::type nearbyint(T arg) { return functions::nearbyint(arg); }\n\t\tinline half nearbyint(half arg) { return functions::rint(arg); }\n\t\tinline half nearbyint(expr arg) { return functions::rint(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<half,T>::type rint(T arg) { return functions::rint(arg); }\n\t\tinline half rint(half arg) { return functions::rint(arg); }\n\t\tinline half rint(expr arg) { return functions::rint(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<long,T>::type lrint(T arg) { return functions::lrint(arg); }\n\t\tinline long lrint(half arg) { return functions::lrint(arg); }\n\t\tinline long lrint(expr arg) { return functions::lrint(arg); }\n\t#if HALF_ENABLE_CPP11_LONG_LONG\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<long long,T>::type llround(T arg) { return functions::llround(arg); }\n\t\tinline long long llround(half arg) { return functions::llround(arg); }\n\t\tinline long long llround(expr arg) { return functions::llround(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<long long,T>::type llrint(T arg) { return functions::llrint(arg); }\n\t\tinline long long llrint(half arg) { return functions::llrint(arg); }\n\t\tinline long long llrint(expr arg) { return functions::llrint(arg); }\n\t#endif\n\n\t\t/// \\}\n\t\t/// \\name Floating point manipulation\n\t\t/// \\{\n\n\t\t/// Decompress floating point number.\n\t\t/// \\param arg number to decompress\n\t\t/// \\param exp address to store exponent at\n\t\t/// \\return significant in range [0.5, 1)\n//\t\ttemplate<typename T> typename enable<half,T>::type frexp(T arg, int *exp) { return functions::frexp(arg, exp); }\n\t\tinline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }\n\t\tinline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\n//\t\ttemplate<typename T> typename enable<half,T>::type ldexp(T arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Extract integer and fractional parts.\n\t\t/// \\param arg number to decompress\n\t\t/// \\param iptr address to store integer part at\n\t\t/// \\return fractional part\n//\t\ttemplate<typename T> typename enable<half,T>::type modf(T arg, half *iptr) { return functions::modf(arg, iptr); }\n\t\tinline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }\n\t\tinline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\n//\t\ttemplate<typename T> typename enable<half,T>::type scalbn(T arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\t\n//\t\ttemplate<typename T> typename enable<half,T>::type scalbln(T arg, long exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Extract exponent.\n\t\t/// \\param arg number to query\n\t\t/// \\return floating point exponent\n\t\t/// \\retval FP_ILOGB0 for zero\n\t\t/// \\retval FP_ILOGBNAN for NaN\n\t\t/// \\retval MAX_INT for infinity\n//\t\ttemplate<typename T> typename enable<int,T>::type ilogb(T arg) { return functions::ilogb(arg); }\n\t\tinline int ilogb(half arg) { return functions::ilogb(arg); }\n\t\tinline int ilogb(expr arg) { return functions::ilogb(arg); }\n\n\t\t/// Extract exponent.\n\t\t/// \\param arg number to query\n\t\t/// \\return floating point exponent\n//\t\ttemplate<typename T> typename enable<half,T>::type logb(T arg) { return functions::logb(arg); }\n\t\tinline half logb(half arg) { return functions::logb(arg); }\n\t\tinline half logb(expr arg) { return functions::logb(arg); }\n\n\t\t/// Next representable value.\n\t\t/// \\param from value to compute next representable value for\n\t\t/// \\param to direction towards which to compute next value\n\t\t/// \\return next representable value after \\a from in direction towards \\a to\n//\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type nextafter(T from, U to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(half from, half to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(half from, expr to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(expr from, half to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }\n\n\t\t/// Next representable value.\n\t\t/// \\param from value to compute next representable value for\n\t\t/// \\param to direction towards which to compute next value\n\t\t/// \\return next representable value after \\a from in direction towards \\a to\n//\t\ttemplate<typename T> typename enable<half,T>::type nexttoward(T from, long double to) { return functions::nexttoward(from, to); }\n\t\tinline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }\n\t\tinline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }\n\n\t\t/// Take sign.\n\t\t/// \\param x value to change sign for\n\t\t/// \\param y value to take sign from\n\t\t/// \\return value equal to \\a x in magnitude and to \\a y in sign\n//\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type copysign(T x, U y) { return functions::copysign(x, y); }\n\t\tinline half copysign(half x, half y) { return functions::copysign(x, y); }\n\t\tinline half copysign(half x, expr y) { return functions::copysign(x, y); }\n\t\tinline half copysign(expr x, half y) { return functions::copysign(x, y); }\n\t\tinline half copysign(expr x, expr y) { return functions::copysign(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Floating point classification\n\t\t/// \\{\n\n\n\t\t/// Classify floating point value.\n\t\t/// \\param arg number to classify\n\t\t/// \\retval FP_ZERO for positive and negative zero\n\t\t/// \\retval FP_SUBNORMAL for subnormal numbers\n\t\t/// \\retval FP_INFINITY for positive and negative infinity\n\t\t/// \\retval FP_NAN for NaNs\n\t\t/// \\retval FP_NORMAL for all other (normal) values\n//\t\ttemplate<typename T> typename enable<int,T>::type fpclassify(T arg) { return functions::fpclassify(arg); }\n\t\tinline int fpclassify(half arg) { return functions::fpclassify(arg); }\n\t\tinline int fpclassify(expr arg) { return functions::fpclassify(arg); }\n\n\t\t/// Check if finite number.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true if neither infinity nor NaN\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isfinite(T arg) { return functions::isfinite(arg); }\n\t\tinline bool isfinite(half arg) { return functions::isfinite(arg); }\n\t\tinline bool isfinite(expr arg) { return functions::isfinite(arg); }\n\n\t\t/// Check for infinity.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for positive or negative infinity\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isinf(T arg) { return functions::isinf(arg); }\n\t\tinline bool isinf(half arg) { return functions::isinf(arg); }\n\t\tinline bool isinf(expr arg) { return functions::isinf(arg); }\n\n\t\t/// Check for NaN.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for NaNs\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isnan(T arg) { return functions::isnan(arg); }\n\t\tinline bool isnan(half arg) { return functions::isnan(arg); }\n\t\tinline bool isnan(expr arg) { return functions::isnan(arg); }\n\n\t\t/// Check if normal number.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true if normal number\n\t\t/// \\retval false if either subnormal, zero, infinity or NaN\n//\t\ttemplate<typename T> typename enable<bool,T>::type isnormal(T arg) { return functions::isnormal(arg); }\n\t\tinline bool isnormal(half arg) { return functions::isnormal(arg); }\n\t\tinline bool isnormal(expr arg) { return functions::isnormal(arg); }\n\n\t\t/// Check sign.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for negative number\n\t\t/// \\retval false for positive number\n//\t\ttemplate<typename T> typename enable<bool,T>::type signbit(T arg) { return functions::signbit(arg); }\n\t\tinline bool signbit(half arg) { return functions::signbit(arg); }\n\t\tinline bool signbit(expr arg) { return functions::signbit(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Comparison\n\t\t/// \\{\n\n\t\t/// Comparison for greater than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater than \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isgreater(T x, U y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(half x, half y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }\n\n\t\t/// Comparison for greater equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater equal \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isgreaterequal(T x, U y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }\n\n\t\t/// Comparison for less than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less than \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isless(T x, U y) { return functions::isless(x, y); }\n\t\tinline bool isless(half x, half y) { return functions::isless(x, y); }\n\t\tinline bool isless(half x, expr y) { return functions::isless(x, y); }\n\t\tinline bool isless(expr x, half y) { return functions::isless(x, y); }\n\t\tinline bool isless(expr x, expr y) { return functions::isless(x, y); }\n\n\t\t/// Comparison for less equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less equal \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type islessequal(T x, U y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(half x, half y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }\n\n\t\t/// Comarison for less or greater.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if either less or greater\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type islessgreater(T x, U y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }\n\n\t\t/// Check if unordered.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if unordered (one or two NaN operands)\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isunordered(T x, U y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(half x, half y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }\n\n\t\t/// \\name Casting\n\t\t/// \\{\n\n\t\t/// Cast to or from half-precision floating point number.\n\t\t/// This casts between [half](\\ref half) and any built-in arithmetic type. Floating point types are \n\t\t/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n\t\t/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n\t\t/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n\t\t/// that a `static_cast` would otherwise do. It uses the default rounding mode.\n\t\t///\n\t\t/// Using this cast with neither of the two types being a [half](\\ref half) or with any of the two types \n\t\t/// not being a built-in arithmetic type (apart from [half](\\ref half), of course) results in a compiler \n\t\t/// error and casting between [half](\\ref half)s is just a no-op.\n\t\t/// \\tparam T destination type (half or built-in arithmetic type)\n\t\t/// \\tparam U source type (half or built-in arithmetic type)\n\t\t/// \\param arg value to cast\n\t\t/// \\return \\a arg converted to destination type\n\t\ttemplate<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }\n\n\t\t/// Cast to or from half-precision floating point number.\n\t\t/// This casts between [half](\\ref half) and any built-in arithmetic type. Floating point types are \n\t\t/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n\t\t/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n\t\t/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n\t\t/// that a `static_cast` would otherwise do.\n\t\t///\n\t\t/// Using this cast with neither of the two types being a [half](\\ref half) or with any of the two types \n\t\t/// not being a built-in arithmetic type (apart from [half](\\ref half), of course) results in a compiler \n\t\t/// error and casting between [half](\\ref half)s is just a no-op.\n\t\t/// \\tparam T destination type (half or built-in arithmetic type)\n\t\t/// \\tparam R rounding mode to use.\n\t\t/// \\tparam U source type (half or built-in arithmetic type)\n\t\t/// \\param arg value to cast\n\t\t/// \\return \\a arg converted to destination type\n\t\ttemplate<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)\n\t\t\t{ return half_caster<T,U,R>::cast(arg); }\n\t\t/// \\}\n\t}\n\n\tusing detail::operator==;\n\tusing detail::operator!=;\n\tusing detail::operator<;\n\tusing detail::operator>;\n\tusing detail::operator<=;\n\tusing detail::operator>=;\n\tusing detail::operator+;\n\tusing detail::operator-;\n\tusing detail::operator*;\n\tusing detail::operator/;\n\tusing detail::operator<<;\n\tusing detail::operator>>;\n\n// \tusing detail::abs;\n// \tusing detail::fabs;\n// \tusing detail::fmod;\n// \tusing detail::remainder;\n// \tusing detail::remquo;\n// \tusing detail::fma;\n// \tusing detail::fmax;\n// \tusing detail::fmin;\n// \tusing detail::fdim;\n// \tusing detail::nanh;\n// \tusing detail::exp;\n// \tusing detail::expm1;\n// \tusing detail::exp2;\n// \tusing detail::log;\n// \tusing detail::log10;\n// \tusing detail::log1p;\n// \tusing detail::log2;\n// \tusing detail::sqrt;\n// \tusing detail::cbrt;\n// \tusing detail::hypot;\n// \t//using detail::pow;\n// \tusing detail::sin;\n// \tusing detail::cos;\n// \tusing detail::tan;\n// \tusing detail::asin;\n// \tusing detail::acos;\n// \tusing detail::atan;\n// \tusing detail::atan2;\n// \tusing detail::sinh;\n// \tusing detail::cosh;\n// \tusing detail::tanh;\n// \tusing detail::asinh;\n// \tusing detail::acosh;\n// \tusing detail::atanh;\n// \tusing detail::erf;\n// \tusing detail::erfc;\n// \tusing detail::lgamma;\n// \tusing detail::tgamma;\n// \tusing detail::ceil;\n// \tusing detail::floor;\n// \tusing detail::trunc;\n// \tusing detail::round;\n// \tusing detail::lround;\n// \tusing detail::nearbyint;\n// \tusing detail::rint;\n// \tusing detail::lrint;\n// #if HALF_ENABLE_CPP11_LONG_LONG\n// \tusing detail::llround;\n// \tusing detail::llrint;\n// #endif\n// \tusing detail::frexp;\n// \tusing detail::ldexp;\n// \tusing detail::modf;\n// \tusing detail::scalbn;\n// \tusing detail::scalbln;\n// \tusing detail::ilogb;\n// \tusing detail::logb;\n// \tusing detail::nextafter;\n// \tusing detail::nexttoward;\n// \tusing detail::copysign;\n \tusing detail::fpclassify;\n \tusing detail::isfinite;\n \tusing detail::isinf;\n \tusing detail::isnan;\n \tusing detail::isnormal;\n \tusing detail::signbit;\n \tusing detail::isgreater;\n \tusing detail::isgreaterequal;\n \tusing detail::isless;\n \tusing detail::islessequal;\n \tusing detail::islessgreater;\n \tusing detail::isunordered;\n\n\tusing detail::half_cast;\n\n/// Extensions to the C++ standard library.\nnamespace std\n{\n\t/// Numeric limits for half-precision floats.\n\t/// Because of the underlying single-precision implementation of many operations, it inherits some properties from \n\t/// `std::numeric_limits<float>`.\n\ttemplate<> struct numeric_limits<half> : public numeric_limits<float>\n\t{\n\tpublic:\n\t\t/// Supports signed values.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_signed = true;\n\n\t\t/// Is not exact.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_exact = false;\n\n\t\t/// Doesn't provide modulo arithmetic.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_modulo = false;\n\n\t\t/// IEEE conformant.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_iec559 = true;\n\n\t\t/// Supports infinity.\n\t\tstatic HALF_CONSTEXPR_CONST bool has_infinity = true;\n\n\t\t/// Supports quiet NaNs.\n\t\tstatic HALF_CONSTEXPR_CONST bool has_quiet_NaN = true;\n\n\t\t/// Supports subnormal values.\n\t\tstatic HALF_CONSTEXPR_CONST float_denorm_style has_denorm = denorm_present;\n\n\t\t/// Rounding mode.\n\t\t/// Due to the mix of internal single-precision computations (using the rounding mode of the underlying \n\t\t/// single-precision implementation) with explicit truncation of the single-to-half conversions, the actual rounding \n\t\t/// mode is indeterminate.\n\t\tstatic HALF_CONSTEXPR_CONST float_round_style round_style = (std::numeric_limits<float>::round_style==\n\t\t\thalf::round_style) ? half::round_style : round_indeterminate;\n\n\t\t/// Significant digits.\n\t\tstatic HALF_CONSTEXPR_CONST int digits = 11;\n\n\t\t/// Significant decimal digits.\n\t\tstatic HALF_CONSTEXPR_CONST int digits10 = 3;\n\n\t\t/// Required decimal digits to represent all possible values.\n\t\tstatic HALF_CONSTEXPR_CONST int max_digits10 = 5;\n\n\t\t/// Number base.\n\t\tstatic HALF_CONSTEXPR_CONST int radix = 2;\n\n\t\t/// One more than smallest exponent.\n\t\tstatic HALF_CONSTEXPR_CONST int min_exponent = -13;\n\n\t\t/// Smallest normalized representable power of 10.\n\t\tstatic HALF_CONSTEXPR_CONST int min_exponent10 = -4;\n\n\t\t/// One more than largest exponent\n\t\tstatic HALF_CONSTEXPR_CONST int max_exponent = 16;\n\n\t\t/// Largest finitely representable power of 10.\n\t\tstatic HALF_CONSTEXPR_CONST int max_exponent10 = 4;\n\n\t\t/// Smallest positive normal value.\n\t\tstatic HALF_CONSTEXPR half min() HALF_NOTHROW { return half(detail::binary, 0x0400); }\n\n\t\t/// Smallest finite value.\n\t\tstatic HALF_CONSTEXPR half lowest() HALF_NOTHROW { return half(detail::binary, 0xFBFF); }\n\n\t\t/// Largest finite value.\n\t\tstatic HALF_CONSTEXPR half max() HALF_NOTHROW { return half(detail::binary, 0x7BFF); }\n\n\t\t/// Difference between one and next representable value.\n\t\tstatic HALF_CONSTEXPR half epsilon() HALF_NOTHROW { return half(detail::binary, 0x1400); }\n\n\t\t/// Maximum rounding error.\n\t\tstatic HALF_CONSTEXPR half round_error() HALF_NOTHROW\n\t\t\t{ return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }\n\n\t\t/// Positive infinity.\n\t\tstatic HALF_CONSTEXPR half infinity() HALF_NOTHROW { return half(detail::binary, 0x7C00); }\n\n\t\t/// Quiet NaN.\n\t\tstatic HALF_CONSTEXPR half quiet_NaN() HALF_NOTHROW { return half(detail::binary, 0x7FFF); }\n\n\t\t/// Signalling NaN.\n\t\tstatic HALF_CONSTEXPR half signaling_NaN() HALF_NOTHROW { return half(detail::binary, 0x7DFF); }\n\n\t\t/// Smallest positive subnormal value.\n\t\tstatic HALF_CONSTEXPR half denorm_min() HALF_NOTHROW { return half(detail::binary, 0x0001); }\n\t};\n\n#if HALF_ENABLE_CPP11_HASH\n\t/// Hash function for half-precision floats.\n\t/// This is only defined if C++11 `std::hash` is supported and enabled.\n\ttemplate<> struct hash<half> //: unary_function<half,size_t>\n\t{\n\t\t/// Type of function argument.\n\t\ttypedef half argument_type;\n\n\t\t/// Function return type.\n\t\ttypedef size_t result_type;\n\n\t\t/// Compute hash function.\n\t\t/// \\param arg half to hash\n\t\t/// \\return hash value\n\t\tresult_type operator()(argument_type arg) const\n\t\t\t{ return hash<detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }\n\t};\n#endif\n}\n\n\n#undef HALF_CONSTEXPR\n#undef HALF_CONSTEXPR_CONST\n#undef HALF_NOEXCEPT\n#undef HALF_NOTHROW\n#ifdef HALF_POP_WARNINGS\n\t#pragma warning(pop)\n\t#undef HALF_POP_WARNINGS\n#endif\n\n#endif // AESL_SYN\n\n// implemented in lib_hlsm.cpp\n//extern int __signbit(half a_re);\nextern half half_nan(const char *tagp);\n// extern int __isfinite(half t_in);\n// extern int __isinf(half t_in);\n// extern int __isnan(half t_in);\n// extern int __isnormal(half t_in);\n// extern int __fpclassify(half t_in);\nextern half half_atan(half t);\nextern half half_atan2(half y, half x);\nextern half half_copysign(half x, half y);\n//extern half copysign(half x, half y);\nextern half half_fabs(half x);\n//extern half fabs(half x);\nextern half half_abs(half x);\nextern half half_fma(half x, half y, half z);\nextern half half_mad(half x, half y, half z);\nextern half half_frexp (half x, int* exp);\nextern half half_ldexp (half x, int exp);\nextern half half_fmax(half x, half y);\n//extern half fmax(half x, half y);\nextern half half_fmin(half x, half y);\n//extern half fmin(half x, half y);\nextern half half_asin(half t_in);\nextern half half_acos(half t_in);\nextern half half_sin(half t_in);\nextern half half_cos(half t_in);\nextern void half_sincos(half x, half *sin, half *cos);\nextern half half_sinh(half t_in);\nextern half half_cosh(half t_in);\nextern half half_sinpi(half t_in);\nextern half half_cospi(half t_in);\nextern half half_recip(half x);\nextern half half_sqrt(half x);\nextern half half_rsqrt(half x);\nextern half half_cbrt(half x);\nextern half half_hypot(half x, half y);\nextern half half_log(half x);\nextern half half_log10(half x);\nextern half half_log2(half x);\nextern half half_logb(half x);\nextern half half_log1p(half x);\nextern int half_ilogb(half x);\nextern half half_exp(half x);\nextern half half_exp10(half x);\nextern half half_exp2(half x);\nextern half half_expm1(half x);\nextern half half_pow(half x, half y);\nextern half half_powr(half x, half y);\nextern half half_pown(half x, int y);\nextern half half_rootn(half x, int y);\nextern half half_floor(half x);\n//half floor(half x)\nextern half half_ceil(half x);\n//half ceil(half x)\nextern half half_trunc(half x);\n// half trunc(half x)\nextern half half_round(half x);\n//half round(half x)\nextern half half_nearbyint(half x);\nextern half half_rint(half x);\nextern long int half_lrint(half x);\nextern long long int half_llrint(half x);\nextern long int half_lround(half x);\nextern long long int half_llround(half x);\nextern half half_modf(half x, half *intpart);\n// half modf(half x, half *intpart)\nextern half half_fract(half x, half *intpart);\nextern half half_nextafter(half x, half y);\nextern half half_fmod(half x, half y);\nextern half half_remainder(half x, half y);\nextern half half_remquo(half x, half y, int* quo);\nextern half half_divide(half x, half y);\n#endif\n\n// vim: ts=4:sw=4:tw=4:noexpandtab:\n\n",
    "ap_int.h": "/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_INT_H__\n#define __AP_INT_H__\n\n#include \"ap_common.h\"\n#include \"ap_int_base.h\"\n#include \"ap_int_ref.h\"\n\n//---------------------------------------------------------------\n\n/// Sign Arbitrary Precision Type.\ntemplate <int _AP_W>\nstruct ap_int : ap_int_base<_AP_W, true> {\n  typedef ap_int_base<_AP_W, true> Base;\n  // Constructor\n  INLINE ap_int() : Base() {}\n  template <int _AP_W2>\n  INLINE ap_int(const ap_int<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int(const volatile ap_int<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int(const ap_uint<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int(const volatile ap_uint<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n#ifdef __SYNTHESIS__\n#if ((__clang_major__ != 3) || (__clang_minor__ != 1))\n  /// ctor from raw val\n  INLINE ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {\n    Base::V = V;\n  }\n#endif\n#endif\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)\n      : Base(ref) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {\n  }\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_int(\n      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_int(\n      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n#define CTOR(TYPE) \\\n  INLINE ap_int(TYPE val) { Base::V = val; }\n  CTOR(bool)\n  CTOR(char)\n  CTOR(signed char)\n  CTOR(unsigned char)\n  CTOR(short)\n  CTOR(unsigned short)\n  CTOR(int)\n  CTOR(unsigned int)\n  CTOR(long)\n  CTOR(unsigned long)\n  CTOR(ap_slong)\n  CTOR(ap_ulong)\n#undef CTOR\n  ap_int(double val) : Base(val) {}\n  ap_int(float val) : Base(val) {}\n  ap_int(half val) : Base(val) {}\n\n  // ap_int_base will guess radix if radix is not provided.\n  INLINE ap_int(const char* s) : Base(s) {}\n\n  INLINE ap_int(const char* s, signed char rd) : Base(s, rd) {}\n\n  // Assignment\n  /* ctor will be used when right is not of proper type. */\n\n  INLINE ap_int& operator=(const ap_int<_AP_W>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  /* cannot bind volatile reference to non-volatile type. */\n  INLINE ap_int& operator=(const volatile ap_int<_AP_W>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  /* cannot return volatile *this. */\n  INLINE void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }\n\n  INLINE void operator=(const volatile ap_int<_AP_W>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n}; // struct ap_int.\n\n//---------------------------------------------------------------\n\n/// Unsigned Arbitrary Precision Type.\ntemplate <int _AP_W>\nstruct ap_uint : ap_int_base<_AP_W, false> {\n  typedef ap_int_base<_AP_W, false> Base;\n  // Constructor\n  INLINE ap_uint() : Base() {}\n  template <int _AP_W2>\n  INLINE ap_uint(const ap_uint<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_uint(const ap_int<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_uint(const volatile ap_uint<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_uint(const volatile ap_int<_AP_W2>& op) {\n    Base::V = op.V;\n  }\n\n#ifdef __SYNTHESIS__\n#if ((__clang_major__ != 3) || (__clang_minor__ != 1))\n  /// ctor from raw val\n  INLINE ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {\n    Base::V = V;\n  }\n#endif\n#endif\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)\n      : Base(ref) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {\n  }\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_uint(\n      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}\n\n  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n            int _AP_N2>\n  INLINE ap_uint(\n      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {\n    Base::V = op.V;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_uint(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_uint(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_uint(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n#define CTOR(TYPE) \\\n  INLINE ap_uint(TYPE val) { Base::V = val; }\n  CTOR(bool)\n  CTOR(char)\n  CTOR(signed char)\n  CTOR(unsigned char)\n  CTOR(short)\n  CTOR(unsigned short)\n  CTOR(int)\n  CTOR(unsigned int)\n  CTOR(long)\n  CTOR(unsigned long)\n  CTOR(ap_slong)\n  CTOR(ap_ulong)\n#undef CTOR\n  ap_uint(double val) : Base(val) {}\n  ap_uint(float val) : Base(val) {}\n  ap_uint(half val) : Base(val) {}\n\n  // ap_int_base will guess radix if radix is not provided.\n  INLINE ap_uint(const char* s) : Base(s) {}\n\n  INLINE ap_uint(const char* s, signed char rd) : Base(s, rd) {}\n\n  // Assignment\n  /* XXX ctor will be used when right is not of proper type. */\n\n  INLINE ap_uint& operator=(const ap_uint<_AP_W>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  /* cannot bind volatile reference to non-volatile type. */\n  INLINE ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  /* cannot return volatile *this. */\n  INLINE void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }\n\n  INLINE void operator=(const volatile ap_uint<_AP_W>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n}; // struct ap_uint.\n\n#define ap_bigint ap_int\n#define ap_biguint ap_uint\n\n#if !defined(__SYNTHESIS__) && (defined(SYSTEMC_H) || defined(SYSTEMC_INCLUDED))\n// XXX sc_trace overload for ap_fixed is already included in\n// \"ap_sysc/ap_sc_extras.h\", so do not define in synthesis.\ntemplate <int _AP_W>\nINLINE void sc_trace(sc_core::sc_trace_file* tf, const ap_int<_AP_W>& op,\n                     const std::string& name) {\n  if (tf) tf->trace(sc_dt::sc_lv<_AP_W>(op.to_string(2).c_str()), name);\n}\n\ntemplate <int _AP_W>\nINLINE void sc_trace(sc_core::sc_trace_file* tf, const ap_uint<_AP_W>& op,\n                     const std::string& name) {\n  if (tf) tf->trace(sc_dt::sc_lv<_AP_W>(op.to_string(2).c_str()), name);\n}\n#endif // System C sim\n\n#include \"ap_int_special.h\"\n\n#endif // ifndef __AP_INT_H__ else\n\n// FIXME user should include ap_fixed.h when using ap_fixed.\n// to avoid circular inclusion, must check whether this is required by\n// ap_fixed.h\n#ifndef __AP_FIXED_H__\n#include \"ap_fixed.h\"\n#endif\n\n// -*- cpp -*-\n",
    "etc/../hls_half.h": "// half - IEEE 754-based half-precision floating point library.\n//\n// Copyright (c) 2012-2013 Christian Rau <rauy@users.sourceforge.net>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation \n// files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, \n// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the \n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR \n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Version 1.11.0\n\n/// \\file\n/// Main header file for half precision functionality.\n\n#ifndef __HLS_HALF_H__\n#define __HLS_HALF_H__\n\n#ifndef __cplusplus\n#ifndef __SYNTHESIS__ \n#error C++ is required to include this header file\n#endif\n#endif\n#ifndef __SYNTHESIS__\n#include \"cmath\"\n#endif\n\n#ifdef __SYNTHESIS__ \n\n#ifndef _HLS_HALF_DEFINED_\ntypedef __fp16 half;\n#endif\n\n#else // AESL_SYN\n\n// XXX work-around old version of GMP with C++11 <cstddef> used by fpo.\n#include \"cstddef\"\n#include \"hls_fpo.h\"\n\n//Forward declaration of ap_fixed_base.\n#include \"ap_decl.h\"\n\n#ifdef HLS_NO_XIL_FPO_LIB\n//#warning \"Xilinx Floating Point Operator IP core does not provide simulation models for ARM architecture. Then there may be mismatch between simulation model and FPGA implementation\" \n\n#else\n\n// Fiddle an MPFR variable to contain the same information as an xip_fpo_t variable without allocating memory\n// m is the mpfr_t variable (destination), x is the xip_fpo_t variable (source)\n// First variant: copy all information\n#define XIP_FPO_2_MPFR(m, x) \\\n(m)->_mpfr_prec = (x)->_xip_fpo_mant_prec; \\\n(m)->_mpfr_sign = (x)->_xip_fpo_sign;      \\\n(m)->_mpfr_exp  = (x)->_xip_fpo_exp;       \\\n(m)->_mpfr_d    = (x)->_xip_fpo_d;\n\n#endif\n\n/// Combined gcc version number.\n#define HALF_GNUC_VERSION (__GNUC__*100+__GNUC_MINOR__)\n\n//check C++11 language features\n#if defined(__clang__)\t\t\t\t\t\t\t\t\t\t//clang\n\t#if __has_feature(cxx_static_assert) && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if __has_feature(cxx_constexpr) && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t#endif\n\t#if __has_feature(cxx_noexcept) && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t#endif\n\t#if __has_feature(cxx_user_literals) && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n\t\t#define HALF_ENABLE_CPP11_USER_LITERALS 1\n\t#endif\n\t#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L) && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif\n/*#elif defined(__INTEL_COMPILER)\t\t\t\t\t\t\t\t//Intel C++\n\t#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\t\t????????\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1300 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t#endif\n\t#if __INTEL_COMPILER >= 1100 && !defined(HALF_ENABLE_CPP11_LONG_LONG)\t\t\t????????\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif*/\n#elif defined(__GNUC__)\t\t\t\t\t\t\t\t\t\t//gcc\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L\n\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_CONSTEXPR)\n\t\t\t#define HALF_ENABLE_CPP11_CONSTEXPR 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 406 && !defined(HALF_ENABLE_CPP11_NOEXCEPT)\n\t\t\t#define HALF_ENABLE_CPP11_NOEXCEPT 1\n\t\t#endif\n\t\t#if HALF_GNUC_VERSION >= 407 && !defined(HALF_ENABLE_CPP11_USER_LITERALS)\n\t\t\t#define HALF_ENABLE_CPP11_USER_LITERALS 1\n\t\t#endif\n\t\t#if !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t\t#endif\n\t#endif\n#elif defined(_MSC_VER)\t\t\t\t\t\t\t\t\t\t//Visual C++\n\t#if _MSC_VER >= 1600 && !defined(HALF_ENABLE_CPP11_STATIC_ASSERT)\n\t\t#define HALF_ENABLE_CPP11_STATIC_ASSERT 1\n\t#endif\n\t#if _MSC_VER >= 1310 && !defined(HALF_ENABLE_CPP11_LONG_LONG)\n\t\t#define HALF_ENABLE_CPP11_LONG_LONG 1\n\t#endif\n\t#define HALF_POP_WARNINGS 1\n\t#pragma warning(push)\n\t#pragma warning(disable : 4099 4127 4146)\t//struct vs class, constant in if, negative unsigned\n#endif\n\n//check C++11 library features\n#include \"utility\"\n#if defined(_LIBCPP_VERSION)\t\t\t\t\t\t\t\t//libc++\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n\t\t#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CSTDINT\n\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CMATH\n\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_HASH\n\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t#endif\n\t#endif\n#elif defined(__GLIBCXX__)\t\t\t\t\t\t\t\t\t//libstdc++\n\t#if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103\n\t\t#ifdef __clang__\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_TYPE_TRAITS)\n\t\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n\t\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_CMATH)\n\t\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t\t#endif\n\t\t\t#if __GLIBCXX__ >= 20080606 && !defined(HALF_ENABLE_CPP11_HASH)\n\t\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t\t#endif\n\t\t#else\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CSTDINT)\n\t\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t\t#endif\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_CMATH)\n\t\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t\t#endif\n\t\t\t#if HALF_GNUC_VERSION >= 403 && !defined(HALF_ENABLE_CPP11_HASH)\n\t\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t\t#endif\n\t\t#endif\n\t#endif\n#elif defined(_CPPLIB_VER)\t\t\t\t\t\t\t\t\t//Dinkumware/Visual C++\n\t#if _CPPLIB_VER >= 520\n\t\t#ifndef HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\t#define HALF_ENABLE_CPP11_TYPE_TRAITS 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_CSTDINT\n\t\t\t#define HALF_ENABLE_CPP11_CSTDINT 1\n\t\t#endif\n\t\t#ifndef HALF_ENABLE_CPP11_HASH\n\t\t\t#define HALF_ENABLE_CPP11_HASH 1\n\t\t#endif\n\t#endif\n\t#if _CPPLIB_VER >= 610\n\t\t#ifndef HALF_ENABLE_CPP11_CMATH\n\t\t\t#define HALF_ENABLE_CPP11_CMATH 1\n\t\t#endif\n\t#endif\n#endif\n#undef HALF_GNUC_VERSION\n\n//support constexpr\n#if HALF_ENABLE_CPP11_CONSTEXPR\n\t#define HALF_CONSTEXPR\t\t\tconstexpr\n\t#define HALF_CONSTEXPR_CONST\tconstexpr\n#else\n\t#define HALF_CONSTEXPR\n\t#define HALF_CONSTEXPR_CONST\tconst\n#endif\n\n//support noexcept\n#if HALF_ENABLE_CPP11_NOEXCEPT\n\t#define HALF_NOEXCEPT\tnoexcept\n\t#define HALF_NOTHROW\tnoexcept\n#else\n\t#define HALF_NOEXCEPT\n\t#define HALF_NOTHROW\tthrow()\n#endif\n\n#include \"algorithm\"\n#include \"iostream\"\n#include \"limits\"\n#include \"climits\"\n//#include \"cmath\"\n#include \"cstring\"\n#if HALF_ENABLE_CPP11_TYPE_TRAITS\n\t#include \"type_traits\"\n#endif\n#if HALF_ENABLE_CPP11_CSTDINT\n\t#include \"cstdint\"\n#endif\n#if HALF_ENABLE_CPP11_HASH\n\t#include \"functional\"\n#endif\n\n\n/// Default rounding mode.\n/// This specifies the rounding mode used for all conversions between [half](\\ref half)s and `float`s as well as \n/// for the half_cast() if not specifying a rounding mode explicitly. It can be redefined (before including half.hpp) to one \n/// of the standard rounding modes using their respective constants or the equivalent values of `std::float_round_style`:\n///\n/// `std::float_round_style`         | value | rounding\n/// ---------------------------------|-------|-------------------------\n/// `std::round_indeterminate`       | -1    | fastest (default)\n/// `std::round_toward_zero`         | 0     | toward zero\n/// `std::round_to_nearest`          | 1     | to nearest\n/// `std::round_toward_infinity`     | 2     | toward positive infinity\n/// `std::round_toward_neg_infinity` | 3     | toward negative infinity\n///\n/// By default this is set to `-1` (`std::round_indeterminate`), which uses truncation (round toward zero, but with overflows \n/// set to infinity) and is the fastest rounding mode possible. It can even be set to `std::numeric_limits<float>::round_style` \n/// to synchronize the rounding mode with that of the underlying single-precision implementation.\n#ifndef HALF_ROUND_STYLE\n\t#define HALF_ROUND_STYLE\t1\t\t\t// = std::round_indeterminate\n#endif\n\n/// Tie-breaking behaviour for round to nearest.\n/// This specifies if ties in round to nearest should be resolved by rounding to the nearest even value. By default this is \n/// defined to `0` resulting in the faster but slightly more biased behaviour of rounding away from zero in half-way cases (and \n/// thus equal to the round() function), but can be redefined to `1` (before including half.hpp) if more IEEE-conformant \n/// behaviour is needed.\n#ifndef HALF_ROUND_TIES_TO_EVEN\n\t#define HALF_ROUND_TIES_TO_EVEN\t1\t\t// ties away from zero\n#endif\n\n/// Value signaling overflow.\n/// In correspondence with `HUGE_VAL[F|L]` from `<cmath>` this symbol expands to a positive value signaling the overflow of an \n/// operation, in particular it just evaluates to positive infinity.\n#define HUGE_VALH\tstd::numeric_limits<half>::infinity()\n\n/// Fast half-precision fma function.\n/// This symbol is only defined if the fma() function generally executes as fast as, or faster than, a separate \n/// half-precision multiplication followed by an addition. Due to the internal single-precision implementation of all \n/// arithmetic operations, this is in fact always the case.\n#define FP_FAST_FMAH\t1\n\n#ifndef FP_ILOGB0\n\t#define FP_ILOGB0\t\tINT_MIN\n#endif\n#ifndef FP_ILOGBNAN\n\t#define FP_ILOGBNAN\t\tINT_MAX\n#endif\n#ifndef FP_SUBNORMAL\n\t#define FP_SUBNORMAL\t0\n#endif\n#ifndef FP_ZERO\n\t#define FP_ZERO\t\t\t1\n#endif\n#ifndef FP_NAN\n\t#define FP_NAN\t\t\t2\n#endif\n#ifndef FP_INFINITE\n\t#define FP_INFINITE\t\t3\n#endif\n#ifndef FP_NORMAL\n\t#define FP_NORMAL\t\t4\n#endif\n\n\n/// Main namespace for half precision functionality.\n/// This namespace contains all the functionality provided by the library.\n\tclass half;\n\n\t/// \\internal\n\t/// \\brief Implementation details.\n\tnamespace detail\n\t{\n\t#if HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t/// Conditional type.\n\t\ttemplate<bool B,typename T,typename F> struct conditional : std::conditional<B,T,F> {};\n\n\t\t/// Helper for tag dispatching.\n\t\ttemplate<bool B> struct bool_type : std::integral_constant<bool,B> {};\n\t\tusing std::true_type;\n\t\tusing std::false_type;\n\n\t\t/// Type traits for floating point types.\n\t\ttemplate<typename T> struct is_float : std::is_floating_point<T> {};\n\t#else\n\t\t/// Conditional type.\n\t\ttemplate<bool,typename T,typename> struct conditional { typedef T type; };\n\t\ttemplate<typename T,typename F> struct conditional<false,T,F> { typedef F type; };\n\n\t\t/// Helper for tag dispatching.\n\t\ttemplate<bool> struct bool_type {};\n\t\ttypedef bool_type<true> true_type;\n\t\ttypedef bool_type<false> false_type;\n\n\t\t/// Type traits for floating point types.\n\t\ttemplate<typename> struct is_float : false_type {};\n\t\ttemplate<typename T> struct is_float<const T> : is_float<T> {};\n\t\ttemplate<typename T> struct is_float<volatile T> : is_float<T> {};\n\t\ttemplate<typename T> struct is_float<const volatile T> : is_float<T> {};\n\t\ttemplate<> struct is_float<float> : true_type {};\n\t\ttemplate<> struct is_float<double> : true_type {};\n\t\ttemplate<> struct is_float<long double> : true_type {};\n\t#endif\n\n\t#if HALF_ENABLE_CPP11_CSTDINT\n\t\t/// Unsigned integer of (at least) 16 bits width.\n\t\ttypedef std::uint_least16_t uint16;\n\n\t\t/// Unsigned integer of (at least) 32 bits width.\n\t\ttypedef std::uint_least32_t uint32;\n\n\t\t/// Fastest signed integer capable of holding all values of type uint16.\n\t\ttypedef std::int_fast32_t int17;\n\t#else\n\t\t/// Unsigned integer of (at least) 16 bits width.\n\t\ttypedef unsigned short uint16;\n\n\t\t/// Unsigned integer of (at least) 32 bits width.\n\t\ttypedef conditional<std::numeric_limits<unsigned int>::digits>=32,unsigned int,unsigned long>::type uint32;\n\n\t\t/// Fastest signed integer capable of holding all values of type uint16.\n\t\ttypedef conditional<std::numeric_limits<int>::digits>=16,int,long>::type int17;\n\t#endif\n\n\t\t/// Tag type for binary construction.\n\t\tstruct binary_t {};\n\n\t\t/// Tag for binary construction.\n\t\tHALF_CONSTEXPR_CONST binary_t binary = binary_t();\n\n\t\t/// Temporary half-precision expression.\n\t\t/// This class represents a half-precision expression which just stores a single-precision value internally.\n\t\tstruct expr\n\t\t{\n\t\t\t/// Conversion constructor.\n\t\t\t/// \\param f single-precision value to convert\n\t\t\texplicit HALF_CONSTEXPR expr(float f) : value_(f) {}\n\n\t\t\t/// Conversion to single-precision.\n\t\t\t/// \\return single precision value representing expression value\n\t\t\tHALF_CONSTEXPR operator float() const { return value_; }\n\n\t\tprivate:\n\t\t\t/// Internal expression value stored in single-precision.\n\t\t\tfloat value_;\n\t\t};\n\n\t\t/// SFINAE helper for generic half-precision functions.\n\t\t/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n\t\t/// `type` member equivalent to \\a T.\n\t\t/// \\tparam T type to return\n\t\ttemplate<typename T,typename,typename=void,typename=void> struct enable {};\n\t\ttemplate<typename T> struct enable<T,half,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,float,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,double,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,long long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,int,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,short,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,char,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,void,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,long long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,int,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,short,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,char,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,float,half,void> { typedef float type; };\n\t\ttemplate<typename T> struct enable<T,half,float,void> { typedef float type; };\n\t\ttemplate<typename T> struct enable<T,double,half,void> { typedef double type; };\n\t\ttemplate<typename T> struct enable<T,half,double,void> { typedef double type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,void> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,half,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,half,expr,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,half,expr> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,half> { typedef T type; };\n\t\ttemplate<typename T> struct enable<T,expr,expr,expr> { typedef T type; };\n\n\t\t/// Return type for specialized generic 2-argument half-precision functions.\n\t\t/// This class template has to be specialized for each valid combination of argument types to provide a corresponding \n\t\t/// `type` member denoting the appropriate return type.\n\t\t/// \\tparam T first argument type\n\t\t/// \\tparam U first argument type\n\t\ttemplate<typename T,typename U> struct result : enable<expr,T,U> {};\n\t\ttemplate<> struct result<half,half> { typedef half type; };\n\n\t\t/// \\name Classification helpers\n\t\t/// \\{\n\n\t\t/// Check for infinity.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if infinity\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_isinf(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::isinf(arg);\n\t\t#elif defined(_MSC_VER)\n\t\t\treturn !_finite(static_cast<double>(arg)) && !_isnan(static_cast<double>(arg));\n\t\t#else\n\t\t\treturn arg == std::numeric_limits<T>::infinity() || arg == -std::numeric_limits<T>::infinity();\n\t\t#endif\n\t\t}\n\n\t\t/// Check for NaN.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if not a number\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_isnan(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::isnan(arg);\n\t\t#elif defined(_MSC_VER)\n\t\t\treturn _isnan(static_cast<double>(arg)) != 0;\n\t\t#else\n\t\t\treturn arg != arg;\n\t\t#endif\n\t\t}\n\n\t\t/// Check sign.\n\t\t/// \\tparam T argument type (builtin floating point type)\n\t\t/// \\param arg value to query\n\t\t/// \\retval true if signbit set\n\t\t/// \\retval false else\n\t\ttemplate<typename T> bool builtin_signbit(T arg)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\treturn std::signbit(arg);\n\t\t#else\n\t\t\treturn arg < T() || (arg == T() && T(1)/arg < T());\n\t\t#endif\n\t\t}\n\n\t\t/// \\}\n\t\t/// \\name Conversion\n\t\t/// \\{\n\n\t\t/// Convert IEEE single-precision to half-precision.\n\t\t/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half_impl(float value, true_type)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT\n\t\t\tstatic_assert(std::numeric_limits<float>::is_iec559, \"float to half conversion needs IEEE 754 conformant 'float' type\");\n\t\t\tstatic_assert(sizeof(uint32)==sizeof(float), \"float to half conversion needs unsigned integer type of exactly the size of a 'float'\");\n\t\t#endif\n\t\t\tstatic const uint16 base_table[512] = { \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, \n\t\t\t\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, \n\t\t\t\t0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00, \n\t\t\t\t0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, \n\t\t\t\t0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100, \n\t\t\t\t0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00, \n\t\t\t\t0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, \n\t\t\t\t0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };\n\t\t\tstatic const unsigned char shift_table[512] = { \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n\t\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, \n\t\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };\n\t\t\tuint32 bits;// = *reinterpret_cast<uint32*>(&value);\t\t//violating strict aliasing!\n\t\t\tstd::memcpy(&bits, &value, sizeof(float));\n\t\t\tuint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);\n\t\t\tif(R == std::round_to_nearest)\n\t\t\t\thbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)\n\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t& (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)\n\t\t\t\t#endif\n\t\t\t\t;\n\t\t\telse if(R == std::round_toward_zero)\n\t\t\t\thbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];\n\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\thbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&\n\t\t\t\t\t((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));\n\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\thbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&\n\t\t\t\t\t((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));\n\t\t\treturn hbits;\n\t\t}\n\n\t\t/// Convert non-IEEE single-precision to half-precision.\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half_impl(float value, false_type)\n\t\t{\n\t\t\tuint16 hbits = builtin_signbit(value) << 15;\n\t\t\tif(value == 0.0f)\n\t\t\t\treturn hbits;\n\t\t\tif(builtin_isnan(value))\n\t\t\t\treturn hbits | 0x7FFF;\n\t\t\tif(builtin_isinf(value))\n\t\t\t\treturn hbits | 0x7C00;\n\t\t\tint exp;\n\t\t\tstd::frexp(value, &exp);\n\t\t\tif(exp > 16)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_zero)\n\t\t\t\t\treturn hbits | 0x7BFF;\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\treturn hbits | 0x7C00 - (hbits>>15);\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\treturn hbits | 0x7BFF + (hbits>>15);\n\t\t\t\treturn hbits | 0x7C00;\n\t\t\t}\n\t\t\tif(exp < -13)\n\t\t\t\tvalue = std::ldexp(value, 24);\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = std::ldexp(value, 11-exp);\n\t\t\t\thbits |= ((exp+14)<<10);\n\t\t\t}\n\t\t\tint ival = static_cast<int>(value);\n\t\t\thbits |= static_cast<uint16>(std::abs(ival)&0x3FF);\n\t\t\tif(R == std::round_to_nearest)\n\t\t\t{\n\t\t\t\tfloat diff = std::abs(value-static_cast<float>(ival));\n\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\thbits += (diff>0.5f) | ((diff==0.5f)&hbits);\n\t\t\t\t#else\n\t\t\t\t\thbits += diff >= 0.5f;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\thbits += value > static_cast<float>(ival);\n\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\thbits += value < static_cast<float>(ival);\n\t\t\treturn hbits;\n\t\t}\n\n\t\t/// Convert single-precision to half-precision.\n\t\t/// \\param value single-precision value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R> uint16 float2half(float value)\n\t\t{\n\t\t\treturn float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n\t\t}\n\n\t\t/// Convert integer to half-precision floating point.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam S `true` if value negative, `false` else\n\t\t/// \\tparam T type to convert (builtin integer type)\n\t\t/// \\param value non-negative integral value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)\n\t\t{\n\t\t\tif(S)\n\t\t\t\tvalue = -value;\n\t\t\tuint16 bits = S << 15;\n\t\t\tif(value > 65504)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_infinity)\n\t\t\t\t\tbits |= 0x7C00 - S;\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tbits |= 0x7BFF + S;\n\t\t\t\telse\n\t\t\t\t\tbits |= 0x7BFF + (R!=std::round_toward_zero);\n\t\t\t}\n\t\t\telse if(value)\n\t\t\t{\n\t\t\t\tunsigned int m = value, exp = 25;\n\t\t\t\tfor(; m<0x400; m<<=1,--exp) ;\n\t\t\t\tfor(; m>0x7FF; m>>=1,++exp) ;\n\t\t\t\tbits |= (exp<<10) | (m&0x3FF);\n\t\t\t\tif(exp > 25)\n\t\t\t\t{\n\t\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\t\tbits += (value>>(exp-26)) & 1\n\t\t\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t\t\t& (((((1<<(exp-26))-1)&value)!=0)|bits)\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t;\n\t\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\t\tbits += ((value&((1<<(exp-25))-1))!=0) & !S;\n\t\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\t\tbits += ((value&((1<<(exp-25))-1))!=0) & S;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bits;\n\t\t}\n\n\t\t/// Convert integer to half-precision floating point.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam T type to convert (builtin integer type)\n\t\t/// \\param value integral value\n\t\t/// \\return binary representation of half-precision value\n\t\ttemplate<std::float_round_style R,typename T> uint16 int2half(T value)\n\t\t{\n\t\t\treturn (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);\n\t\t}\n\n\t\t/// Convert half-precision to IEEE single-precision.\n\t\t/// Credit for this goes to [Jeroen van der Zijp](ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf).\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float_impl(uint16 value, true_type)\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT\n\t\t\tstatic_assert(std::numeric_limits<float>::is_iec559, \"half to float conversion needs IEEE 754 conformant 'float' type\");\n\t\t\tstatic_assert(sizeof(uint32)==sizeof(float), \"half to float conversion needs unsigned integer type of exactly the size of a 'float'\");\n\t\t#endif\n\t\t\tstatic const uint32 mantissa_table[2048] = { \n\t\t\t\t0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000, \n\t\t\t\t0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000, \n\t\t\t\t0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000, \n\t\t\t\t0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000, \n\t\t\t\t0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000, \n\t\t\t\t0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000, \n\t\t\t\t0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000, \n\t\t\t\t0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000, \n\t\t\t\t0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000, \n\t\t\t\t0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000, \n\t\t\t\t0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000, \n\t\t\t\t0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000, \n\t\t\t\t0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000, \n\t\t\t\t0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000, \n\t\t\t\t0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000, \n\t\t\t\t0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000, \n\t\t\t\t0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000, \n\t\t\t\t0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000, \n\t\t\t\t0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000, \n\t\t\t\t0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000, \n\t\t\t\t0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000, \n\t\t\t\t0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000, \n\t\t\t\t0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000, \n\t\t\t\t0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000, \n\t\t\t\t0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000, \n\t\t\t\t0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000, \n\t\t\t\t0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000, \n\t\t\t\t0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000, \n\t\t\t\t0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000, \n\t\t\t\t0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000, \n\t\t\t\t0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000, \n\t\t\t\t0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000, \n\t\t\t\t0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000, \n\t\t\t\t0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000, \n\t\t\t\t0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000, \n\t\t\t\t0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000, \n\t\t\t\t0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000, \n\t\t\t\t0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000, \n\t\t\t\t0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000, \n\t\t\t\t0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000, \n\t\t\t\t0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000, \n\t\t\t\t0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000, \n\t\t\t\t0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000, \n\t\t\t\t0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000, \n\t\t\t\t0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000, \n\t\t\t\t0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000, \n\t\t\t\t0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000, \n\t\t\t\t0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000, \n\t\t\t\t0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000, \n\t\t\t\t0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000, \n\t\t\t\t0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000, \n\t\t\t\t0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000, \n\t\t\t\t0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000, \n\t\t\t\t0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000, \n\t\t\t\t0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000, \n\t\t\t\t0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000, \n\t\t\t\t0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000, \n\t\t\t\t0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000, \n\t\t\t\t0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000, \n\t\t\t\t0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000, \n\t\t\t\t0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000, \n\t\t\t\t0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000, \n\t\t\t\t0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000, \n\t\t\t\t0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000, \n\t\t\t\t0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000, \n\t\t\t\t0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000, \n\t\t\t\t0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000, \n\t\t\t\t0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000, \n\t\t\t\t0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000, \n\t\t\t\t0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000, \n\t\t\t\t0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000, \n\t\t\t\t0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000, \n\t\t\t\t0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000, \n\t\t\t\t0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000, \n\t\t\t\t0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000, \n\t\t\t\t0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000, \n\t\t\t\t0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000, \n\t\t\t\t0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000, \n\t\t\t\t0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000, \n\t\t\t\t0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000, \n\t\t\t\t0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000, \n\t\t\t\t0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000, \n\t\t\t\t0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000, \n\t\t\t\t0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000, \n\t\t\t\t0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000, \n\t\t\t\t0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000, \n\t\t\t\t0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000, \n\t\t\t\t0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000, \n\t\t\t\t0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000, \n\t\t\t\t0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000, \n\t\t\t\t0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000, \n\t\t\t\t0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000, \n\t\t\t\t0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000, \n\t\t\t\t0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000, \n\t\t\t\t0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000, \n\t\t\t\t0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000, \n\t\t\t\t0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000, \n\t\t\t\t0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000, \n\t\t\t\t0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000, \n\t\t\t\t0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000, \n\t\t\t\t0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000, \n\t\t\t\t0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000, \n\t\t\t\t0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000, \n\t\t\t\t0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000, \n\t\t\t\t0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000, \n\t\t\t\t0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000, \n\t\t\t\t0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000, \n\t\t\t\t0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000, \n\t\t\t\t0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000, \n\t\t\t\t0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000, \n\t\t\t\t0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000, \n\t\t\t\t0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000, \n\t\t\t\t0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000, \n\t\t\t\t0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000, \n\t\t\t\t0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000, \n\t\t\t\t0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000, \n\t\t\t\t0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000, \n\t\t\t\t0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000, \n\t\t\t\t0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000, \n\t\t\t\t0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000, \n\t\t\t\t0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000, \n\t\t\t\t0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000, \n\t\t\t\t0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000, \n\t\t\t\t0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000, \n\t\t\t\t0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000, \n\t\t\t\t0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000, \n\t\t\t\t0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000, \n\t\t\t\t0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };\n\t\t\tstatic const uint32 exponent_table[64] = { \n\t\t\t\t0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000, \n\t\t\t\t0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000, \n\t\t\t\t0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000, \n\t\t\t\t0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };\n\t\t\tstatic const unsigned short offset_table[64] = { \n\t\t\t\t   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, \n\t\t\t\t   0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };\n\t\t\tuint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];\n//\t\t\tuint32 bits = mantissa_table[(((value&0x7C00)!=0)<<10)+(value&0x3FF)] + exponent_table[value>>10];\n//\t\t\treturn *reinterpret_cast<float*>(&bits);\t\t\t//violating strict aliasing!\n\t\t\tfloat out;\n\t\t\tstd::memcpy(&out, &bits, sizeof(float));\n\t\t\treturn out;\n\t\t}\n\n\t\t/// Convert half-precision to non-IEEE single-precision.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float_impl(uint16 value, false_type)\n\t\t{\n\t\t\tfloat out;\n\t\t\tint abs = value & 0x7FFF;\n\t\t\tif(abs > 0x7C00)\n\t\t\t\tout = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;\n\t\t\telse if(abs == 0x7C00)\n\t\t\t\tout = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();\n\t\t\telse if(abs > 0x3FF)\n\t\t\t\tout = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);\n\t\t\telse\n\t\t\t\tout = std::ldexp(static_cast<float>(abs), -24);\n\t\t\treturn (value&0x8000) ? -out : out;\n\t\t}\n\n\t\t/// Convert half-precision to single-precision.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return single-precision value\n\t\tinline float half2float(uint16 value)\n\t\t{\n\t\t\treturn half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());\n\t\t}\n\n\t\t/// Convert half-precision floating point to integer.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam E `true` for round to even, `false` for round away from zero\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)\n\t\t{\n\t\t\tunsigned int e = value & 0x7FFF;\n\t\t\tif(e >= 0x7C00)\n\t\t\t\treturn (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();\n\t\t\tif(e < 0x3800)\n\t\t\t{\n\t\t\t\tif(R == std::round_toward_infinity)\n\t\t\t\t\treturn T(~(value>>15)&(e!=0));\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\treturn -T(value>0x8000);\n\t\t\t\treturn T();\n\t\t\t}\n\t\t\tint17 m = (value&0x3FF) | 0x400;\n\t\t\te >>= 10;\n\t\t\tif(e < 25)\n\t\t\t{\n\t\t\t\tif(R == std::round_indeterminate || R == std::round_toward_zero)\n\t\t\t\t\tm >>= 25 - e;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\t\tm += (1<<(24-e)) - (~(m>>(25-e))&E);\n\t\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\t\tm += ((value>>15)-1) & ((1<<(25-e))-1U);\n\t\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\t\tm += -(value>>15) & ((1<<(25-e))-1U);\n\t\t\t\t\tm >>= 25 - e;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tm <<= e - 25;\n//\t\t\tif(std::numeric_limits<T>::digits < 16)\n//\t\t\t\treturn std::min(std::max(m, static_cast<int17>(std::numeric_limits<T>::min())), static_cast<int17>(std::numeric_limits<T>::max()));\n\t\t\treturn static_cast<T>((value&0x8000) ? -m : m);\n\t\t}\n\n\t\t/// Convert half-precision floating point to integer.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,HALF_ROUND_TIES_TO_EVEN,T>(value); }\n\n\t\t/// Convert half-precision floating point to integer using round-to-nearest-away-from-zero.\n\t\t/// \\tparam T type to convert to (buitlin integer type with at least 16 bits precision, excluding any implicit sign bits)\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return integral value\n\t\ttemplate<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }\n\n\t\t/// Round half-precision number to nearest integer value.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\tparam E `true` for round to even, `false` for round away from zero\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\ttemplate<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)\n\t\t{\n\t\t\tunsigned int e = value & 0x7FFF;\n\t\t\tuint16 result = value;\n\t\t\tif(e < 0x3C00)\n\t\t\t{\n\t\t\t\tresult &= 0x8000;\n\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\tresult |= 0x3C00U & -(e>=(0x3800+E));\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\tresult |= 0x3C00U & -(~(value>>15)&(e!=0));\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tresult |= 0x3C00U & -(value>0x8000);\n\t\t\t}\n\t\t\telse if(e < 0x6400)\n\t\t\t{\n\t\t\t\te = 25 - (e>>10);\n\t\t\t\tunsigned int mask = (1<<e) - 1;\n\t\t\t\tif(R == std::round_to_nearest)\n\t\t\t\t\tresult += (1<<(e-1)) - (~(result>>e)&E);\n\t\t\t\telse if(R == std::round_toward_infinity)\n\t\t\t\t\tresult += mask & ((value>>15)-1);\n\t\t\t\telse if(R == std::round_toward_neg_infinity)\n\t\t\t\t\tresult += mask & -(value>>15);\n\t\t\t\tresult &= ~mask;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// Round half-precision number to nearest integer value.\n\t\t/// \\tparam R rounding mode to use, `std::round_indeterminate` for fastest rounding\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\ttemplate<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,HALF_ROUND_TIES_TO_EVEN>(value); }\n\n\t\t/// Round half-precision number to nearest integer value using round-to-nearest-away-from-zero.\n\t\t/// \\param value binary representation of half-precision value\n\t\t/// \\return half-precision bits for nearest integral value\n\t\tinline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }\n\t\t/// \\}\n\n\t\tstruct functions;\n\t\ttemplate<typename> struct unary_specialized;\n\t\ttemplate<typename,typename> struct binary_specialized;\n\t\ttemplate<typename,typename,std::float_round_style> struct half_caster;\n\t}\n\n\t/// Half-precision floating point type.\n\t/// This class implements an IEEE-conformant half-precision floating point type with the usual arithmetic operators and \n\t/// conversions. It is implicitly convertible to single-precision floating point, which makes artihmetic expressions and \n\t/// functions with mixed-type operands to be of the most precise operand type. Additionally all arithmetic operations \n\t/// (and many mathematical functions) are carried out in single-precision internally. All conversions from single- to \n\t/// half-precision are done using truncation (round towards zero), but temporary results inside chained arithmetic \n\t/// expressions are kept in single-precision as long as possible (while of course still maintaining a strong half-precision type).\n\t///\n\t/// According to the C++98/03 definition, the half type is not a POD type. But according to C++11's less strict and \n\t/// extended definitions it is both a standard layout type and a trivially copyable type (even if not a POD type), which \n\t/// means it can be standard-conformantly copied using raw binary copies. But in this context some more words about the \n\t/// actual size of the type. Although the half is representing an IEEE 16-bit type, it does not neccessarily have to be of \n\t/// exactly 16-bits size. But on any reasonable implementation the actual binary representation of this type will most \n\t/// probably not ivolve any additional \"magic\" or padding beyond the simple binary representation of the underlying 16-bit \n\t/// IEEE number, even if not strictly guaranteed by the standard. But even then it only has an actual size of 16 bits if \n\t/// your C++ implementation supports an unsigned integer type of exactly 16 bits width. But this should be the case on \n\t/// nearly any reasonable platform.\n\t///\n\t/// So if your C++ implementation is not totally exotic or imposes special alignment requirements, it is a reasonable \n\t/// assumption that the data of a half is just comprised of the 2 bytes of the underlying IEEE representation.\n\tclass half\n\t{\n\t\tfriend struct detail::functions;\n\t\tfriend struct detail::unary_specialized<half>;\n\t\tfriend struct detail::binary_specialized<half,half>;\n\t\ttemplate<typename,typename,std::float_round_style> friend struct detail::half_caster;\n\t\tfriend struct std::numeric_limits<half>;\n\t#if HALF_ENABLE_CPP11_HASH\n\t\tfriend struct std::hash<half>;\n\t#endif\n\n\tpublic:\n\t\t/// Default constructor.\n\t\t/// This initializes the half to 0. Although this does not match the builtin types' default-initialization semantics \n\t\t/// and may be less efficient than no initialization, it is needed to provide proper value-initialization semantics.\n\t\tHALF_CONSTEXPR half() : data_() {}\n\n\t\t/// Copy constructor.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to copy from\n\t\thalf(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {\n#ifndef HLS_NO_XIL_FPO_LIB\n            xip_fpo_half_set_flt(rhs);\n#endif\n        }\n\n\t\t/// Conversion constructor.\n\t\t/// \\param rhs float to convert\n\t\thalf(float rhs) : data_(detail::float2half<round_style>(rhs)) {\n#ifndef HLS_NO_XIL_FPO_LIB\n            xip_fpo_half_set_flt(rhs);\n#endif\n        }\n\n        /// Conversion constructor from AP types.\n\t\ttemplate<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\n\t\thalf(const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& rhs) {\n\t\t\tstd::cout << \"WARNING: explicit method ap_fixed::to_half() should be used to convert ap_fixed to half.\" << std::endl;\n\t\t\t*this = rhs.to_half();\n\t\t}\n\n\t\t/// Conversion to single-precision.\n\t\t/// \\return single precision value representing expression value\n\t\toperator float() const {\n#ifdef HLS_NO_XIL_FPO_LIB\n            return detail::half2float(data_);\n#else\n            return xip_fpo_half_get_flt();\n#endif\n        }\n\n\t\t/// Assignment operator.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to copy from\n\t\t/// \\return reference to this half\n\t\thalf& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to add\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to subtract\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to multiply with\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\tparam T type of concrete half expression\n\t\t/// \\param rhs half expression to divide by\n\t\t/// \\return reference to this half\n\t\ttemplate<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }\n\n#if 0\n\t\t/* disable to avoid ambiguous overload. */\n\t\t/// Assignment operator.\n\t\t/// \\param rhs single-precision value to copy from\n\t\t/// \\return reference to this half\n\t\thalf& operator=(float rhs) { \n#ifdef HLS_NO_XIL_FPO_LIB\n                    data_ = detail::float2half<round_style>(rhs);\n#else\n                    xip_fpo_half_set_flt(rhs);\n#endif\n                    return *this; \n                }\n#endif\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to add\n\t\t/// \\return reference to this half\n\t\t//half& operator+=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)+rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to subtract\n\t\t/// \\return reference to this half\n\t\t//half& operator-=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)-rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to multiply with\n\t\t/// \\return reference to this half\n\t\t//half& operator*=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)*rhs); return *this; }\n\n\t\t/// Arithmetic assignment.\n\t\t/// \\param rhs single-precision value to divide by\n\t\t/// \\return reference to this half\n\t\t//half& operator/=(float rhs) { data_ = detail::float2half<round_style>(detail::half2float(data_)/rhs); return *this; }\n\n\t\t/// Prefix increment.\n\t\t/// \\return incremented half value\n\t\thalf& operator++() { return *this += 1.0f; }\n\n\t\t/// Prefix decrement.\n\t\t/// \\return decremented half value\n\t\thalf& operator--() { return *this -= 1.0f; }\n\n\t\t/// Postfix increment.\n\t\t/// \\return non-incremented half value\n\t\thalf operator++(int) { half out(*this); ++*this; return out; }\n\n\t\t/// Postfix decrement.\n\t\t/// \\return non-decremented half value\n\t\thalf operator--(int) { half out(*this); --*this; return out; }\n\n        /// Get half internal uint16 representation\n        /// \\return packed uint16 data\n        detail::uint16 get_bits() { return data_; }\n\t\t\n        /// Set half internal uint16 representation\n        /// \\return\n        void set_bits(detail::uint16 bits) { data_ = bits; }\n\n\t\n#ifndef HLS_NO_XIL_FPO_LIB\n        /// Assign value from half data to xip_fpo struct\n        /// \\return xip_fpo exceptions\n        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {\n            int exc = 0;\n            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);\n            op->_xip_fpo_exp  = ((data_ & 0x7C00) >> 10) - 14;\n            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);\n            if ((data_ & 0x7C00) == 0) { // subnormal\n                exc |= 0x1;\n                xip_fpo_set_zero(op, op->_xip_fpo_sign);\n            } else if ((data_ & 0x7FFF) == 0x7C00) { // infinity\n                exc |= 0x2;\n                xip_fpo_set_inf(op, op->_xip_fpo_sign);\n            } else if ((data_ & 0x7FFF) > 0x7C00) { // NaN\n                exc |= 0x4;\n                xip_fpo_set_nan(op);\n            }\n            return exc;\n        }\n\n        /// Convert\n        float xip_fpo_half_get_flt() const {\n            xip_fpo_t op;\n            xip_fpo_init2(op, 5, 11);\n            xip_fpo_exc_t exc = xip_fpo_get_data(op);\n            float res;\n            if (exc & 0x1) {\n                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);\n            } else if (exc & 0x2) {\n                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());\n            } else if (exc & 0x4) {\n                res = std::numeric_limits<float>::quiet_NaN();\n            } else {\n                res = xip_fpo_get_flt(op);\n            }\n            xip_fpo_clear(op);\n            return res;\n        }\n\n        /// Assign value from xip_fpo struct to half data\n        /// \\return void\n        void xip_fpo_set_data(xip_fpo_ptr op) {\n            mpfr_t fr;\n            XIP_FPO_2_MPFR(fr, op);\n            data_ = 0;\n            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;\n            if (mpfr_zero_p(fr)) {\n                data_ &= 0x8000;\n            } else if (mpfr_inf_p(fr)) {\n                data_ |= 0x7C00;\n            } else if (mpfr_nan_p(fr)) {\n                data_ |= 0x7E00;\n            } else {\n                data_ |= (op->_xip_fpo_exp + 14) << 10;\n                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);\n            }\n        }\n        \n        /// Assignment\n        void xip_fpo_half_set_flt(float rhs) {\n            xip_fpo_t op;\n            xip_fpo_init2(op, 5, 11);\n            xip_fpo_set_flt(op, rhs);\n            xip_fpo_set_data(op);\n            xip_fpo_clear(op);\n        }\n#endif\n\n        private:\n\t\t/// Rounding mode to use (always `std::round_indeterminate`)\n\t\tstatic const std::float_round_style round_style = (std::float_round_style)(HALF_ROUND_STYLE);\n\n\t\t/// Constructor.\n\t\t/// \\param bits binary representation to set half to\n\t\tHALF_CONSTEXPR half(detail::binary_t, detail::uint16 bits) : data_(bits) {}\n\n\t\t/// Internal binary representation\n\t\tdetail::uint16 data_;\n\t};\n\n    // half simulation model with Xilinx Floating Point Operator IP core\n#ifndef HLS_NO_XIL_FPO_LIB\n    template<typename F>\n    half math_function_1arg(F f, half x) {\n        half res;\n        xip_fpo_t rop, xop;\n        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        f(rop, xop);\n        res.xip_fpo_set_data(rop);\n        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);\n        return res;\n    }\n\n    template<typename F>\n    half binary_operator(F f, half x, half y) {\n        half res;\n        xip_fpo_t op, xop, yop;\n        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        y.xip_fpo_get_data(yop);\n        f(op, xop, yop);\n        res.xip_fpo_set_data(op);\n        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);\n        return res;\n    }\n    // perform comparison\n    template<typename F>\n    bool binary_operator_compare(F f, half x, half y) {\n        int res;\n        xip_fpo_t xop, yop;\n        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);\n        x.xip_fpo_get_data(xop);\n        y.xip_fpo_get_data(yop);\n        f(&res, xop, yop);\n        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);\n        return res;\n    }\n#endif \n\n#if HALF_ENABLE_CPP11_USER_LITERALS\n\t/// Library-defined half-precision literals.\n\t/// Import this namespace to enable half-precision floating point literals:\n\t/// ~~~~{.cpp}\n\t/// using namespace literal;\n\t/// half = 4.2_h;\n\t/// ~~~~\n\tnamespace literal\n\t{\n\t\t/// Half literal.\n\t\t/// While this returns an actual half-precision value, half literals can unfortunately not be constant expressions due \n\t\t/// to rather involved single-to-half conversion.\n\t\t/// \\param value literal value\n\t\t/// \\return half with given value (if representable)\n\t\tinline half operator \"\" _h(long double value) { return half(static_cast<float>(value)); }\n\t}\n#endif\n\n\n\tnamespace detail\n\t{\n\t\t/// Wrapper implementing unspecialized half-precision functions.\n\t\tstruct functions\n\t\t{\n\t\t\t/// Addition implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision sum\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr plus(float x, float y) { return expr(x+y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }\n\t\t\tstatic float plus(float x, half y) { return HLS_FPO_ADDF(x,y); }\n\t\t\tstatic float plus(half x, float y) { return HLS_FPO_ADDF(x,y); }\n\t\t\tstatic double plus(double x, half y) { return HLS_FPO_ADD(x,y); }\n\t\t\tstatic double plus(half x, double y) { return HLS_FPO_ADD(x,y); }\n#endif\n\n\t\t\t/// Subtraction implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision difference \n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr minus(float x, float y) { return expr(x-y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }\n\t\t\tstatic float minus(float x, half y) { return HLS_FPO_SUBF(x,y); }\n\t\t\tstatic float minus(half x, float y) { return HLS_FPO_SUBF(x,y); }\n\t\t\tstatic double minus(double x, half y) { return HLS_FPO_SUB(x,y); }\n\t\t\tstatic double minus(half x, double y) { return HLS_FPO_SUB(x,y); }\n#endif\n\n\t\t\t/// Multiplication implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision product \n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr multiplies(float x, float y) { return expr(x*y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }\n\t\t\tstatic float multiplies(float x, half y) { return HLS_FPO_MULF(x,y); }\n\t\t\tstatic float multiplies(half x, float y) { return HLS_FPO_MULF(x,y); }\n\t\t\tstatic double multiplies(double x, half y) { return HLS_FPO_MUL(x,y); }\n\t\t\tstatic double multiplies(half x, double y) { return HLS_FPO_MUL(x,y); }\n#endif\n\n\t\t\t/// Division implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision quotient\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\t/// \\return Half-precision sum stored in single-precision\n\t\t\tstatic expr divides(float x, float y) { return expr(x/y); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }\n\t\t\tstatic float divides(float x, half y) { return HLS_FPO_DIVF(x,y); }\n\t\t\tstatic float divides(half x, float y) { return HLS_FPO_DIVF(x,y); }\n\t\t\tstatic double divides(double x, half y) { return HLS_FPO_DIV(x,y); }\n\t\t\tstatic double divides(half x, double y) { return HLS_FPO_DIV(x,y); }\n#endif\n\n\t\t\t/// Output implementation.\n\t\t\t/// \\param out stream to write to\n\t\t\t/// \\param arg value to write\n\t\t\t/// \\return reference to stream\n\t\t\ttemplate<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }\n\n\t\t\t/// Input implementation.\n\t\t\t/// \\param in stream to read from\n\t\t\t/// \\param arg half to read into\n\t\t\t/// \\return reference to stream\n\t\t\ttemplate<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)\n\t\t\t{\n\t\t\t\tfloat f;\n\t\t\t\tif(in >> f)\n\t\t\t\t\targ = f;\n\t\t\t\treturn in;\n\t\t\t}\n\n\t\t\t/// Modulo implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr fmod(float x, float y) { return expr(std::fmod(x, y)); }\n\n\t\t\t/// Remainder implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr remainder(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::remainder(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x) || builtin_isnan(y))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tfloat ax = std::fabs(x), ay = std::fabs(y);\n\t\t\t\tif(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tif(ay >= 65536.0f)\n\t\t\t\t\treturn expr(x);\n\t\t\t\tif(ax == ay)\n\t\t\t\t\treturn expr(builtin_signbit(x) ? -0.0f : 0.0f);\n\t\t\t\tax = std::fmod(ax, ay+ay);\n\t\t\t\tfloat y2 = 0.5f * ay;\n\t\t\t\tif(ax > y2)\n\t\t\t\t{\n\t\t\t\t\tax -= ay;\n\t\t\t\t\tif(ax >= y2)\n\t\t\t\t\t\tax -= ay;\n\t\t\t\t}\n\t\t\t\treturn expr(builtin_signbit(x) ? -ax : ax);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Remainder implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\param quo address to store quotient bits at\n\t\t\t/// \\return Half-precision division remainder stored in single-precision\n\t\t\tstatic expr remquo(float x, float y, int *quo)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::remquo(x, y, quo));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x) || builtin_isnan(y))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tbool sign = builtin_signbit(x), qsign = static_cast<bool>(sign^builtin_signbit(y));\n\t\t\t\tfloat ax = std::fabs(x), ay = std::fabs(y);\n\t\t\t\tif(ax >= 65536.0f || ay < std::ldexp(1.0f, -24))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\tif(ay >= 65536.0f)\n\t\t\t\t\treturn expr(x);\n\t\t\t\tif(ax == ay)\n\t\t\t\t\treturn *quo = qsign ? -1 : 1, expr(sign ? -0.0f : 0.0f);\n\t\t\t\tax = std::fmod(ax, 8.0f*ay);\n\t\t\t\tint cquo = 0;\n\t\t\t\tif(ax >= 4.0f * ay)\n\t\t\t\t{\n\t\t\t\t\tax -= 4.0f * ay;\n\t\t\t\t\tcquo += 4;\n\t\t\t\t}\n\t\t\t\tif(ax >= 2.0f * ay)\n\t\t\t\t{\n\t\t\t\t\tax -= 2.0f * ay;\n\t\t\t\t\tcquo += 2;\n\t\t\t\t}\n\t\t\t\tfloat y2 = 0.5f * ay;\n\t\t\t\tif(ax > y2)\n\t\t\t\t{\n\t\t\t\t\tax -= ay;\n\t\t\t\t\t++cquo;\n\t\t\t\t\tif(ax >= y2)\n\t\t\t\t\t{\n\t\t\t\t\t\tax -= ay;\n\t\t\t\t\t\t++cquo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn *quo = qsign ? -cquo : cquo, expr(sign ? -ax : ax);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Positive difference implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return Positive difference stored in single-precision\n\t\t\tstatic expr fdim(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fdim(x, y));\n\t\t\t#else\n\t\t\t\treturn expr((x<=y) ? 0.0f : (x-y));\n\t\t\t#endif\n\t\t\t}\n\n                        static expr maxmag(float x, float y)\n                        {\n\t\t\t\tif (fabs(y)>fabs(x)) return expr(y);\n\t\t\t\telse return expr(x);\n                        }\n\n                        static expr minmag(float x, float y)\n                        {\n\t\t\t\tif (fabs(y)<fabs(x)) return expr(y);\n\t\t\t\telse return expr(x);\n                        }\n\n\t\t\t/// Fused multiply-add implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\param z third operand\n\t\t\t/// \\return \\a x * \\a y + \\a z stored in single-precision\n\t\t\tstatic expr fma(float x, float y, float z)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH && defined(FP_FAST_FMAF)\n\t\t\t\treturn expr(std::fma(x, y, z));\n\t\t\t#else\n\t\t\t\treturn expr(x*y+z);\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Get NaN.\n\t\t\t/// \\return Half-precision quiet NaN\n\t\t\tstatic half nanh(const char*) { return half(binary, 0x7FFF); }\n\n\t\t\t/// Exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr exp(float arg) { return expr(std::exp(arg)); }\n\n\t\t\t/// Exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr expm1(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::expm1(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::exp(static_cast<double>(arg))-1.0));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Binary exponential implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr exp2(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::exp2(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::exp(arg*0.69314718055994530941723212145818)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log(float arg) { return expr(std::log(arg)); }\n\n\t\t\t/// Common logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log10(float arg) { return expr(std::log10(arg)); }\n\n\t\t\t/// Logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log1p(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::log1p(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::log(1.0+arg)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Binary logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr log2(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::log2(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(std::log(static_cast<double>(arg))*1.4426950408889634073599246810019));\n\t\t\t#endif\n\t\t\t}\n\n                        static expr logb(float arg)\n                        {\n                        #if HALF_ENABLE_CPP11_CMATH\n                                return expr(std::logb(arg));\n                        #else\n                                return expr(static_cast<float>(std::log(static_cast<double>(fabs(arg)))*1.4426950408889634073599246810019));\n                        #endif\n                        }\n\n\t\t\t/// Square root implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sqrt(float arg) { return expr(std::sqrt(arg)); }\n\n\t\t\t/// Cubic root implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cbrt(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::cbrt(arg));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(arg) || builtin_isinf(arg))\n\t\t\t\t\treturn expr(arg);\n\t\t\t\treturn expr(builtin_signbit(arg) ? -static_cast<float>(std::pow(std::fabs(static_cast<double>(arg)), 1.0/3.0)) : \n\t\t\t\t\tstatic_cast<float>(std::pow(static_cast<double>(arg), 1.0/3.0)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hypotenuse implementation.\n\t\t\t/// \\param x first argument\n\t\t\t/// \\param y second argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr hypot(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::hypot(x, y));\n\t\t\t#else\n\t\t\t\treturn expr((builtin_isinf(x) || builtin_isinf(y)) ? std::numeric_limits<float>::infinity() : \n\t\t\t\t\tstatic_cast<float>(std::sqrt(static_cast<double>(x)*x+static_cast<double>(y)*y)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Power implementation.\n\t\t\t/// \\param base value to exponentiate\n\t\t\t/// \\param exp power to expontiate to\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr pow(float base, float exp) { return expr(std::pow(base, exp)); }\n                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }\n                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }\n\t\t\tstatic expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }\n\n\t\t\t/// Sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sin(float arg) { return expr(std::sin(arg)); }\n\n\t\t\t/// Cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cos(float arg) { return expr(std::cos(arg)); }\n\n\t\t\t/// Tan implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tan(float arg) { return expr(std::tan(arg)); }\n\n\t\t\t/// Arc sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr asin(float arg) { return expr(std::asin(arg)); }\n\n\t\t\t/// Arc cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr acos(float arg) { return expr(std::acos(arg)); }\n\n\t\t\t/// Arc tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atan(float arg) { return expr(std::atan(arg)); }\n\n\t\t\t/// Arc tangent implementation.\n\t\t\t/// \\param x first argument\n\t\t\t/// \\param y second argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atan2(float x, float y) { return expr(std::atan2(x, y)); }\n\n\t\t\t/// Hyperbolic sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr sinh(float arg) { return expr(std::sinh(arg)); }\n\n\t\t\t/// Hyperbolic cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr cosh(float arg) { return expr(std::cosh(arg)); }\n\n\t\t\t/// Hyperbolic tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tanh(float arg) { return expr(std::tanh(arg)); }\n\n\t\t\t/// Hyperbolic area sine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr asinh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::asinh(arg));\n\t\t\t#else\n\t\t\t\treturn expr((arg==-std::numeric_limits<float>::infinity()) ? arg : static_cast<float>(std::log(arg+std::sqrt(arg*arg+1.0))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hyperbolic area cosine implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr acosh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::acosh(arg));\n\t\t\t#else\n\t\t\t\treturn expr((arg<-1.0f) ? std::numeric_limits<float>::quiet_NaN() : static_cast<float>(std::log(arg+std::sqrt(arg*arg-1.0))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Hyperbolic area tangent implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr atanh(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::atanh(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(0.5*std::log((1.0+arg)/(1.0-arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Error function implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr erf(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::erf(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(erf(static_cast<double>(arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Complementary implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr erfc(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::erfc(arg));\n\t\t\t#else\n\t\t\t\treturn expr(static_cast<float>(1.0-erf(static_cast<double>(arg))));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Gamma logarithm implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr lgamma(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::lgamma(arg));\n\t\t\t#else\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn expr(std::numeric_limits<float>::infinity());\n\t\t\t\tdouble z = static_cast<double>(arg);\n\t\t\t\tif(z < 0)\n\t\t\t\t{\n\t\t\t\t\tdouble i, f = std::modf(-z, &i);\n\t\t\t\t\tif(f == 0.0)\n\t\t\t\t\t\treturn expr(std::numeric_limits<float>::infinity());\n\t\t\t\t\treturn expr(static_cast<float>(1.1447298858494001741434273513531-std::log(std::abs(std::sin(3.1415926535897932384626433832795*f)))-lgamma(1.0-z)));\n\t\t\t\t}\n//\t\t\t\tif(z < 8.0)\n\t\t\t\t\treturn expr(static_cast<float>(lgamma(static_cast<double>(arg))));\n\t\t\t\treturn expr(static_cast<float>(0.5*(1.8378770664093454835606594728112-std::log(z))+z*(std::log(z+1.0/(12.0*z-1.0/(10.0*z)-1.0))-1.0)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Gamma implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return function value stored in single-preicision\n\t\t\tstatic expr tgamma(float arg)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::tgamma(arg));\n\t\t\t#else\n\t\t\t\tdouble z = static_cast<double>(arg);\n\t\t\t\tif(z == 0.0)\n\t\t\t\t\treturn builtin_signbit(z) ? expr(-std::numeric_limits<float>::infinity()) : expr(std::numeric_limits<float>::infinity());\n\t\t\t\tif(z < 0.0)\n\t\t\t\t{\n\t\t\t\t\tdouble i, f = std::modf(-z, &i);\n\t\t\t\t\tif(f == 0.0)\n\t\t\t\t\t\treturn expr(std::numeric_limits<float>::quiet_NaN());\n\t\t\t\t\tdouble sign = (std::fmod(i, 2.0)==0.0) ? -1.0 : 1.0;\n\t\t\t\t\treturn expr(static_cast<float>(sign*3.1415926535897932384626433832795/(std::sin(3.1415926535897932384626433832795*f)*std::exp(lgamma(1.0-z)))));\n\t\t\t\t}\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn expr(arg);\n//\t\t\t\tif(arg < 8.0f)\n\t\t\t\t\treturn expr(static_cast<float>(std::exp(lgamma(z))));\n\t\t\t\treturn expr(static_cast<float>(std::sqrt(6.283185307179586476925286766559/z)*std::pow(0.36787944117144232159552377016146*(z+1.0/(12.0*z-1.0/(10.0*z))), z)));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Floor implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }\n\n\t\t\t/// Ceiling implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }\n\n\t\t\t/// Truncation implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half round(half arg) { return half(binary, round_half_up(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long lround(half arg) { return detail::half2int_up<long>(arg.data_); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }\n\n\t\t#if HALF_ENABLE_CPP11_LONG_LONG\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }\n\n\t\t\t/// Nearest integer implementation.\n\t\t\t/// \\param arg value to round\n\t\t\t/// \\return rounded value\n\t\t\tstatic long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }\n\t\t#endif\n\n\t\t\t/// Decompression implementation.\n\t\t\t/// \\param arg number to decompress\n\t\t\t/// \\param exp address to store exponent at\n\t\t\t/// \\return normalized significant\n\t\t\tstatic half frexp(half arg, int *exp)\n\t\t\t{\n\t\t\t\tunsigned int m = arg.data_ & 0x7FFF;\n\t\t\t\tif(m >= 0x7C00 || !m)\n\t\t\t\t\treturn *exp = 0, arg;\n\t\t\t\tint e = m >> 10;\n\t\t\t\tif(!e)\n\t\t\t\t\tfor(m<<=1; m<0x400; m<<=1,--e) ;\n\t\t\t\treturn *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));\n\t\t\t}\n\n\t\t\t/// Decompression implementation.\n\t\t\t/// \\param arg number to decompress\n\t\t\t/// \\param iptr address to store integer part at\n\t\t\t/// \\return fractional part\n\t\t\tstatic half modf(half arg, half *iptr)\n\t\t\t{\n\t\t\t\tunsigned int e = arg.data_ & 0x7C00;\n\t\t\t\tif(e > 0x6000)\n\t\t\t\t\treturn *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);\n\t\t\t\tif(e < 0x3C00)\n\t\t\t\t\treturn iptr->data_ = arg.data_ & 0x8000, arg;\n\t\t\t\te >>= 10;\n\t\t\t\tunsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;\n\t\t\t\tiptr->data_ = arg.data_ & ~mask;\n\t\t\t\tif(!m)\n\t\t\t\t\treturn half(binary, arg.data_&0x8000);\n\t\t\t\tfor(; m<0x400; m<<=1,--e) ;\n\t\t\t\treturn half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));\n\t\t\t}\n\n\t\t\t/// Scaling implementation.\n\t\t\t/// \\param arg number to scale\n\t\t\t/// \\param exp power of two to scale by\n\t\t\t/// \\return scaled number\n\t\t\tstatic half scalbln(half arg, long exp)\n\t\t\t{\n\t\t\t\tlong e = arg.data_ & 0x7C00;\n\t\t\t\tif(e == 0x7C00)\n\t\t\t\t\treturn arg;\n\t\t\t\tunsigned int m = arg.data_ & 0x3FF;\n\t\t\t\tif(e >>= 10)\n\t\t\t\t\tm |= 0x400;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(!m)\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\tfor(m<<=1; m<0x400; m<<=1,--e) ;\n\t\t\t\t}\n\t\t\t\te += exp;\n\t\t\t\tuint16 value = arg.data_ & 0x8000;\n\t\t\t\tif(e > 30)\n\t\t\t\t{\n\t\t\t\t\tif(half::round_style == std::round_toward_zero)\n\t\t\t\t\t\tvalue |= 0x7BFF;\n\t\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\t\tvalue |= 0x7C00 - (value>>15);\n\t\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\t\tvalue |= 0x7BFF + (value>>15);\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue |= 0x7C00;\n\t\t\t\t}\n\t\t\t\telse if(e > 0)\n\t\t\t\t\tvalue |= (e<<10) | (m&0x3FF);\n\t\t\t\telse if(e > -11)\n\t\t\t\t{\n\t\t\t\t\tif(half::round_style == std::round_to_nearest)\n\t\t\t\t\t{\n\t\t\t\t\t\tm += 1 << -e;\n\t\t\t\t\t#if HALF_ROUND_TIES_TO_EVEN\n\t\t\t\t\t\tm -= (m>>(1-e)) & 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\t\tm += ((value>>15)-1) & ((1<<(1-e))-1U);\n\t\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\t\tm += -(value>>15) & ((1<<(1-e))-1U);\n\t\t\t\t\tvalue |= m >> (1-e);\n\t\t\t\t}\n\t\t\t\telse if(half::round_style == std::round_toward_infinity)\n\t\t\t\t\tvalue |= ((value>>15)-1) & 1;\n\t\t\t\telse if(half::round_style == std::round_toward_neg_infinity)\n\t\t\t\t\tvalue |= value >> 15;\n\t\t\t\treturn half(binary, value);\n\t\t\t}\n\n\t\t\t/// Exponent implementation.\n\t\t\t/// \\param arg number to query\n\t\t\t/// \\return floating point exponent\n\t\t\tstatic int ilogb(half arg)\n\t\t\t{\n\t\t\t\tint exp = arg.data_ & 0x7FFF;\n\t\t\t\tif(!exp)\n\t\t\t\t\treturn FP_ILOGB0;\n\t\t\t\tif(exp < 0x7C00)\n\t\t\t\t{\n\t\t\t\t\tif(!(exp>>=10))\n\t\t\t\t\t\tfor(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;\n\t\t\t\t\treturn exp - 15;\n\t\t\t\t}\n\t\t\t\tif(exp > 0x7C00)\n\t\t\t\t\treturn FP_ILOGBNAN;\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\n\t\t\t/// \\param from number to increase/decrease\n\t\t\t/// \\param to direction to enumerate into\n\t\t\t/// \\return next representable number\n\t\t\tstatic half nextafter(half from, half to)\n\t\t\t{\n\t\t\t\tuint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;\n\t\t\t\tif(fabs > 0x7C00)\n\t\t\t\t\treturn from;\n\t\t\t\tif(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))\n\t\t\t\t\treturn to;\n\t\t\t\tif(!fabs)\n\t\t\t\t\treturn half(binary, (to.data_&0x8000)+1);\n\t\t\t\tbool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) < \n\t\t\t\t\t(signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));\n\t\t\t\treturn half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);\n\t\t\t}\n\n\t\t\t/// Enumeration implementation.\n\t\t\t/// \\param from number to increase/decrease\n\t\t\t/// \\param to direction to enumerate into\n\t\t\t/// \\return next representable number\n\t\t\tstatic half nexttoward(half from, long double to)\n\t\t\t{\n\t\t\t\tif(isnan(from))\n\t\t\t\t\treturn from;\n\t\t\t\tlong double lfrom = static_cast<long double>(from);\n\t\t\t\tif(builtin_isnan(to) || lfrom == to)\n\t\t\t\t\treturn half(static_cast<float>(to));\n\t\t\t\tif(!(from.data_&0x7FFF))\n\t\t\t\t\treturn half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);\n\t\t\t\treturn half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);\n\t\t\t}\n\n\t\t\t/// Sign implementation\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return composed value\n\t\t\tstatic half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if infinite number\n\t\t\t/// \\retval false else\n\t\t\tstatic int fpclassify(half arg)\n\t\t\t{\n\t\t\t\tunsigned int abs = arg.data_ & 0x7FFF;\n\t\t\t\tif(abs > 0x7C00)\n\t\t\t\t\treturn FP_NAN;\n\t\t\t\tif(abs == 0x7C00)\n\t\t\t\t\treturn FP_INFINITE;\n\t\t\t\tif(abs > 0x3FF)\n\t\t\t\t\treturn FP_NORMAL;\n\t\t\t\treturn abs ? FP_SUBNORMAL : FP_ZERO;\n\t\t\t}\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if finite number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if infinite number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if not a number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }\n\n\t\t\t/// Classification implementation.\n\t\t\t/// \\param arg value to classify\n\t\t\t/// \\retval true if normal number\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }\n\n\t\t\t/// Sign bit implementation.\n\t\t\t/// \\param arg value to check\n\t\t\t/// \\retval true if signed\n\t\t\t/// \\retval false if unsigned\n\t\t\tstatic bool signbit(half arg) { return (arg.data_&0x8000) != 0; }\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operands equal\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isequal(half x, half y) { return (x.data_==y.data_ || !((x.data_|y.data_)&0x7FFF)) && !isnan(x); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }\n\t\t\tstatic bool isequal(float x, half y) { return HLS_FPO_EQUALF(x,y); }\n\t\t\tstatic bool isequal(half x, float y) { return HLS_FPO_EQUALF(x,y); }\n\t\t\tstatic bool isequal(double x, half y) { return HLS_FPO_EQUAL(x,y); }\n\t\t\tstatic bool isequal(half x, double y) { return HLS_FPO_EQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operands not equal\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isnotequal(half x, half y) { return (x.data_!=y.data_ && ((x.data_|y.data_)&0x7FFF)) || isnan(x); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }\n\t\t\tstatic bool isnotequal(float x, half y) { return HLS_FPO_NOTEQUALF(x,y); }\n\t\t\tstatic bool isnotequal(half x, float y) { return HLS_FPO_NOTEQUALF(x,y); }\n\t\t\tstatic bool isnotequal(double x, half y) { return HLS_FPO_NOTEQUAL(x,y); }\n\t\t\tstatic bool isnotequal(half x, double y) { return HLS_FPO_NOTEQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x > \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isgreater(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) > (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }\n\t\t\tstatic bool isgreater(float x, half y) { return HLS_FPO_GREATERF(x,y); }\n\t\t\tstatic bool isgreater(half x, float y) { return HLS_FPO_GREATERF(x,y); }\n\t\t\tstatic bool isgreater(double x, half y) { return HLS_FPO_GREATER(x,y); }\n\t\t\tstatic bool isgreater(half x, double y) { return HLS_FPO_GREATER(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x >= \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isgreaterequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) >= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }\n\t\t\tstatic bool isgreaterequal(float x, half y) { return HLS_FPO_GREATEREQUALF(x,y); }\n\t\t\tstatic bool isgreaterequal(half x, float y) { return HLS_FPO_GREATEREQUALF(x,y); }\n\t\t\tstatic bool isgreaterequal(double x, half y) { return HLS_FPO_GREATEREQUAL(x,y); }\n\t\t\tstatic bool isgreaterequal(half x, double y) { return HLS_FPO_GREATEREQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x < \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool isless(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) < (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }\n\t\t\tstatic bool isless(float x, half y) { return HLS_FPO_LESSF(x,y); }\n\t\t\tstatic bool isless(half x, float y) { return HLS_FPO_LESSF(x,y); }\n\t\t\tstatic bool isless(double x, half y) { return HLS_FPO_LESS(x,y); }\n\t\t\tstatic bool isless(half x, double y) { return HLS_FPO_LESS(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if \\a x <= \\a y\n\t\t\t/// \\retval false else\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\t\tstatic bool islessequal(half x, half y) { return !isnan(x) && !isnan(y) && ((signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : \n\t\t\t\tstatic_cast<int17>(x.data_)) <= (signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))); }\n#else\n            template<typename T1, typename T2>\n\t\t\tstatic bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }\n\t\t\tstatic bool islessequal(float x, half y) { return HLS_FPO_LESSEQUALF(x,y); }\n\t\t\tstatic bool islessequal(half x, float y) { return HLS_FPO_LESSEQUALF(x,y); }\n\t\t\tstatic bool islessequal(double x, half y) { return HLS_FPO_LESSEQUAL(x,y); }\n\t\t\tstatic bool islessequal(half x, double y) { return HLS_FPO_LESSEQUAL(x,y); }\n#endif\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true neither \\a x > \\a y nor \\a x < \\a y\n\t\t\t/// \\retval false else\n\t\t\tstatic bool islessgreater(half x, half y)\n\t\t\t{\n\t\t\t\tif(isnan(x) || isnan(y))\n\t\t\t\t\treturn false;\n\t\t\t\t//int17 a = signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_);\n\t\t\t\t//int17 b = signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_);\n\t\t\t\t//return a < b || a > b;\n                return isless(x, y) || isgreater(x, y);\n\t\t\t}\n\n\t\t\t/// Comparison implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\retval true if operand unordered\n\t\t\t/// \\retval false else\n\t\t\tstatic bool isunordered(half x, half y) { return isnan(x) || isnan(y); }\n\n\t\tprivate:\n\t\t\tstatic double erf(double arg)\n\t\t\t{\n\t\t\t\tif(builtin_isinf(arg))\n\t\t\t\t\treturn (arg<0.0) ? -1.0 : 1.0;\n\t\t\t\tdouble x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;\n\t\t\t\tdouble value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));\n\t\t\t\treturn builtin_signbit(arg) ? -value : value;\n\t\t\t}\n\n\t\t\tstatic double lgamma(double arg)\n\t\t\t{\n\t\t\t\tdouble v = 1.0;\n\t\t\t\tfor(; arg<8.0; ++arg) v *= arg;\n\t\t\t\tdouble w = 1.0 / (arg * arg);\n\t\t\t\treturn (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+\n\t\t\t\t\t-0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+\n\t\t\t\t\t-5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+\n\t\t\t\t\t-0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg + \n\t\t\t\t\t0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);\n\t\t\t}\n\t\t};\n\n\t\t/// Wrapper for unary half-precision functions needing specialization for individual argument types.\n\t\t/// \\tparam T argument type\n\t\ttemplate<typename T> struct unary_specialized\n\t\t{\n\t\t\t/// Negation implementation.\n\t\t\t/// \\param arg value to negate\n\t\t\t/// \\return negated value\n\t\t\tstatic HALF_CONSTEXPR half negate(half arg) { return half(binary, arg.data_^0x8000); }\n\n\t\t\t/// Absolute value implementation.\n\t\t\t/// \\param arg function argument\n\t\t\t/// \\return absolute value\n\t\t\tstatic half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }\n\t\t};\n\t\ttemplate<> struct unary_specialized<expr>\n\t\t{\n\t\t\tstatic HALF_CONSTEXPR expr negate(float arg) { return expr(-arg); }\n\t\t\tstatic expr fabs(float arg) { return expr(std::fabs(arg)); }\n\t\t};\n\n\t\t/// Wrapper for binary half-precision functions needing specialization for individual argument types.\n\t\t/// \\tparam T first argument type\n\t\t/// \\tparam U first argument type\n\t\ttemplate<typename T,typename U> struct binary_specialized\n\t\t{\n\t\t\t/// Minimum implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return minimum value\n\t\t\tstatic expr fmin(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fmin(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x))\n\t\t\t\t\treturn expr(y);\n\t\t\t\tif(builtin_isnan(y))\n\t\t\t\t\treturn expr(x);\n\t\t\t\treturn expr(std::min(x, y));\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t/// Maximum implementation.\n\t\t\t/// \\param x first operand\n\t\t\t/// \\param y second operand\n\t\t\t/// \\return maximum value\n\t\t\tstatic expr fmax(float x, float y)\n\t\t\t{\n\t\t\t#if HALF_ENABLE_CPP11_CMATH\n\t\t\t\treturn expr(std::fmax(x, y));\n\t\t\t#else\n\t\t\t\tif(builtin_isnan(x))\n\t\t\t\t\treturn expr(y);\n\t\t\t\tif(builtin_isnan(y))\n\t\t\t\t\treturn expr(x);\n\t\t\t\treturn expr(std::max(x, y));\n\t\t\t#endif\n\t\t\t}\n\t\t};\n\t\ttemplate<> struct binary_specialized<half,half>\n\t\t{\n\t\t\tstatic half fmin(half x, half y)\n\t\t\t{\n\t\t\t\tif(functions::isnan(x))\n\t\t\t\t\treturn y;\n\t\t\t\tif(functions::isnan(y))\n\t\t\t\t\treturn x;\n\t\t\t\treturn ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >\n\t\t\t\t\t\t(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n\t\t\t}\n\t\t\tstatic half fmax(half x, half y)\n\t\t\t{\n\t\t\t\tif(functions::isnan(x))\n\t\t\t\t\treturn y;\n\t\t\t\tif(functions::isnan(y))\n\t\t\t\t\treturn x;\n\t\t\t\treturn ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <\n\t\t\t\t\t\t(functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;\n\t\t\t}\n\t\t};\n\n\t\t/// Helper class for half casts.\n\t\t/// This class template has to be specialized for all valid cast argument to define an appropriate static `cast` member \n\t\t/// function and a corresponding `type` member denoting its return type.\n\t\t/// \\tparam T destination type\n\t\t/// \\tparam U source type\n\t\t/// \\tparam R rounding mode to use\n\t\ttemplate<typename T,typename U,std::float_round_style R=(std::float_round_style)(HALF_ROUND_STYLE)> struct half_caster {};\n\t\ttemplate<typename U,std::float_round_style R> struct half_caster<half,U,R>\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\tstatic_assert(std::is_arithmetic<U>::value, \"half_cast from non-arithmetic type unsupported\");\n\t\t#endif\n\n\t\t\ttypedef half type;\n\t\t\tstatic half cast(U arg) { return cast_impl(arg, is_float<U>()); };\n\n\t\tprivate:\n\t\t\tstatic half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }\n\t\t\tstatic half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }\n\t\t};\n\t\ttemplate<typename T,std::float_round_style R> struct half_caster<T,half,R>\n\t\t{\n\t\t#if HALF_ENABLE_CPP11_STATIC_ASSERT && HALF_ENABLE_CPP11_TYPE_TRAITS\n\t\t\tstatic_assert(std::is_arithmetic<T>::value, \"half_cast to non-arithmetic type unsupported\");\n\t\t#endif\n\n\t\t\ttypedef T type;\n\t\t\ttemplate<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }\n\n\t\tprivate:\n\t\t\tstatic T cast_impl(float arg, true_type) { return static_cast<T>(arg); }\n\t\t\tstatic T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }\n\t\t};\n\t\ttemplate<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};\n\t\ttemplate<std::float_round_style R> struct half_caster<half,half,R>\n\t\t{\n\t\t\ttypedef half type;\n\t\t\tstatic half cast(half arg) { return arg; }\n\t\t};\n\t\ttemplate<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};\n\n\t\t/// \\name Comparison operators\n\t\t/// \\{\n\n        /// the behavior of comparison operators' simulation model is same with STD/following implmentation\n        /// so no need to call FPO model\n\n\t\t/// Comparison for equality.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if operands equal\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }\n\n\t\t/// Comparison for inequality.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if operands not equal\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }\n\n\t\t/// Comparison for less than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less than \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }\n\n\t\t/// Comparison for greater than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater than \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }\n\n\t\t/// Comparison for less equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less equal \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }\n\n\t\t/// Comparison for greater equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater equal \\a y\n\t\t/// \\retval false else\n\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Arithmetic operators\n\t\t/// \\{\n\n\t\t/// Add halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return sum of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }\n#endif\n\n\t\t/// Subtract halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return difference of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }\n#endif\n\n\t\t/// Multiply halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return product of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }\n#endif\n\n\t\t/// Divide halfs.\n\t\t/// \\param x left operand\n\t\t/// \\param y right operand\n\t\t/// \\return quotient of half expressions\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }\n#else\n\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }\n#endif\n\n\t\t/// Identity.\n\t\t/// \\param arg operand\n\t\t/// \\return uncahnged operand\n\t\ttemplate<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator+(T arg) { return arg; }\n\n\t\t/// Negation.\n\t\t/// \\param arg operand\n\t\t/// \\return negated operand\n\t\ttemplate<typename T> HALF_CONSTEXPR typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Input and output\n\t\t/// \\{\n\n\t\t/// Output operator.\n\t\t/// \\param out output stream to write into\n\t\t/// \\param arg half expression to write\n\t\t/// \\return reference to output stream\n\t\ttemplate<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type\n\t\t\toperator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }\n\n\t\t/// Input operator.\n\t\t/// \\param in input stream to read from\n\t\t/// \\param arg half to read into\n\t\t/// \\return reference to input stream\n\t\ttemplate<typename charT,typename traits> std::basic_istream<charT,traits>&\n\t\t\toperator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }\n\n\t\t/// \\}\n\t\t/// \\name Basic mathematical operations\n\t\t/// \\{\n\n\t\t/// Absolute value.\n\t\t/// \\param arg operand\n\t\t/// \\return absolute value of \\a arg\n//\t\ttemplate<typename T> typename enable<T,T>::type abs(T arg) { return unary_specialized<T>::fabs(arg); }\n\t\tinline half abs(half arg) { return unary_specialized<half>::fabs(arg); }\n\t\tinline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n\t\t/// Absolute value.\n\t\t/// \\param arg operand\n\t\t/// \\return absolute value of \\a arg\n//\t\ttemplate<typename T> typename enable<T,T>::type fabs(T arg) { return unary_specialized<T>::fabs(arg); }\n\t\tinline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }\n\t\tinline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type fmod(T x, U y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(half x, half y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(half x, expr y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(expr x, half y) { return functions::fmod(x, y); }\n\t\tinline expr fmod(expr x, expr y) { return functions::fmod(x, y); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type remainder(T x, U y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(half x, half y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(half x, expr y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(expr x, half y) { return functions::remainder(x, y); }\n\t\tinline expr remainder(expr x, expr y) { return functions::remainder(x, y); }\n\n\t\t/// Remainder of division.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\param quo address to store some bits of quotient at\n\t\t/// \\return remainder of floating point division.\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type remquo(T x, U y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }\n\t\tinline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }\n\n\t\t/// Fused multiply add.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\param z third operand\n\t\t/// \\return ( \\a x * \\a y ) + \\a z rounded as one operation.\n//\t\ttemplate<typename T,typename U,typename V> typename enable<expr,T,U,V>::type fma(T x, U y, V z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }\n\t\tinline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }\n\n                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }\n                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }\n\n\t\t/// Maximum of half expressions.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return maximum of operands\n//\t\ttemplate<typename T,typename U> typename result<T,U>::type fmax(T x, U y) { return binary_specialized<T,U>::fmax(x, y); }\n\t\tinline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }\n\t\tinline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }\n\t\tinline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }\n\t\tinline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }\n\n\t\t/// Minimum of half expressions.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return minimum of operands\n//\t\ttemplate<typename T,typename U> typename result<T,U>::type fmin(T x, U y) { return binary_specialized<T,U>::fmin(x, y); }\n\t\tinline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }\n\t\tinline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }\n\t\tinline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }\n\t\tinline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }\n\n\t\t/// Positive difference.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\return \\a x - \\a y or 0 if difference negative\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type fdim(T x, U y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(half x, half y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(half x, expr y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(expr x, half y) { return functions::fdim(x, y); }\n\t\tinline expr fdim(expr x, expr y) { return functions::fdim(x, y); }\n\n                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }\n                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }\n                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }\n                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }\n\n                inline expr minmag(half x, half y) { return functions::minmag(x, y); }\n                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }\n                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }\n                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }\n\n\t\t/// Get NaN value.\n\t\t/// \\param arg descriptive string (ignored)\n\t\t/// \\return quiet NaN\n\t\tinline half nanh(const char *arg) { return functions::nanh(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Exponential functions\n\t\t/// \\{\n\n\t\t/// Exponential function.\n\t\t/// \\param arg function argument\n\t\t/// \\return e raised to \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type exp(T arg) { return functions::exp(arg); }\n\t\tinline expr exp(half arg) { return functions::exp(arg); }\n\t\tinline expr exp(expr arg) { return functions::exp(arg); }\n\n\t\t/// Exponential minus one.\n\t\t/// \\param arg function argument\n\t\t/// \\return e raised to \\a arg subtracted by 1\n//\t\ttemplate<typename T> typename enable<expr,T>::type expm1(T arg) { return functions::expm1(arg); }\n\t\tinline expr expm1(half arg) { return functions::expm1(arg); }\n\t\tinline expr expm1(expr arg) { return functions::expm1(arg); }\n\n\t\t/// Binary exponential.\n\t\t/// \\param arg function argument\n\t\t/// \\return 2 raised to \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type exp2(T arg) { return functions::exp2(arg); }\n\t\tinline expr exp2(half arg) { return functions::exp2(arg); }\n\t\tinline expr exp2(expr arg) { return functions::exp2(arg); }\n\n\t\t/// Natural logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base e\n//\t\ttemplate<typename T> typename enable<expr,T>::type log(T arg) { return functions::log(arg); }\n\t\tinline expr log(half arg) { return functions::log(arg); }\n\t\tinline expr log(expr arg) { return functions::log(arg); }\n\n\t\t/// Common logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base 10\n//\t\ttemplate<typename T> typename enable<expr,T>::type log10(T arg) { return functions::log10(arg); }\n\t\tinline expr log10(half arg) { return functions::log10(arg); }\n\t\tinline expr log10(expr arg) { return functions::log10(arg); }\n\n\t\t/// Natural logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg plus 1 to base e\n//\t\ttemplate<typename T> typename enable<expr,T>::type log1p(T arg) { return functions::log1p(arg); }\n\t\tinline expr log1p(half arg) { return functions::log1p(arg); }\n\t\tinline expr log1p(expr arg) { return functions::log1p(arg); }\n\n\t\t/// Binary logorithm.\n\t\t/// \\param arg function argument\n\t\t/// \\return logarithm of \\a arg to base 2\n//\t\ttemplate<typename T> typename enable<expr,T>::type log2(T arg) { return functions::log2(arg); }\n\t\tinline expr log2(half arg) { return functions::log2(arg); }\n\t\tinline expr log2(expr arg) { return functions::log2(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Power functions\n\t\t/// \\{\n\n\t\t/// Square root.\n\t\t/// \\param arg function argument\n\t\t/// \\return square root of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sqrt(T arg) { return functions::sqrt(arg); }\n#ifdef HLS_NO_XIL_FPO_LIB\n\t\tinline expr sqrt(half arg) { return functions::sqrt(arg); }\n#else\n\t\tinline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }\n#endif\n\t\tinline expr sqrt(expr arg) { return functions::sqrt(arg); }\n\n\t\t/// Cubic root.\n\t\t/// \\param arg function argument\n\t\t/// \\return cubic root of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cbrt(T arg) { return functions::cbrt(arg); }\n\t\tinline expr cbrt(half arg) { return functions::cbrt(arg); }\n\t\tinline expr cbrt(expr arg) { return functions::cbrt(arg); }\n\n\t\t/// Hypotenuse function.\n\t\t/// \\param x first argument\n\t\t/// \\param y second argument\n\t\t/// \\return square root of sum of squares without internal over- or underflows\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type hypot(T x, U y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(half x, half y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(half x, expr y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(expr x, half y) { return functions::hypot(x, y); }\n\t\tinline expr hypot(expr x, expr y) { return functions::hypot(x, y); }\n\n\t\t/// Power function.\n\t\t/// \\param base first argument\n\t\t/// \\param exp second argument\n\t\t/// \\return \\a base raised to \\a exp\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type pow(T base, U exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(half base, half exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(half base, expr exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(expr base, half exp) { return functions::pow(base, exp); }\n\t\tinline expr pow(expr base, expr exp) { return functions::pow(base, exp); }\n                inline expr powr(half base, half exp) { return functions::powr(base, exp); }\n                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }\n                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }\n                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }\n                inline expr pown(half base, int exp) { return functions::pown(base, exp); }\n                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }\n\n\t\t/// \\}\n\t\t/// \\name Trigonometric functions\n\t\t/// \\{\n\n\t\t/// Sine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sin(T arg) { return functions::sin(arg); }\n\t\tinline expr sin(half arg) { return functions::sin(arg); }\n\t\tinline expr sin(expr arg) { return functions::sin(arg); }\n\n\t\t/// Cosine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cos(T arg) { return functions::cos(arg); }\n\t\tinline expr cos(half arg) { return functions::cos(arg); }\n\t\tinline expr cos(expr arg) { return functions::cos(arg); }\n\n\t\t/// Tangent function.\n\t\t/// \\param arg function argument\n\t\t/// \\return tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tan(T arg) { return functions::tan(arg); }\n\t\tinline expr tan(half arg) { return functions::tan(arg); }\n\t\tinline expr tan(expr arg) { return functions::tan(arg); }\n\n\t\t/// Arc sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type asin(T arg) { return functions::asin(arg); }\n\t\tinline expr asin(half arg) { return functions::asin(arg); }\n\t\tinline expr asin(expr arg) { return functions::asin(arg); }\n\n\t\t/// Arc cosine function.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type acos(T arg) { return functions::acos(arg); }\n\t\tinline expr acos(half arg) { return functions::acos(arg); }\n\t\tinline expr acos(expr arg) { return functions::acos(arg); }\n\n\t\t/// Arc tangent function.\n\t\t/// \\param arg function argument\n\t\t/// \\return arc tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type atan(T arg) { return functions::atan(arg); }\n\t\tinline expr atan(half arg) { return functions::atan(arg); }\n\t\tinline expr atan(expr arg) { return functions::atan(arg); }\n\n\t\t/// Arc tangent function.\n\t\t/// \\param x first argument\n\t\t/// \\param y second argument\n\t\t/// \\return arc tangent value\n//\t\ttemplate<typename T,typename U> typename enable<expr,T,U>::type atan2(T x, U y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(half x, half y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(half x, expr y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(expr x, half y) { return functions::atan2(x, y); }\n\t\tinline expr atan2(expr x, expr y) { return functions::atan2(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Hyperbolic functions\n\t\t/// \\{\n\n\t\t/// Hyperbolic sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type sinh(T arg) { return functions::sinh(arg); }\n\t\tinline expr sinh(half arg) { return functions::sinh(arg); }\n\t\tinline expr sinh(expr arg) { return functions::sinh(arg); }\n\n\t\t/// Hyperbolic cosine.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type cosh(T arg) { return functions::cosh(arg); }\n\t\tinline expr cosh(half arg) { return functions::cosh(arg); }\n\t\tinline expr cosh(expr arg) { return functions::cosh(arg); }\n\n\t\t/// Hyperbolic tangent.\n\t\t/// \\param arg function argument\n\t\t/// \\return hyperbolic tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tanh(T arg) { return functions::tanh(arg); }\n\t\tinline expr tanh(half arg) { return functions::tanh(arg); }\n\t\tinline expr tanh(expr arg) { return functions::tanh(arg); }\n\n\t\t/// Hyperbolic area sine.\n\t\t/// \\param arg function argument\n\t\t/// \\return area sine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type asinh(T arg) { return functions::asinh(arg); }\n\t\tinline expr asinh(half arg) { return functions::asinh(arg); }\n\t\tinline expr asinh(expr arg) { return functions::asinh(arg); }\n\n\t\t/// Hyperbolic area cosine.\n\t\t/// \\param arg function argument\n\t\t/// \\return area cosine value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type acosh(T arg) { return functions::acosh(arg); }\n\t\tinline expr acosh(half arg) { return functions::acosh(arg); }\n\t\tinline expr acosh(expr arg) { return functions::acosh(arg); }\n\n\t\t/// Hyperbolic area tangent.\n\t\t/// \\param arg function argument\n\t\t/// \\return area tangent value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type atanh(T arg) { return functions::atanh(arg); }\n\t\tinline expr atanh(half arg) { return functions::atanh(arg); }\n\t\tinline expr atanh(expr arg) { return functions::atanh(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Error and gamma functions\n\t\t/// \\{\n\n\t\t/// Error function.\n\t\t/// \\param arg function argument\n\t\t/// \\return error function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type erf(T arg) { return functions::erf(arg); }\n\t\tinline expr erf(half arg) { return functions::erf(arg); }\n\t\tinline expr erf(expr arg) { return functions::erf(arg); }\n\n\t\t/// Complementary error function.\n\t\t/// \\param arg function argument\n\t\t/// \\return 1 minus error function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type erfc(T arg) { return functions::erfc(arg); }\n\t\tinline expr erfc(half arg) { return functions::erfc(arg); }\n\t\tinline expr erfc(expr arg) { return functions::erfc(arg); }\n\n\t\t/// Natural logarithm of gamma function.\n\t\t/// \\param arg function argument\n\t\t/// \\return natural logarith of gamma function for \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type lgamma(T arg) { return functions::lgamma(arg); }\n                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }\n                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }\n\t\tinline expr lgamma(half arg) { return functions::lgamma(arg); }\n\t\tinline expr lgamma(expr arg) { return functions::lgamma(arg); }\n\n\t\t/// Gamma function.\n\t\t/// \\param arg function argument\n\t\t/// \\return gamma function value of \\a arg\n//\t\ttemplate<typename T> typename enable<expr,T>::type tgamma(T arg) { return functions::tgamma(arg); }\n\t\tinline expr tgamma(half arg) { return functions::tgamma(arg); }\n\t\tinline expr tgamma(expr arg) { return functions::tgamma(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Rounding\n\t\t/// \\{\n\n\t\t/// Nearest integer not less than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not less than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type ceil(T arg) { return functions::ceil(arg); }\n\t\tinline half ceil(half arg) { return functions::ceil(arg); }\n\t\tinline half ceil(expr arg) { return functions::ceil(arg); }\n\n\t\t/// Nearest integer not greater than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not greater than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type floor(T arg) { return functions::floor(arg); }\n\t\tinline half floor(half arg) { return functions::floor(arg); }\n\t\tinline half floor(expr arg) { return functions::floor(arg); }\n\n\t\t/// Nearest integer not greater in magnitude than half value.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer not greater in magnitude than \\a arg\n//\t\ttemplate<typename T> typename enable<half,T>::type trunc(T arg) { return functions::trunc(arg); }\n\t\tinline half trunc(half arg) { return functions::trunc(arg); }\n\t\tinline half trunc(expr arg) { return functions::trunc(arg); }\n\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<half,T>::type round(T arg) { return functions::round(arg); }\n\t\tinline half round(half arg) { return functions::round(arg); }\n\t\tinline half round(expr arg) { return functions::round(arg); }\n\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<long,T>::type lround(T arg) { return functions::lround(arg); }\n\t\tinline long lround(half arg) { return functions::lround(arg); }\n\t\tinline long lround(expr arg) { return functions::lround(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<half,T>::type nearbyint(T arg) { return functions::nearbyint(arg); }\n\t\tinline half nearbyint(half arg) { return functions::rint(arg); }\n\t\tinline half nearbyint(expr arg) { return functions::rint(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<half,T>::type rint(T arg) { return functions::rint(arg); }\n\t\tinline half rint(half arg) { return functions::rint(arg); }\n\t\tinline half rint(expr arg) { return functions::rint(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<long,T>::type lrint(T arg) { return functions::lrint(arg); }\n\t\tinline long lrint(half arg) { return functions::lrint(arg); }\n\t\tinline long lrint(expr arg) { return functions::lrint(arg); }\n\t#if HALF_ENABLE_CPP11_LONG_LONG\n\t\t/// Nearest integer.\n\t\t/// \\param arg half to round\n\t\t/// \\return nearest integer, rounded away from zero in half-way cases\n//\t\ttemplate<typename T> typename enable<long long,T>::type llround(T arg) { return functions::llround(arg); }\n\t\tinline long long llround(half arg) { return functions::llround(arg); }\n\t\tinline long long llround(expr arg) { return functions::llround(arg); }\n\n\t\t/// Nearest integer using half's internal rounding mode.\n\t\t/// \\param arg half expression to round\n\t\t/// \\return nearest integer using default rounding mode\n//\t\ttemplate<typename T> typename enable<long long,T>::type llrint(T arg) { return functions::llrint(arg); }\n\t\tinline long long llrint(half arg) { return functions::llrint(arg); }\n\t\tinline long long llrint(expr arg) { return functions::llrint(arg); }\n\t#endif\n\n\t\t/// \\}\n\t\t/// \\name Floating point manipulation\n\t\t/// \\{\n\n\t\t/// Decompress floating point number.\n\t\t/// \\param arg number to decompress\n\t\t/// \\param exp address to store exponent at\n\t\t/// \\return significant in range [0.5, 1)\n//\t\ttemplate<typename T> typename enable<half,T>::type frexp(T arg, int *exp) { return functions::frexp(arg, exp); }\n\t\tinline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }\n\t\tinline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\n//\t\ttemplate<typename T> typename enable<half,T>::type ldexp(T arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Extract integer and fractional parts.\n\t\t/// \\param arg number to decompress\n\t\t/// \\param iptr address to store integer part at\n\t\t/// \\return fractional part\n//\t\ttemplate<typename T> typename enable<half,T>::type modf(T arg, half *iptr) { return functions::modf(arg, iptr); }\n\t\tinline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }\n\t\tinline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\n//\t\ttemplate<typename T> typename enable<half,T>::type scalbn(T arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Multiply by power of two.\n\t\t/// \\param arg number to modify\n\t\t/// \\param exp power of two to multiply with\n\t\t/// \\return \\a arg multplied by 2 raised to \\a exp\t\n//\t\ttemplate<typename T> typename enable<half,T>::type scalbln(T arg, long exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }\n\t\tinline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }\n\n\t\t/// Extract exponent.\n\t\t/// \\param arg number to query\n\t\t/// \\return floating point exponent\n\t\t/// \\retval FP_ILOGB0 for zero\n\t\t/// \\retval FP_ILOGBNAN for NaN\n\t\t/// \\retval MAX_INT for infinity\n//\t\ttemplate<typename T> typename enable<int,T>::type ilogb(T arg) { return functions::ilogb(arg); }\n\t\tinline int ilogb(half arg) { return functions::ilogb(arg); }\n\t\tinline int ilogb(expr arg) { return functions::ilogb(arg); }\n\n\t\t/// Extract exponent.\n\t\t/// \\param arg number to query\n\t\t/// \\return floating point exponent\n//\t\ttemplate<typename T> typename enable<half,T>::type logb(T arg) { return functions::logb(arg); }\n\t\tinline half logb(half arg) { return functions::logb(arg); }\n\t\tinline half logb(expr arg) { return functions::logb(arg); }\n\n\t\t/// Next representable value.\n\t\t/// \\param from value to compute next representable value for\n\t\t/// \\param to direction towards which to compute next value\n\t\t/// \\return next representable value after \\a from in direction towards \\a to\n//\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type nextafter(T from, U to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(half from, half to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(half from, expr to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(expr from, half to) { return functions::nextafter(from, to); }\n\t\tinline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }\n\n\t\t/// Next representable value.\n\t\t/// \\param from value to compute next representable value for\n\t\t/// \\param to direction towards which to compute next value\n\t\t/// \\return next representable value after \\a from in direction towards \\a to\n//\t\ttemplate<typename T> typename enable<half,T>::type nexttoward(T from, long double to) { return functions::nexttoward(from, to); }\n\t\tinline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }\n\t\tinline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }\n\n\t\t/// Take sign.\n\t\t/// \\param x value to change sign for\n\t\t/// \\param y value to take sign from\n\t\t/// \\return value equal to \\a x in magnitude and to \\a y in sign\n//\t\ttemplate<typename T,typename U> typename enable<half,T,U>::type copysign(T x, U y) { return functions::copysign(x, y); }\n\t\tinline half copysign(half x, half y) { return functions::copysign(x, y); }\n\t\tinline half copysign(half x, expr y) { return functions::copysign(x, y); }\n\t\tinline half copysign(expr x, half y) { return functions::copysign(x, y); }\n\t\tinline half copysign(expr x, expr y) { return functions::copysign(x, y); }\n\n\t\t/// \\}\n\t\t/// \\name Floating point classification\n\t\t/// \\{\n\n\n\t\t/// Classify floating point value.\n\t\t/// \\param arg number to classify\n\t\t/// \\retval FP_ZERO for positive and negative zero\n\t\t/// \\retval FP_SUBNORMAL for subnormal numbers\n\t\t/// \\retval FP_INFINITY for positive and negative infinity\n\t\t/// \\retval FP_NAN for NaNs\n\t\t/// \\retval FP_NORMAL for all other (normal) values\n//\t\ttemplate<typename T> typename enable<int,T>::type fpclassify(T arg) { return functions::fpclassify(arg); }\n\t\tinline int fpclassify(half arg) { return functions::fpclassify(arg); }\n\t\tinline int fpclassify(expr arg) { return functions::fpclassify(arg); }\n\n\t\t/// Check if finite number.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true if neither infinity nor NaN\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isfinite(T arg) { return functions::isfinite(arg); }\n\t\tinline bool isfinite(half arg) { return functions::isfinite(arg); }\n\t\tinline bool isfinite(expr arg) { return functions::isfinite(arg); }\n\n\t\t/// Check for infinity.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for positive or negative infinity\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isinf(T arg) { return functions::isinf(arg); }\n\t\tinline bool isinf(half arg) { return functions::isinf(arg); }\n\t\tinline bool isinf(expr arg) { return functions::isinf(arg); }\n\n\t\t/// Check for NaN.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for NaNs\n\t\t/// \\retval false else\n//\t\ttemplate<typename T> typename enable<bool,T>::type isnan(T arg) { return functions::isnan(arg); }\n\t\tinline bool isnan(half arg) { return functions::isnan(arg); }\n\t\tinline bool isnan(expr arg) { return functions::isnan(arg); }\n\n\t\t/// Check if normal number.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true if normal number\n\t\t/// \\retval false if either subnormal, zero, infinity or NaN\n//\t\ttemplate<typename T> typename enable<bool,T>::type isnormal(T arg) { return functions::isnormal(arg); }\n\t\tinline bool isnormal(half arg) { return functions::isnormal(arg); }\n\t\tinline bool isnormal(expr arg) { return functions::isnormal(arg); }\n\n\t\t/// Check sign.\n\t\t/// \\param arg number to check\n\t\t/// \\retval true for negative number\n\t\t/// \\retval false for positive number\n//\t\ttemplate<typename T> typename enable<bool,T>::type signbit(T arg) { return functions::signbit(arg); }\n\t\tinline bool signbit(half arg) { return functions::signbit(arg); }\n\t\tinline bool signbit(expr arg) { return functions::signbit(arg); }\n\n\t\t/// \\}\n\t\t/// \\name Comparison\n\t\t/// \\{\n\n\t\t/// Comparison for greater than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater than \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isgreater(T x, U y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(half x, half y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }\n\t\tinline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }\n\n\t\t/// Comparison for greater equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x greater equal \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isgreaterequal(T x, U y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }\n\t\tinline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }\n\n\t\t/// Comparison for less than.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less than \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isless(T x, U y) { return functions::isless(x, y); }\n\t\tinline bool isless(half x, half y) { return functions::isless(x, y); }\n\t\tinline bool isless(half x, expr y) { return functions::isless(x, y); }\n\t\tinline bool isless(expr x, half y) { return functions::isless(x, y); }\n\t\tinline bool isless(expr x, expr y) { return functions::isless(x, y); }\n\n\t\t/// Comparison for less equal.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if \\a x less equal \\a y\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type islessequal(T x, U y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(half x, half y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }\n\t\tinline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }\n\n\t\t/// Comarison for less or greater.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if either less or greater\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type islessgreater(T x, U y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }\n\t\tinline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }\n\n\t\t/// Check if unordered.\n\t\t/// \\param x first operand\n\t\t/// \\param y second operand\n\t\t/// \\retval true if unordered (one or two NaN operands)\n\t\t/// \\retval false else\n//\t\ttemplate<typename T,typename U> typename enable<bool,T,U>::type isunordered(T x, U y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(half x, half y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }\n\t\tinline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }\n\n\t\t/// \\name Casting\n\t\t/// \\{\n\n\t\t/// Cast to or from half-precision floating point number.\n\t\t/// This casts between [half](\\ref half) and any built-in arithmetic type. Floating point types are \n\t\t/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n\t\t/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n\t\t/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n\t\t/// that a `static_cast` would otherwise do. It uses the default rounding mode.\n\t\t///\n\t\t/// Using this cast with neither of the two types being a [half](\\ref half) or with any of the two types \n\t\t/// not being a built-in arithmetic type (apart from [half](\\ref half), of course) results in a compiler \n\t\t/// error and casting between [half](\\ref half)s is just a no-op.\n\t\t/// \\tparam T destination type (half or built-in arithmetic type)\n\t\t/// \\tparam U source type (half or built-in arithmetic type)\n\t\t/// \\param arg value to cast\n\t\t/// \\return \\a arg converted to destination type\n\t\ttemplate<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }\n\n\t\t/// Cast to or from half-precision floating point number.\n\t\t/// This casts between [half](\\ref half) and any built-in arithmetic type. Floating point types are \n\t\t/// converted via an explicit cast to/from `float` (using the rounding mode of the built-in single precision \n\t\t/// implementation) and thus any possible warnings due to an otherwise implicit conversion to/from `float` will be \n\t\t/// suppressed. Integer types are converted directly using the given rounding mode, without any roundtrip over `float` \n\t\t/// that a `static_cast` would otherwise do.\n\t\t///\n\t\t/// Using this cast with neither of the two types being a [half](\\ref half) or with any of the two types \n\t\t/// not being a built-in arithmetic type (apart from [half](\\ref half), of course) results in a compiler \n\t\t/// error and casting between [half](\\ref half)s is just a no-op.\n\t\t/// \\tparam T destination type (half or built-in arithmetic type)\n\t\t/// \\tparam R rounding mode to use.\n\t\t/// \\tparam U source type (half or built-in arithmetic type)\n\t\t/// \\param arg value to cast\n\t\t/// \\return \\a arg converted to destination type\n\t\ttemplate<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)\n\t\t\t{ return half_caster<T,U,R>::cast(arg); }\n\t\t/// \\}\n\t}\n\n\tusing detail::operator==;\n\tusing detail::operator!=;\n\tusing detail::operator<;\n\tusing detail::operator>;\n\tusing detail::operator<=;\n\tusing detail::operator>=;\n\tusing detail::operator+;\n\tusing detail::operator-;\n\tusing detail::operator*;\n\tusing detail::operator/;\n\tusing detail::operator<<;\n\tusing detail::operator>>;\n\n// \tusing detail::abs;\n// \tusing detail::fabs;\n// \tusing detail::fmod;\n// \tusing detail::remainder;\n// \tusing detail::remquo;\n// \tusing detail::fma;\n// \tusing detail::fmax;\n// \tusing detail::fmin;\n// \tusing detail::fdim;\n// \tusing detail::nanh;\n// \tusing detail::exp;\n// \tusing detail::expm1;\n// \tusing detail::exp2;\n// \tusing detail::log;\n// \tusing detail::log10;\n// \tusing detail::log1p;\n// \tusing detail::log2;\n// \tusing detail::sqrt;\n// \tusing detail::cbrt;\n// \tusing detail::hypot;\n// \t//using detail::pow;\n// \tusing detail::sin;\n// \tusing detail::cos;\n// \tusing detail::tan;\n// \tusing detail::asin;\n// \tusing detail::acos;\n// \tusing detail::atan;\n// \tusing detail::atan2;\n// \tusing detail::sinh;\n// \tusing detail::cosh;\n// \tusing detail::tanh;\n// \tusing detail::asinh;\n// \tusing detail::acosh;\n// \tusing detail::atanh;\n// \tusing detail::erf;\n// \tusing detail::erfc;\n// \tusing detail::lgamma;\n// \tusing detail::tgamma;\n// \tusing detail::ceil;\n// \tusing detail::floor;\n// \tusing detail::trunc;\n// \tusing detail::round;\n// \tusing detail::lround;\n// \tusing detail::nearbyint;\n// \tusing detail::rint;\n// \tusing detail::lrint;\n// #if HALF_ENABLE_CPP11_LONG_LONG\n// \tusing detail::llround;\n// \tusing detail::llrint;\n// #endif\n// \tusing detail::frexp;\n// \tusing detail::ldexp;\n// \tusing detail::modf;\n// \tusing detail::scalbn;\n// \tusing detail::scalbln;\n// \tusing detail::ilogb;\n// \tusing detail::logb;\n// \tusing detail::nextafter;\n// \tusing detail::nexttoward;\n// \tusing detail::copysign;\n \tusing detail::fpclassify;\n \tusing detail::isfinite;\n \tusing detail::isinf;\n \tusing detail::isnan;\n \tusing detail::isnormal;\n \tusing detail::signbit;\n \tusing detail::isgreater;\n \tusing detail::isgreaterequal;\n \tusing detail::isless;\n \tusing detail::islessequal;\n \tusing detail::islessgreater;\n \tusing detail::isunordered;\n\n\tusing detail::half_cast;\n\n/// Extensions to the C++ standard library.\nnamespace std\n{\n\t/// Numeric limits for half-precision floats.\n\t/// Because of the underlying single-precision implementation of many operations, it inherits some properties from \n\t/// `std::numeric_limits<float>`.\n\ttemplate<> struct numeric_limits<half> : public numeric_limits<float>\n\t{\n\tpublic:\n\t\t/// Supports signed values.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_signed = true;\n\n\t\t/// Is not exact.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_exact = false;\n\n\t\t/// Doesn't provide modulo arithmetic.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_modulo = false;\n\n\t\t/// IEEE conformant.\n\t\tstatic HALF_CONSTEXPR_CONST bool is_iec559 = true;\n\n\t\t/// Supports infinity.\n\t\tstatic HALF_CONSTEXPR_CONST bool has_infinity = true;\n\n\t\t/// Supports quiet NaNs.\n\t\tstatic HALF_CONSTEXPR_CONST bool has_quiet_NaN = true;\n\n\t\t/// Supports subnormal values.\n\t\tstatic HALF_CONSTEXPR_CONST float_denorm_style has_denorm = denorm_present;\n\n\t\t/// Rounding mode.\n\t\t/// Due to the mix of internal single-precision computations (using the rounding mode of the underlying \n\t\t/// single-precision implementation) with explicit truncation of the single-to-half conversions, the actual rounding \n\t\t/// mode is indeterminate.\n\t\tstatic HALF_CONSTEXPR_CONST float_round_style round_style = (std::numeric_limits<float>::round_style==\n\t\t\thalf::round_style) ? half::round_style : round_indeterminate;\n\n\t\t/// Significant digits.\n\t\tstatic HALF_CONSTEXPR_CONST int digits = 11;\n\n\t\t/// Significant decimal digits.\n\t\tstatic HALF_CONSTEXPR_CONST int digits10 = 3;\n\n\t\t/// Required decimal digits to represent all possible values.\n\t\tstatic HALF_CONSTEXPR_CONST int max_digits10 = 5;\n\n\t\t/// Number base.\n\t\tstatic HALF_CONSTEXPR_CONST int radix = 2;\n\n\t\t/// One more than smallest exponent.\n\t\tstatic HALF_CONSTEXPR_CONST int min_exponent = -13;\n\n\t\t/// Smallest normalized representable power of 10.\n\t\tstatic HALF_CONSTEXPR_CONST int min_exponent10 = -4;\n\n\t\t/// One more than largest exponent\n\t\tstatic HALF_CONSTEXPR_CONST int max_exponent = 16;\n\n\t\t/// Largest finitely representable power of 10.\n\t\tstatic HALF_CONSTEXPR_CONST int max_exponent10 = 4;\n\n\t\t/// Smallest positive normal value.\n\t\tstatic HALF_CONSTEXPR half min() HALF_NOTHROW { return half(detail::binary, 0x0400); }\n\n\t\t/// Smallest finite value.\n\t\tstatic HALF_CONSTEXPR half lowest() HALF_NOTHROW { return half(detail::binary, 0xFBFF); }\n\n\t\t/// Largest finite value.\n\t\tstatic HALF_CONSTEXPR half max() HALF_NOTHROW { return half(detail::binary, 0x7BFF); }\n\n\t\t/// Difference between one and next representable value.\n\t\tstatic HALF_CONSTEXPR half epsilon() HALF_NOTHROW { return half(detail::binary, 0x1400); }\n\n\t\t/// Maximum rounding error.\n\t\tstatic HALF_CONSTEXPR half round_error() HALF_NOTHROW\n\t\t\t{ return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }\n\n\t\t/// Positive infinity.\n\t\tstatic HALF_CONSTEXPR half infinity() HALF_NOTHROW { return half(detail::binary, 0x7C00); }\n\n\t\t/// Quiet NaN.\n\t\tstatic HALF_CONSTEXPR half quiet_NaN() HALF_NOTHROW { return half(detail::binary, 0x7FFF); }\n\n\t\t/// Signalling NaN.\n\t\tstatic HALF_CONSTEXPR half signaling_NaN() HALF_NOTHROW { return half(detail::binary, 0x7DFF); }\n\n\t\t/// Smallest positive subnormal value.\n\t\tstatic HALF_CONSTEXPR half denorm_min() HALF_NOTHROW { return half(detail::binary, 0x0001); }\n\t};\n\n#if HALF_ENABLE_CPP11_HASH\n\t/// Hash function for half-precision floats.\n\t/// This is only defined if C++11 `std::hash` is supported and enabled.\n\ttemplate<> struct hash<half> //: unary_function<half,size_t>\n\t{\n\t\t/// Type of function argument.\n\t\ttypedef half argument_type;\n\n\t\t/// Function return type.\n\t\ttypedef size_t result_type;\n\n\t\t/// Compute hash function.\n\t\t/// \\param arg half to hash\n\t\t/// \\return hash value\n\t\tresult_type operator()(argument_type arg) const\n\t\t\t{ return hash<detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }\n\t};\n#endif\n}\n\n\n#undef HALF_CONSTEXPR\n#undef HALF_CONSTEXPR_CONST\n#undef HALF_NOEXCEPT\n#undef HALF_NOTHROW\n#ifdef HALF_POP_WARNINGS\n\t#pragma warning(pop)\n\t#undef HALF_POP_WARNINGS\n#endif\n\n#endif // AESL_SYN\n\n// implemented in lib_hlsm.cpp\n//extern int __signbit(half a_re);\nextern half half_nan(const char *tagp);\n// extern int __isfinite(half t_in);\n// extern int __isinf(half t_in);\n// extern int __isnan(half t_in);\n// extern int __isnormal(half t_in);\n// extern int __fpclassify(half t_in);\nextern half half_atan(half t);\nextern half half_atan2(half y, half x);\nextern half half_copysign(half x, half y);\n//extern half copysign(half x, half y);\nextern half half_fabs(half x);\n//extern half fabs(half x);\nextern half half_abs(half x);\nextern half half_fma(half x, half y, half z);\nextern half half_mad(half x, half y, half z);\nextern half half_frexp (half x, int* exp);\nextern half half_ldexp (half x, int exp);\nextern half half_fmax(half x, half y);\n//extern half fmax(half x, half y);\nextern half half_fmin(half x, half y);\n//extern half fmin(half x, half y);\nextern half half_asin(half t_in);\nextern half half_acos(half t_in);\nextern half half_sin(half t_in);\nextern half half_cos(half t_in);\nextern void half_sincos(half x, half *sin, half *cos);\nextern half half_sinh(half t_in);\nextern half half_cosh(half t_in);\nextern half half_sinpi(half t_in);\nextern half half_cospi(half t_in);\nextern half half_recip(half x);\nextern half half_sqrt(half x);\nextern half half_rsqrt(half x);\nextern half half_cbrt(half x);\nextern half half_hypot(half x, half y);\nextern half half_log(half x);\nextern half half_log10(half x);\nextern half half_log2(half x);\nextern half half_logb(half x);\nextern half half_log1p(half x);\nextern int half_ilogb(half x);\nextern half half_exp(half x);\nextern half half_exp10(half x);\nextern half half_exp2(half x);\nextern half half_expm1(half x);\nextern half half_pow(half x, half y);\nextern half half_powr(half x, half y);\nextern half half_pown(half x, int y);\nextern half half_rootn(half x, int y);\nextern half half_floor(half x);\n//half floor(half x)\nextern half half_ceil(half x);\n//half ceil(half x)\nextern half half_trunc(half x);\n// half trunc(half x)\nextern half half_round(half x);\n//half round(half x)\nextern half half_nearbyint(half x);\nextern half half_rint(half x);\nextern long int half_lrint(half x);\nextern long long int half_llrint(half x);\nextern long int half_lround(half x);\nextern long long int half_llround(half x);\nextern half half_modf(half x, half *intpart);\n// half modf(half x, half *intpart)\nextern half half_fract(half x, half *intpart);\nextern half half_nextafter(half x, half y);\nextern half half_fmod(half x, half y);\nextern half half_remainder(half x, half y);\nextern half half_remquo(half x, half y, int* quo);\nextern half half_divide(half x, half y);\n#endif\n\n// vim: ts=4:sw=4:tw=4:noexpandtab:\n\n",
    "ap_decl.h": "/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n */\n\n#ifndef __AP_DECL_H__\n#define __AP_DECL_H__\n\n// ----------------------------------------------------------------------\n\n#if !defined(__AP_FIXED_H__) && !defined(__AP_INT_H__) && !defined(__AUTOPILOT_CBE_H__) && !defined(__HLS_HALF_H__)\n#error \"Only ap_fixed.h and ap_int.h can be included directly in user code.\"\n#endif\n\n// Test __SYNTHESIS__ only for mode\n#if !defined(__SYNTHESIS__) && (defined(AESL_SYN) || defined(__HLS_SYN__))\n//#pragma message \"AESL_SYN and __HLS_SYN__ should be replaced by __SYNTHESIS__\"\n#define __SYNTHESIS__\n#endif\n\n/* for safety*/\n#if (defined(_AP_N) || defined(_AP_C))\n#error One or more of the following is defined: _AP_N, _AP_C. Definition conflicts with their usage as template parameters.\n#endif\n\n/* for safety*/\n#if (defined(_AP_W) || defined(_AP_I) || defined(_AP_S) || defined(_AP_Q) || \\\n     defined(_AP_O) || defined(_AP_W2) || defined(_AP_I2) ||                 \\\n     defined(_AP_S2) || defined(_AP_Q2) || defined(_AP_O2) ||                \\\n     defined(_AP_N) || defined(_AP_N2))\n#error \\\n    \"One or more of the following is defined: _AP_W, _AP_I, _AP_S, _AP_Q, _AP_O,  _AP_N, _AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2. Definition conflicts with their usage as template parameters.\"\n#endif\n\n/*for safety*/\n#if (defined(_AP_W3) || defined(_AP_S3) || defined(_AP_W4) || defined(_AP_S4))\n#error \\\n    \"One or more of the following is defined: _AP_W3, _AP_S3, _AP_W4,_AP_S4. Definition conflicts with their usage as template parameters.\"\n#endif\n\n#if (defined(_AP_W1) || defined(_AP_S1) || defined(_AP_T) || \\\n     defined(_AP_T1) || defined(_AP_T2) || defined(_AP_T3) || defined(_AP_T4))\n#error \\\n    \"One or more of the following is defined: _AP_W1, _AP_S1, _AP_T,  _AP_T1, _AP_T2, _AP_T3, _AP_T4. Definition conflicts with their usage as template parameters.\"\n#endif\n\n#ifndef __cplusplus\n#error \"AP data type can only be used in C++\"\n#endif\n\n// ----------------------------------------------------------------------\n\n#ifndef __SC_COMPATIBLE__\n/// ap_fixed quantification mode\nenum ap_q_mode {\n  AP_RND,         //< rounding to plus infinity\n  AP_RND_ZERO,    //< rounding to zero\n  AP_RND_MIN_INF, //< rounding to minus infinity\n  AP_RND_INF,     //< rounding to infinity\n  AP_RND_CONV,    //< convergent rounding\n  AP_TRN,         //< truncation\n  AP_TRN_ZERO,    //< truncation to zero\n};\n\n// FIXME for legacy code\n#ifndef SYSTEMC_INCLUDED\n#define SC_RND AP_RND\n#define SC_RND_ZERO AP_RND_ZERO\n#define SC_RND_MIN_INF AP_RND_MIN_INF\n#define SC_RND_INF AP_RND_INF\n#define SC_RND_CONV AP_RND_CONV\n#define SC_TRN AP_TRN\n#define SC_TRN_ZERO AP_TRN_ZERO\n#endif // !defined(SYSTEMC_INCLUDED)\n\n/// ap_fixed saturation mode\nenum ap_o_mode {\n  AP_SAT,      //< saturation\n  AP_SAT_ZERO, //< saturation to zero\n  AP_SAT_SYM,  //< symmetrical saturation\n  AP_WRAP,     //< wrap-around (*)\n  AP_WRAP_SM,  //< sign magnitude wrap-around (*)\n};\n\n// FIXME for legacy code\n#ifndef SYSTEMC_INCLUDED\n#define SC_SAT AP_SAT\n#define SC_SAT_ZERO AP_SAT_ZERO\n#define SC_SAT_SYM AP_SAT_SYM\n#define SC_WRAP AP_WRAP\n#define SC_WRAP_SM AP_WRAP_SM\n#endif // !defined(SYSTEMC_INCLUDED)\n\n#else // defined(__SC_COMPATIBLE__)\n\n// There will not be sc_fxdefs.h, and the emu should be defined by ap_fixed.\n\n/// ap_fixed quantification mode\nenum ap_q_mode {\n  SC_RND,         //< rounding to plus infinity\n  SC_RND_ZERO,    //< rounding to zero\n  SC_RND_MIN_INF, //< rounding to minus infinity\n  SC_RND_INF,     //< rounding to infinity\n  SC_RND_CONV,    //< convergent rounding\n  SC_TRN,         //< truncation\n  SC_TRN_ZERO,    //< truncation to zero\n};\n\n#define AP_RND SC_RND\n#define AP_RND_ZERO SC_RND_ZERO\n#define AP_RND_MIN_INF SC_RND_MIN_INF\n#define AP_RND_INF SC_RND_INF\n#define AP_RND_CONV SC_RND_CONV\n#define AP_TRN SC_TRN\n#define AP_TRN_ZERO SC_TRN_ZERO\n\n/// ap_fixed saturation mode\nenum ap_o_mode {\n  SC_SAT,      //< saturation\n  SC_SAT_ZERO, //< saturation to zero\n  SC_SAT_SYM,  //< symmetrical saturation\n  SC_WRAP,     //< wrap-around (*)\n  SC_WRAP_SM,  //< sign magnitude wrap-around (*)\n};\n\n#define AP_SAT SC_SAT\n#define AP_SAT_ZERO SC_SAT_ZERO\n#define AP_SAT_SYM SC_SAT_SYM\n#define AP_WRAP SC_WRAP\n#define AP_WRAP_SM SC_WRAP_SM\n\n#endif // defined(__SC_COMPATIBLE__)\n\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_int_base;\n\ntemplate <int _AP_W>\nstruct ap_int;\n\ntemplate <int _AP_W>\nstruct ap_uint;\n\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_range_ref;\n\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_bit_ref;\n\ntemplate <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>\nstruct ap_concat_ref;\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,\n          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>\nstruct ap_fixed_base;\n\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,\n          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>\nstruct ap_fixed;\n\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,\n          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>\nstruct ap_ufixed;\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nstruct af_range_ref;\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nstruct af_bit_ref;\n\n/// string base mode\nenum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };\n\n#ifndef SYSTEMC_INCLUDED\n#define SC_BIN 2\n#define SC_OCT 8\n#define SC_DEC 10\n#define SC_HEX 16\n#endif // !defined(SYSTEMC_INCLUDED)\n\n// Alias C data types\n#if defined(_MSC_VER) && _MSC_VER < 1900\n// Legacy tool before Visual Studio 2015\ntypedef signed __int64 ap_slong;\ntypedef unsigned __int64 ap_ulong;\n#else  \ntypedef signed long long ap_slong;\ntypedef unsigned long long ap_ulong;\n#endif // _MSC_VER\n\nenum {\n  _AP_SIZE_char = 8,\n  _AP_SIZE_short = sizeof(short) * 8,\n  _AP_SIZE_int = sizeof(int) * 8,\n  _AP_SIZE_long = sizeof(long) * 8,\n  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8\n};\n\n#endif // !defined(__AP_DECL_H__)\n\n// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n",
    "ap_fixed_base.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_FIXED_BASE_H__\n#define __AP_FIXED_BASE_H__\n\n#ifndef __AP_FIXED_H__\n// TODO make this an error\n#pragma message \\\n    \"Only ap_fixed.h and ap_int.h can be included directly in user code.\"\n#endif\n\n// for ap_int_base and its reference types.\n#include \"ap_int.h\"\n#ifndef __SYNTHESIS__\n// for half type\n#include \"hls_half.h\"\n// for std io\n#include \"iostream\"\n#endif\n\n#ifndef __cplusplus\n#error \"C++ is required to include this header file\"\n#else // __cplusplus\n\n// for warning on unsupported rounding mode in conversion to float/double.\n#if !defined(__SYNTHESIS__) && __cplusplus >= 201103L && \\\n    (defined(__gnu_linux__) || defined(_WIN32))\n#define AP_FIXED_ENABLE_CPP_FENV 1\n#include \"cfenv\"\n#endif\n\n// ----------------------------------------------------------------------\n\n/* Major TODO\n  long double support: constructor, assign and other operators.\n  binary operators with ap_fixed_base and const char*.\n  return ap_fixed/ap_ufixed when result signedness is known.\n*/\n\n// Helper function in conversion to floating point types.\n\n#ifdef __SYNTHESIS__\n#define _AP_ctype_op_get_bit(var, index) _AP_ROOT_op_get_bit(var, index)\n#define _AP_ctype_op_set_bit(var, index, x) _AP_ROOT_op_set_bit(var, index, x)\n#define _AP_ctype_op_get_range(var, low, high) \\\n  _AP_ROOT_op_get_range(var, low, high)\n#define _AP_ctype_op_set_range(var, low, high, x) \\\n  _AP_ROOT_op_set_range(var, low, high, x)\n#else // ifdef __SYNTHESIS__\ntemplate <typename _Tp1, typename _Tp2>\ninline bool _AP_ctype_op_get_bit(_Tp1& var, const _Tp2& index) {\n  return !!(var & (1ull << (index)));\n}\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3>\ninline _Tp1 _AP_ctype_op_set_bit(_Tp1& var, const _Tp2& index, const _Tp3& x) {\n  var |= (((x) ? 1ull : 0ull) << (index));\n  return var;\n}\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3>\ninline _Tp1 _AP_ctype_op_get_range(_Tp1& var, const _Tp2& low,\n                                   const _Tp3& high) {\n  _Tp1 r = var;\n  ap_ulong mask = -1ll;\n  mask >>= (sizeof(_Tp1) * 8 - ((high) - (low) + 1));\n  r >>= (low);\n  r &= mask;\n  return r;\n}\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\ninline _Tp1 _AP_ctype_op_set_range(_Tp1& var, const _Tp2& low, const _Tp3& high,\n                                   const _Tp4& x) {\n  ap_ulong mask = -1ll;\n  mask >>= (_AP_SIZE_ap_slong - ((high) - (low) + 1));\n  var &= ~(mask << (low));\n  var |= ((mask & x) << (low));\n  return var;\n}\n#endif // ifdef __SYNTHESIS__\n\n\n// trait for letting base class to return derived class.\n// Notice that derived class template is incomplete, and we cannot use\n// the member of the derived class.\ntemplate <int _AP_W2, int _AP_I2, bool _AP_S2>\nstruct _ap_fixed_factory;\ntemplate <int _AP_W2, int _AP_I2>\nstruct _ap_fixed_factory<_AP_W2, _AP_I2, true> {\n  typedef ap_fixed<_AP_W2, _AP_I2> type;\n};\ntemplate <int _AP_W2, int _AP_I2>\nstruct _ap_fixed_factory<_AP_W2, _AP_I2, false> {\n  typedef ap_ufixed<_AP_W2, _AP_I2> type;\n};\n\n/// ap_fixed_base: AutoPilot fixed point.\n/** partial specialization of signed.\n  @tparam _AP_W width.\n  @tparam _AP_I integral part width.\n  @tparam _AP_S signed.\n  @tparam _AP_Q quantization mode. Default is AP_TRN.\n  @tparam _AP_O saturation mode. Default is AP_WRAP.\n  @tparam _AP_N saturation wrap value. Default is 0.\n */\n// default for _AP_Q, _AP_O and _AP_N set in ap_decl.h\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nstruct ap_fixed_base : _AP_ROOT_TYPE<_AP_W, _AP_S> {\n public:\n  typedef _AP_ROOT_TYPE<_AP_W, _AP_S> Base;\n  static const int width = _AP_W;\n  static const int iwidth = _AP_I;\n  static const ap_q_mode qmode = _AP_Q;\n  static const ap_o_mode omode = _AP_O;\n\n  /// Return type trait.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2>\n  struct RType {\n    enum {\n      _AP_F = _AP_W - _AP_I,\n      F2 = _AP_W2 - _AP_I2,\n      mult_w = _AP_W + _AP_W2,\n      mult_i = _AP_I + _AP_I2,\n      mult_s = _AP_S || _AP_S2,\n      plus_w = AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)) +\n               1 + AP_MAX(_AP_F, F2),\n      plus_i =\n          AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)) + 1,\n      plus_s = _AP_S || _AP_S2,\n      minus_w =\n          AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)) + 1 +\n          AP_MAX(_AP_F, F2),\n      minus_i =\n          AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)) + 1,\n      minus_s = true,\n#ifndef __SC_COMPATIBLE__\n      div_w = _AP_S2 + _AP_W + AP_MAX(F2, 0),\n#else\n      div_w = _AP_S2 + _AP_W + AP_MAX(F2, 0) + AP_MAX(_AP_I2, 0),\n#endif\n      div_i = _AP_S2 + _AP_I + F2,\n      div_s = _AP_S || _AP_S2,\n      logic_w =\n          AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)) +\n          AP_MAX(_AP_F, F2),\n      logic_i = AP_MAX(_AP_I + (_AP_S2 && !_AP_S), _AP_I2 + (_AP_S && !_AP_S2)),\n      logic_s = _AP_S || _AP_S2\n    };\n\n    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;\n    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;\n\n    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;\n    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;\n    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;\n    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;\n    typedef ap_fixed_base<div_w, div_i, div_s> div_base;\n    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;\n\n    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;\n    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;\n    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;\n    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;\n    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;\n    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;\n  };\n\n private:\n#ifndef __SYNTHESIS__\n  // This cannot handle hex float format string.\n  void fromString(const std::string& val, unsigned char radix) {\n    _AP_ERROR(!(radix == 2 || radix == 8 || radix == 10 || radix == 16),\n              \"ap_fixed_base::fromString(%s, %d)\", val.c_str(), radix);\n\n    Base::V = 0;\n    int startPos = 0;\n    int endPos = val.length();\n    int decPos = val.find(\".\");\n    if (decPos == -1) decPos = endPos;\n\n    // handle sign\n    bool isNegative = false;\n    if (val[0] == '-') {\n      isNegative = true;\n      ++startPos;\n    } else if (val[0] == '+')\n      ++startPos;\n\n    // If there are no integer bits, e.g.:\n    // .0000XXXX, then keep at least one bit.\n    // If the width is greater than the number of integer bits, e.g.:\n    // XXXX.XXXX, then we keep the integer bits\n    // if the number of integer bits is greater than the width, e.g.:\n    // XXX000 then we keep the integer bits.\n    // Always keep one bit.\n    ap_fixed_base<AP_MAX(_AP_I, 4) + 4, AP_MAX(_AP_I, 4) + 4, false>\n        integer_bits = 0;\n\n    // Figure out if we can shift instead of multiply\n    unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);\n\n    //std::cout << \"\\n\\n\" << val << \"\\n\";\n    //std::cout << startPos << \" \" << decPos << \" \" << endPos << \"\\n\";\n\n    bool sticky_int = false;\n\n    // Traverse the integer digits from the MSD, multiplying by radix as we go.\n    for (int i = startPos; i < decPos; i++) {\n      // Get a digit\n      char cdigit = val[i];\n      if (cdigit == '\\0') continue;\n      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);\n\n      sticky_int |= integer_bits[AP_MAX(_AP_I, 4) + 4 - 1] |\n                    integer_bits[AP_MAX(_AP_I, 4) + 4 - 2] |\n                    integer_bits[AP_MAX(_AP_I, 4) + 4 - 3] |\n                    integer_bits[AP_MAX(_AP_I, 4) + 4 - 4];\n      // Shift or multiply the value by the radix\n      if (shift)\n        integer_bits <<= shift;\n      else\n        integer_bits *= radix;\n\n      // Add in the digit we just interpreted\n      integer_bits += digit;\n      //std::cout << \"idigit = \" << digit << \" \" << integer_bits.to_string()\n      //    << \"  \" << sticky_int <<  \"\\n\";\n    }\n    integer_bits[AP_MAX(_AP_I, 4) + 4 - 3] =\n        integer_bits[AP_MAX(_AP_I, 4) + 4 - 3] | sticky_int;\n\n    ap_fixed_base<AP_MAX(_AP_W - _AP_I, 0) + 4 + 4, 4, false> fractional_bits = 0;\n    bool sticky = false;\n\n    // Traverse the fractional digits from the LSD, dividing by radix as we go.\n    for (int i = endPos - 1; i >= decPos + 1; i--) {\n      // Get a digit\n      char cdigit = val[i];\n      if (cdigit == '\\0') continue;\n      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);\n      // Add in the digit we just interpreted\n      fractional_bits += digit;\n\n      sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] |\n                fractional_bits[3];\n      // Shift or divide the value by the radix\n      if (shift)\n        fractional_bits >>= shift;\n      else\n        fractional_bits /= radix;\n\n      //std::cout << \"fdigit = \" << digit << \" \" << fractional_bits.to_string()\n      //    << \" \" << sticky << \"\\n\";\n    }\n\n    //std::cout << \"Int =\" << integer_bits.to_string() << \" \" <<\n    //    fractional_bits.to_string() << \"\\n\";\n\n    fractional_bits[0] = fractional_bits[0] | sticky;\n\n    if (isNegative)\n      *this = -(integer_bits + fractional_bits);\n    else\n      *this = integer_bits + fractional_bits;\n\n    //std::cout << \"end = \" << this->to_string(16) << \"\\n\";\n  }\n\n  /// report invalid constrction of ap_fixed_base\n  INLINE void report() {\n    if (!_AP_S && _AP_O == AP_WRAP_SM) {\n      fprintf(stderr, \"ap_ufxied<...> cannot support AP_WRAP_SM.\\n\");\n      exit(1);\n    }\n    if (_AP_W > MAX_MODE(AP_INT_MAX_W) * 1024) {\n      fprintf(stderr,\n              \"[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the \"\n              \"default max value %d. Please use macro \"\n              \"AP_INT_MAX_W to set a larger max value.\\n\",\n              _AP_S ? \"\" : \"u\", _AP_W, MAX_MODE(AP_INT_MAX_W) * 1024);\n      exit(1);\n    }\n  }\n#else\n  INLINE void report() {}\n#endif // ifdef __SYNTHESIS__\n\n  /// @name helper functions.\n  //  @{\n  INLINE void overflow_adjust(bool underflow, bool overflow, bool lD,\n                              bool sign) {\n    if (!underflow && !overflow) return;\n    if (_AP_O == AP_WRAP) {\n      if (_AP_N == 0) return;\n      if (_AP_S) {\n        // signed AP_WRAP\n        // n_bits == 1\n        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);\n        if (_AP_N > 1) {\n          // n_bits > 1\n          ap_int_base<_AP_W, false> mask(-1);\n          if (sign) mask.V = 0;\n          Base::V =\n              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);\n        }\n      } else {\n        // unsigned AP_WRAP\n        ap_int_base<_AP_W, false> mask(-1);\n        Base::V =\n            _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 1, mask.V);\n      }\n    } else if (_AP_O == AP_SAT_ZERO) {\n      Base::V = 0;\n    } else if (_AP_O == AP_WRAP_SM && _AP_S) {\n      bool Ro = _AP_ROOT_op_get_bit(Base::V, _AP_W - 1);\n      if (_AP_N == 0) {\n        if (lD != Ro) {\n          Base::V = ~Base::V;\n          Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, lD);\n        }\n      } else {\n        if (_AP_N == 1 && sign != Ro) {\n          Base::V = ~Base::V;\n        } else if (_AP_N > 1) {\n          bool lNo = _AP_ROOT_op_get_bit(Base::V, _AP_W - _AP_N);\n          if (lNo == sign) Base::V = ~Base::V;\n          ap_int_base<_AP_W, false> mask(-1);\n          if (sign) mask.V = 0;\n          Base::V =\n              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);\n        }\n        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);\n      }\n    } else {\n      if (_AP_S) {\n        if (overflow) {\n          Base::V = 1;\n          Base::V <<= _AP_W - 1;\n          Base::V = ~Base::V;\n        } else if (underflow) {\n          Base::V = 1;\n          Base::V <<= _AP_W - 1;\n          if (_AP_O == AP_SAT_SYM) Base::V |= 1;\n        }\n      } else {\n        if (overflow)\n          Base::V = ~(ap_int_base<_AP_W, false>(0).V);\n        else if (underflow)\n          Base::V = 0;\n      }\n    }\n  }\n\n  INLINE bool quantization_adjust(bool qb, bool r, bool s) {\n    bool carry = (bool)_AP_ROOT_op_get_bit(Base::V, _AP_W - 1);\n    if (_AP_Q == AP_TRN) return false;\n    if (_AP_Q == AP_RND_ZERO)\n      qb &= s || r;\n    else if (_AP_Q == AP_RND_MIN_INF)\n      qb &= r;\n    else if (_AP_Q == AP_RND_INF)\n      qb &= !s || r;\n    else if (_AP_Q == AP_RND_CONV)\n      qb &= _AP_ROOT_op_get_bit(Base::V, 0) || r;\n    else if (_AP_Q == AP_TRN_ZERO)\n      qb = s && (qb || r);\n    Base::V += qb;\n    return carry && (!(bool)_AP_ROOT_op_get_bit(Base::V, _AP_W - 1));\n  }\n  //  @}\n\n public:\n  /// @name constructors.\n  //  @{\n  /// default ctor.\n  INLINE ap_fixed_base() {}\n\n  /// copy ctor.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    operator=(op);\n    report();\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base(\n      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    operator=(op);\n    report();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {\n    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;\n    tmp.V = op.V;\n    operator=(tmp);\n    report();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {\n    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;\n    tmp.V = op.V;\n    operator=(tmp);\n    report();\n  }\n\n#ifndef __SYNTHESIS__\n#ifndef NON_C99STRING\n  INLINE ap_fixed_base(const char* s, signed char rd = 0) {\n    unsigned char radix = rd;\n    std::string str = ap_private_ops::parseString(s, radix); // will guess rd, default 10\n    _AP_ERROR(radix == 0, \"ap_fixed_base(const char* \\\"%s\\\", %d), str=%s, radix = %d\",\n              s, rd, str.c_str(), radix); // TODO remove this check\n    fromString(str, radix);\n  }\n#else\n  INLINE ap_fixed_base(const char* s, signed char rd = 10) {\n    ap_int_base<_AP_W, _AP_S> t(s, rd);\n    Base::V = t.V;\n  }\n#endif // ifndef NON_C99STRING\n#else // ifndef __SYNTHESIS__\n  // XXX _ssdm_string2bits only takes const string and const radix.\n  // It seems XFORM will do compile time processing of the string.\n  INLINE ap_fixed_base(const char* s) {\n    typeof(Base::V) t;\n    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,\n                      _AP_O, _AP_N, _AP_C99);\n    Base::V = t;\n  }\n  INLINE ap_fixed_base(const char* s, signed char rd) {\n    typeof(Base::V) t;\n    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,\n                      _AP_O, _AP_N, _AP_C99);\n    Base::V = t;\n  }\n#endif // ifndef __SYNTHESIS__ else\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {\n    *this = ((bool)op);\n    report();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {\n    *this = (ap_int_base<_AP_W2, false>(op));\n    report();\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_fixed_base(\n      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {\n    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));\n    report();\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    *this = (bool(op));\n    report();\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    *this = (ap_int_base<_AP_W2, false>(op));\n    report();\n  }\n\n  // ctors from c types.\n  // make a temp ap_fixed_base first, and use ap_fixed_base.operator=\n#define CTOR_FROM_INT(C_TYPE, _AP_W2, _AP_S2)        \\\n  INLINE ap_fixed_base(const C_TYPE x) {             \\\n    ap_fixed_base<(_AP_W2), (_AP_W2), (_AP_S2)> tmp; \\\n    tmp.V = x;                                       \\\n    *this = tmp;                                     \\\n  }\n\n  CTOR_FROM_INT(bool, 1, false)\n  CTOR_FROM_INT(char, 8, CHAR_IS_SIGNED)\n  CTOR_FROM_INT(signed char, 8, true)\n  CTOR_FROM_INT(unsigned char, 8, false)\n  CTOR_FROM_INT(short, _AP_SIZE_short, true)\n  CTOR_FROM_INT(unsigned short, _AP_SIZE_short, false)\n  CTOR_FROM_INT(int, _AP_SIZE_int, true)\n  CTOR_FROM_INT(unsigned int, _AP_SIZE_int, false)\n  CTOR_FROM_INT(long, _AP_SIZE_long, true)\n  CTOR_FROM_INT(unsigned long, _AP_SIZE_long, false)\n  CTOR_FROM_INT(ap_slong, _AP_SIZE_ap_slong, true)\n  CTOR_FROM_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n#undef CTOR_FROM_INT\n/*\n * TODO:\n *Theere used to be several funtions which were AP_WEAK.\n *Now they're all INLINE expect ap_fixed_base(double d)\n *Maybe we can use '#pragma HLS inline' instead of INLINE.\n */\n  AP_WEAK ap_fixed_base(double d) {\n    ap_int_base<64, false> ireg;\n    ireg.V = doubleToRawBits(d);\n    bool isneg = _AP_ROOT_op_get_bit(ireg.V, 63);\n\n    ap_int_base<DOUBLE_EXP + 1, true> exp;\n    ap_int_base<DOUBLE_EXP, false> exp_tmp;\n    exp_tmp.V =\n        _AP_ROOT_op_get_range(ireg.V, DOUBLE_MAN, DOUBLE_MAN + DOUBLE_EXP - 1);\n    exp = exp_tmp - DOUBLE_BIAS;\n    ap_int_base<DOUBLE_MAN + 2, true> man;\n    man.V = _AP_ROOT_op_get_range(ireg.V, 0, DOUBLE_MAN - 1);\n    // do not support NaN\n    _AP_WARNING(exp == APFX_IEEE_DOUBLE_E_MAX + 1 && man.V != 0,\n                \"assign NaN to fixed point value\");\n    man.V = _AP_ROOT_op_set_bit(man.V, DOUBLE_MAN, 1);\n    if (isneg) man = -man;\n    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {\n      Base::V = 0;\n    } else {\n      int _AP_W2 = DOUBLE_MAN + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,\n          F2 = _AP_W2 - _AP_I2;\n      bool _AP_S2 = true,\n           QUAN_INC = F2 > _AP_F &&\n                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));\n      bool carry = false;\n      // handle quantization\n      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;\n      if (F2 == _AP_F)\n        Base::V = man.V;\n      else if (F2 > _AP_F) {\n        if (sh_amt < DOUBLE_MAN + 2)\n          Base::V = man.V >> sh_amt;\n        else {\n          Base::V = isneg ? -1 : 0;\n        }\n        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {\n          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)_AP_ROOT_op_get_bit(\n                                                        man.V, F2 - _AP_F - 1);\n          bool r =\n              (F2 > _AP_F + 1)\n                  ? _AP_ROOT_op_get_range(man.V, 0, (F2 - _AP_F - 2 < _AP_W2)\n                                                        ? (F2 - _AP_F - 2)\n                                                        : (_AP_W2 - 1)) != 0\n                  : false;\n          carry = quantization_adjust(qb, r, isneg);\n        }\n      } else { // no quantization\n        Base::V = man.V;\n        if (sh_amt < _AP_W)\n          Base::V = Base::V << sh_amt;\n        else\n          Base::V = 0;\n      }\n      // handle overflow/underflow\n      if ((_AP_O != AP_WRAP || _AP_N != 0) &&\n          ((!_AP_S && _AP_S2) ||\n           _AP_I - _AP_S <\n               _AP_I2 - _AP_S2 +\n                   (QUAN_INC ||\n                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) { // saturation\n        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;\n        bool neg_src = isneg;\n        bool lD = false;\n        int pos1 = F2 - _AP_F + _AP_W;\n        int pos2 = F2 - _AP_F + _AP_W + 1;\n        bool newsignbit = _AP_ROOT_op_get_bit(Base::V, _AP_W - 1);\n        if (pos1 < _AP_W2 && pos1 >= 0)\n          // lD = _AP_ROOT_op_get_bit(man.V, pos1);\n          lD = (man.V >> pos1) & 1;\n        if (pos1 < _AP_W2) {\n          bool Range1_all_ones = true;\n          bool Range1_all_zeros = true;\n          bool Range2_all_ones = true;\n          ap_int_base<DOUBLE_MAN + 2, false> Range2;\n          ap_int_base<DOUBLE_MAN + 2, false> all_ones(-1);\n\n          if (pos2 >= 0 && pos2 < _AP_W2) {\n            // Range2.V = _AP_ROOT_op_get_range(man.V,\n            //                        pos2, _AP_W2 - 1);\n            Range2.V = man.V;\n            Range2.V >>= pos2;\n            Range2_all_ones = Range2 == (all_ones >> pos2);\n          } else if (pos2 < 0)\n            Range2_all_ones = false;\n          if (pos1 >= 0 && pos2 < _AP_W2) {\n            Range1_all_ones = Range2_all_ones && lD;\n            Range1_all_zeros = !Range2.V && !lD;\n          } else if (pos2 == _AP_W2) {\n            Range1_all_ones = lD;\n            Range1_all_zeros = !lD;\n          } else if (pos1 < 0) {\n            Range1_all_zeros = !man.V;\n            Range1_all_ones = false;\n          }\n\n          deleted_zeros =\n              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);\n          deleted_ones =\n              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;\n          neg_src = isneg && !(carry && Range1_all_ones);\n        } else\n          neg_src = isneg && newsignbit;\n        bool neg_trg = _AP_S && newsignbit;\n        bool overflow = (neg_trg || !deleted_zeros) && !isneg;\n        bool underflow = (!neg_trg || !deleted_ones) && neg_src;\n        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)\n          underflow |=\n              neg_src &&\n              (_AP_W > 1 ? _AP_ROOT_op_get_range(Base::V, 0, _AP_W - 2) == 0\n                         : true);\n        overflow_adjust(underflow, overflow, lD, neg_src);\n      }\n    }\n    report();\n  }\n\n  // TODO more optimized implementation.\n  INLINE ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }\n\n  // TODO more optimized implementation.\n  INLINE ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }\n  //  @}\n\n  /// @name assign operator\n  /// assign, using another ap_fixed_base of same template parameters.\n  /*\n  INLINE ap_fixed_base& operator=(\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {\n    Base::V = op.V;\n    return *this;\n  }\n  */\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base& operator=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n\n    const int _AP_F = _AP_W - _AP_I;\n    const int F2 = _AP_W2 - _AP_I2;\n    const int QUAN_INC =\n          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));\n\n    if (!op) Base::V = 0;\n    bool carry = false;\n    bool signbit = _AP_ROOT_op_get_bit(op.V, _AP_W2 - 1);\n    bool isneg = signbit && _AP_S2;\n    if (F2 == _AP_F)\n      Base::V = op.V;\n    else if (F2 > _AP_F) {\n      unsigned int sh_amt = F2 - _AP_F;\n      //  moves bits right, handle quantization.\n      if (sh_amt < _AP_W2) {\n        Base::V = op.V >> sh_amt;\n      } else {\n        Base::V = isneg ? -1 : 0;\n      }\n      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {\n        bool qbit = _AP_ROOT_op_get_bit(op.V, F2 - _AP_F - 1);\n        // bit after LSB.\n        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;\n        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };\n        // bits after qb.\n        bool r = (F2 > _AP_F + 1) ? (_AP_ROOT_op_get_range(op.V, 0, hi) != 0) : false;\n        carry = quantization_adjust(qb, r, isneg);\n      }\n    } else {\n      unsigned  sh_amt = _AP_F - F2;\n      // moves bits left, no quantization\n      if (sh_amt < _AP_W) {\n        if (_AP_W > _AP_W2) {\n          // extend and then shift, avoid losing bits.\n          Base::V = op.V;\n          Base::V <<= sh_amt;\n        } else {\n          // shift and truncate.\n          Base::V = op.V << sh_amt;\n        }\n      } else {\n        Base::V = 0;\n      }\n    }\n    // handle overflow/underflow\n    if ((_AP_O != AP_WRAP || _AP_N != 0) &&\n        ((!_AP_S && _AP_S2) ||\n         _AP_I - _AP_S <\n             _AP_I2 - _AP_S2 +\n                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) { // saturation\n      bool deleted_zeros = _AP_S2 ? true : !carry;\n      bool deleted_ones = true;\n      bool neg_src = isneg;\n      bool newsignbit = _AP_ROOT_op_get_bit(Base::V, _AP_W - 1);\n      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };\n      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? _AP_ROOT_op_get_bit(op.V, pos1)\n                                             : false;\n      if (pos1 < _AP_W2) {\n        bool Range1_all_ones = true;\n        bool Range1_all_zeros = true;\n        bool Range2_all_ones = true;\n        ap_int_base<_AP_W2, false> all_ones(-1);\n\n        if (pos2 < _AP_W2 && pos2 >= 0) {\n          ap_int_base<_AP_W2, false> Range2;\n          Range2.V = _AP_ROOT_op_get_range(op.V, pos2, _AP_W2 - 1);\n          Range2_all_ones = Range2 == (all_ones >> pos2);\n        } else if (pos2 < 0) {\n          Range2_all_ones = false;\n        }\n\n        if (pos1 >= 0 && pos2 < _AP_W2) {\n          ap_int_base<_AP_W2, false> Range1;\n          Range1.V = _AP_ROOT_op_get_range(op.V, pos1, _AP_W2 - 1);\n          Range1_all_ones = Range1 == (all_ones >> pos1);\n          Range1_all_zeros = !Range1.V;\n        } else if (pos2 == _AP_W2) {\n          Range1_all_ones = lD;\n          Range1_all_zeros = !lD;\n        } else if (pos1 < 0) {\n          Range1_all_zeros = !op.V;\n          Range1_all_ones = false;\n        }\n\n        deleted_zeros =\n            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);\n        deleted_ones =\n            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;\n        neg_src = isneg && !(carry && Range1_all_ones);\n      } else\n        neg_src = isneg && newsignbit;\n      bool neg_trg = _AP_S && newsignbit;\n      bool overflow = (neg_trg || !deleted_zeros) && !isneg;\n      bool underflow = (!neg_trg || !deleted_ones) && neg_src;\n      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)\n        underflow |=\n            neg_src &&\n            (_AP_W > 1 ? _AP_ROOT_op_get_range(Base::V, 0, _AP_W - 2) == 0\n                       : true);\n\n      overflow_adjust(underflow, overflow, lD, neg_src);\n    }\n    return *this;\n  } // operator= \n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base& operator=(\n      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));\n    return *this;\n  }\n\n  /// Set this ap_fixed_base with ULL.\n  INLINE ap_fixed_base& setBits(ap_ulong bv) {\n    // TODO when ull is not be long enough...\n    Base::V = bv;\n    return *this;\n  }\n\n  /// Return a ap_fixed_base object whose this->V is assigned by bv.\n  static INLINE ap_fixed_base bitsToFixed(ap_ulong bv) {\n    // TODO fix when ull is not be long enough...\n    ap_fixed_base t;\n#ifdef __SYNTHESIS__\n    t.V = bv;\n#else\n    t.V.set_bits(bv);\n#endif\n    return t;\n  }\n\n  // Explicit conversion functions to ap_int_base.\n  /** Captures all integer bits, in truncate mode.\n   *  @param[in] Cnative follow conversion from double to int.\n   */\n  INLINE ap_int_base<AP_MAX(_AP_I, 1), _AP_S> to_ap_int_base(\n      bool Cnative = true) const {\n    ap_int_base<AP_MAX(_AP_I, 1), _AP_S> ret;\n    if (_AP_I == 0) {\n      ret.V = 0;\n    } else if (_AP_I > 0 && _AP_I <= _AP_W) {\n      ret.V = _AP_ROOT_op_get_range(Base::V, _AP_W - _AP_I, _AP_W - 1);\n    } else if (_AP_I > _AP_W) {\n      ret.V = _AP_ROOT_op_get_range(Base::V, 0, _AP_W - 1);\n      ret.V <<= (_AP_I - _AP_W);\n    }\n    /* Consider the following case\n     *   float f = -7.5f;\n     *   ap_fixed<8,4> t = f;  // -8 0 0 0 . 0.5\n     *   int i = t.to_int();\n     * the result should be -7 instead of -8.\n     * Therefore, after truncation, the value should be increated by 1.\n     * For (-1, 0), carry to MSB will happen, but result 0 is still correct.\n     */\n    if (Cnative && _AP_I < _AP_W) {\n      // Follow C native data type, conversion from double to int\n      if (_AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1) && (_AP_I < _AP_W) &&\n          (_AP_ROOT_op_get_range(\n               Base::V, 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1) != 0))\n        ++ret;\n    } else {\n      // Follow OSCI library, conversion from sc_fixed to sc_int\n    }\n    return ret;\n  };\n\n public:\n  template <int _AP_W2, bool _AP_S2>\n  INLINE operator ap_int_base<_AP_W2, _AP_S2>() const {\n    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());\n  }\n\n  // Explicit conversion function to C built-in integral type.\n  INLINE char to_char() const { return to_ap_int_base().to_char(); }\n\n  INLINE int to_int() const { return to_ap_int_base().to_int(); }\n\n  INLINE unsigned to_uint() const { return to_ap_int_base().to_uint(); }\n\n  INLINE ap_slong to_int64() const { return to_ap_int_base().to_int64(); }\n\n  INLINE ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }\n\n  /// covert function to double.\n  /** only round-half-to-even mode supported, does not obey FE env. */\n  INLINE double to_double() const {\n#if defined(AP_FIXED_ENABLE_CPP_FENV)\n    _AP_WARNING(std::fegetround() != FE_TONEAREST,\n                \"Only FE_TONEAREST is supported\");\n#endif\n    enum { BITS = DOUBLE_MAN + DOUBLE_EXP + 1 };\n    if (!Base::V) return 0.0f;\n    bool s = _AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1); ///< sign.\n    ap_int_base<_AP_W, false> tmp;\n    if (s)\n      tmp.V = -Base::V; // may truncate one bit extra from neg in sim.\n    else\n      tmp.V = Base::V;\n    int l = tmp.countLeadingZeros(); ///< number of leading zeros.\n    int e = _AP_I - l - 1 + DOUBLE_BIAS; ///< exponent\n    int lsb_index = _AP_W - l - 1 - DOUBLE_MAN;\n    // more than 0.5?\n    bool a = (lsb_index >=2) ?\n        (_AP_ROOT_op_get_range(tmp.V, 0, lsb_index - 2) != 0) : 0;\n    // round to even\n    a |= (lsb_index >=0) ? _AP_ROOT_op_get_bit(tmp.V, lsb_index) : 0;\n    // ull is at least 64-bit\n    ap_ulong m;\n    // may actually left shift, ensure buffer is wide enough.\n    if (_AP_W > BITS) {\n      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))\n                           : (ap_ulong)(tmp.V << (1 - lsb_index));\n    } else {\n      m = (ap_ulong)tmp.V;\n      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))\n                           : (m << (1 - lsb_index));\n    }\n    m += a;\n    m >>= 1;\n    //std::cout << '\\n' << std::hex << m << '\\n'; // TODO delete this\n    // carry to MSB, increase exponent\n    if (_AP_ctype_op_get_bit(m, DOUBLE_MAN + 1)) {\n      e += 1;\n    }\n    // set sign and exponent\n    m = _AP_ctype_op_set_bit(m, BITS - 1, s);\n    //std::cout << m << '\\n'; // TODO delete this\n    m = _AP_ctype_op_set_range(m, DOUBLE_MAN, DOUBLE_MAN + DOUBLE_EXP - 1, e);\n    //std::cout << std::hex << m << std::dec << std::endl; // TODO delete this\n    // cast to fp\n    return rawBitsToDouble(m);\n  }\n\n  /// convert function to float.\n  /** only round-half-to-even mode supported, does not obey FE env. */\n  INLINE float to_float() const {\n#if defined(AP_FIXED_ENABLE_CPP_FENV)\n    _AP_WARNING(std::fegetround() != FE_TONEAREST,\n                \"Only FE_TONEAREST is supported\");\n#endif\n    enum { BITS = FLOAT_MAN + FLOAT_EXP + 1 };\n    if (!Base::V) return 0.0f;\n    bool s = _AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1); ///< sign.\n    ap_int_base<_AP_W, false> tmp;\n    if (s)\n      tmp.V = -Base::V; // may truncate one bit extra from neg in sim.\n    else\n      tmp.V = Base::V;\n    int l = tmp.countLeadingZeros();  ///< number of leading zeros.\n    int e = _AP_I - l - 1 + FLOAT_BIAS; ///< exponent\n    int lsb_index = _AP_W - l - 1 - FLOAT_MAN;\n    // more than 0.5?\n    bool a = (lsb_index >=2) ?\n        (_AP_ROOT_op_get_range(tmp.V, 0, lsb_index - 2) != 0) : 0;\n    // round to even\n    a |= (lsb_index >=0) ? _AP_ROOT_op_get_bit(tmp.V, lsb_index) : 0;\n    // ul is at least 32-bit\n    unsigned long m;\n    // may actually left shift, ensure buffer is wide enough.\n    if (_AP_W > BITS) {\n      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))\n                           : (unsigned long)(tmp.V << (1 - lsb_index));\n    } else {\n      m = (unsigned long)tmp.V;\n      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))\n                           : (m << (1 - lsb_index));\n    }\n    m += a;\n    m >>= 1;\n    // carry to MSB, increase exponent\n    if (_AP_ctype_op_get_bit(m, FLOAT_MAN + 1)) {\n      e += 1;\n    }\n    // set sign and exponent\n    m = _AP_ctype_op_set_bit(m, BITS - 1, s);\n    m = _AP_ctype_op_set_range(m, FLOAT_MAN, FLOAT_MAN + FLOAT_EXP - 1, e);\n    // cast to fp\n    return rawBitsToFloat(m);\n  }\n\n  /// convert function to half.\n  /** only round-half-to-even mode supported, does not obey FE env. */\n  INLINE half to_half() const {\n#if defined(AP_FIXED_ENABLE_CPP_FENV)\n    _AP_WARNING(std::fegetround() != FE_TONEAREST,\n                \"Only FE_TONEAREST is supported\");\n#endif\n    enum { BITS = HALF_MAN + HALF_EXP + 1 };\n    if (!Base::V) return 0.0f;\n    bool s = _AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1); ///< sign.\n    ap_int_base<_AP_W, false> tmp;\n    if (s)\n      tmp.V = -Base::V; // may truncate one bit extra from neg in sim.\n    else\n      tmp.V = Base::V;\n    int l = tmp.countLeadingZeros();  ///< number of leading zeros.\n    int e = _AP_I - l - 1 + HALF_BIAS; ///< exponent\n    int lsb_index = _AP_W - l - 1 - HALF_MAN;\n    // more than 0.5?\n    bool a = (lsb_index >=2) ?\n        (_AP_ROOT_op_get_range(tmp.V, 0, lsb_index - 2) != 0) : 0;\n    // round to even\n    a |= (lsb_index >=0) ? _AP_ROOT_op_get_bit(tmp.V, lsb_index) : 0;\n    // short is at least 16-bit\n    unsigned short m;\n    // may actually left shift, ensure buffer is wide enough.\n    if (_AP_W > BITS) {\n      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))\n                           : (unsigned short)(tmp.V << (1 - lsb_index));\n    } else {\n      m = (unsigned short)tmp.V;\n      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))\n                           : (m << (1 - lsb_index));\n    }\n    m += a;\n    m >>= 1;\n    // carry to MSB, increase exponent\n    if (_AP_ctype_op_get_bit(m, HALF_MAN + 1)) {\n      e += 1;\n    }\n    // set sign and exponent\n    m = _AP_ctype_op_set_bit(m, BITS - 1, s);\n    m = _AP_ctype_op_set_range(m, HALF_MAN, HALF_MAN + HALF_EXP - 1, e);\n    // cast to fp\n    return rawBitsToHalf(m);\n  }\n\n  // FIXME inherited from old code, this may loose precision!\n  INLINE operator long double() const { return (long double)to_double(); }\n\n  INLINE operator double() const { return to_double(); }\n\n  INLINE operator float() const { return to_float(); }\n\n  INLINE operator half() const { return to_half(); }\n\n  INLINE operator bool() const { return (bool)Base::V != 0; }\n\n  INLINE operator char() const { return (char)to_int(); }\n\n  INLINE operator signed char() const { return (signed char)to_int(); }\n\n  INLINE operator unsigned char() const { return (unsigned char)to_uint(); }\n\n  INLINE operator short() const { return (short)to_int(); }\n\n  INLINE operator unsigned short() const { return (unsigned short)to_uint(); }\n\n  INLINE operator int() const { return to_int(); }\n\n  INLINE operator unsigned int() const { return to_uint(); }\n\n// FIXME don't assume data width...\n#ifdef __x86_64__\n  INLINE operator long() const { return (long)to_int64(); }\n\n  INLINE operator unsigned long() const { return (unsigned long)to_uint64(); }\n#else\n  INLINE operator long() const { return (long)to_int(); }\n\n  INLINE operator unsigned long() const { return (unsigned long)to_uint(); }\n#endif // ifdef __x86_64__ else\n\n  INLINE operator ap_ulong() const { return to_uint64(); }\n\n  INLINE operator ap_slong() const { return to_int64(); }\n\n  INLINE int length() const { return _AP_W; };\n\n  // bits_to_int64 deleted.\n#ifndef __SYNTHESIS__\n  // Used in autowrap, when _AP_W < 64.\n  INLINE ap_ulong bits_to_uint64() const {\n    return (Base::V).to_uint64();\n  }\n#endif\n\n  // Count the number of zeros from the most significant bit\n  // to the first one bit. Note this is only for ap_fixed_base whose\n  // _AP_W <= 64, otherwise will incur assertion.\n  INLINE int countLeadingZeros() {\n#ifdef __SYNTHESIS__\n    // TODO: used llvm.ctlz intrinsic ?\n    if (_AP_W <= 32) {\n      ap_int_base<32, false> t(-1ULL);\n      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);\n      return __builtin_ctz(t.V);\n    } else if (_AP_W <= 64) {\n      ap_int_base<64, false> t(-1ULL);\n      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);\n      return __builtin_ctzll(t.V);\n    } else {\n      enum {__N = (_AP_W + 63) / 64};\n      int NZeros = 0;\n      int i = 0;\n      bool hitNonZero = false;\n      for (i = 0; i < __N - 1; ++i) {\n        ap_int_base<64, false> t;\n        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);\n        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);\n        hitNonZero |= (t != 0);\n      }\n      if (!hitNonZero) {\n        ap_int_base<64, false> t(-1ULL);\n        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);\n        NZeros += __builtin_clzll(t.V);\n      }\n      return NZeros;\n    }\n#else\n    return Base::V.countLeadingZeros();\n#endif\n  }\n\n  // Arithmetic : Binary\n  // -------------------------------------------------------------------------\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)\n      const {\n    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;\n    r.V = Base::V;\n    t.V = op2.V;\n    r.V *= op2.V;\n    return r;\n  }\n\n  // multiply function deleted.\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)\n      const {\n    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;\n#ifndef __SYNTHESIS__\n    enum {F2 = _AP_W2-_AP_I2,\n              _W1=AP_MAX(_AP_W + AP_MAX(F2, 0) + ((_AP_S2 && !_AP_S) ? 1 : 0), _AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0))};\n    ap_int_base<_W1,_AP_S||_AP_S2> dividend,divisior;\n    ap_int_base<_W1,_AP_S> tmp1;\n    ap_int_base<_W1,_AP_S2> tmp2;\n    tmp1.V = Base::V;\n    tmp1.V <<= AP_MAX(F2,0);\n    tmp2.V = op2.V;\n    dividend = tmp1;\n    divisior = tmp2;\n    r.V = ((_AP_S||_AP_S2) ? dividend.V.sdiv(divisior.V): dividend.V.udiv(divisior.V));\n#else\n    #ifndef __SC_COMPATIBLE__\n        ap_fixed_base<_AP_W + AP_MAX(_AP_W2 - _AP_I2, 0),_AP_I, _AP_S> t(*this);\n    #else\n        ap_fixed_base<_AP_W + AP_MAX(_AP_W2 - _AP_I2, 0) + AP_MAX(_AP_I2, 0),_AP_I, _AP_S> t(*this);\n    #endif\n        r.V = t.V / op2.V;\n#endif\n/*\n    enum {\n      F2 = _AP_W2 - _AP_I2,\n      shl = AP_MAX(F2, 0) + AP_MAX(_AP_I2, 0),\n#ifndef __SC_COMPATIBLE__\n      shr = AP_MAX(_AP_I2, 0),\n#else\n      shr = 0,\n#endif\n      W3 = _AP_S2 + _AP_W + shl,\n      S3 = _AP_S || _AP_S2,\n    };\n    ap_int_base<W3, S3> dividend, t;\n    dividend.V = Base::V;\n    // multiply both by (1 << F2), and than do integer division.\n    dividend.V <<= (int) shl;\n#ifdef __SYNTHESIS__\n    // .V's have right signedness, and will have right extending.\n    t.V = dividend.V / op2.V;\n#else\n    // XXX op2 may be wider than dividend, and sdiv and udiv takes the same with\n    // as left hand operand, so data might be truncated by mistake if not\n    // handled here.\n    t.V = S3 ? dividend.V.sdiv(op2.V) : dividend.V.udiv(op2.V);\n#endif\n    r.V = t.V >> (int) shr;\n*/\n    return r;\n  }\n\n#define OP_BIN_AF(Sym, Rty)                                                \\\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,         \\\n            ap_o_mode _AP_O2, int _AP_N2>                                  \\\n  INLINE typename RType<_AP_W2, _AP_I2, _AP_S2>::Rty operator Sym(         \\\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& \\\n          op2) const {                                                     \\\n    typename RType<_AP_W2, _AP_I2, _AP_S2>::Rty##_base ret, lhs(*this),    \\\n        rhs(op2);                                                          \\\n    ret.V = lhs.V Sym rhs.V;                                               \\\n    return ret;                                                            \\\n  }\n\n  OP_BIN_AF(+, plus)\n  OP_BIN_AF(-, minus)\n  OP_BIN_AF(&, logic)\n  OP_BIN_AF(|, logic)\n  OP_BIN_AF(^, logic)\n\n// Arithmetic : assign\n// -------------------------------------------------------------------------\n#define OP_ASSIGN_AF(Sym)                                                  \\\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,         \\\n            ap_o_mode _AP_O2, int _AP_N2>                                  \\\n  INLINE ap_fixed_base& operator Sym##=(                                   \\\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& \\\n          op2) {                                                           \\\n    *this = operator Sym(op2);                                             \\\n    return *this;                                                          \\\n  }\n\n  OP_ASSIGN_AF(*)\n  OP_ASSIGN_AF(/)\n  OP_ASSIGN_AF(+)\n  OP_ASSIGN_AF(-)\n  OP_ASSIGN_AF(&)\n  OP_ASSIGN_AF(|)\n  OP_ASSIGN_AF(^)\n\n  // Prefix and postfix increment and decrement.\n  // -------------------------------------------------------------------------\n\n  /// Prefix increment\n  INLINE ap_fixed_base& operator++() {\n    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));\n    return *this;\n  }\n\n  /// Prefix decrement.\n  INLINE ap_fixed_base& operator--() {\n    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));\n    return *this;\n  }\n\n  /// Postfix increment\n  INLINE const ap_fixed_base operator++(int) {\n    ap_fixed_base r(*this);\n    operator++();\n    return r;\n  }\n\n  /// Postfix decrement\n  INLINE const ap_fixed_base operator--(int) {\n    ap_fixed_base r(*this);\n    operator--();\n    return r;\n  }\n\n  // Unary arithmetic.\n  // -------------------------------------------------------------------------\n  INLINE ap_fixed_base operator+() { return *this; }\n\n  INLINE ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {\n    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);\n    r.V = -r.V;\n    return r;\n  }\n\n  INLINE ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {\n    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);\n    r.V = -r.V;\n    return r;\n  }\n\n  // Not (!)\n  // -------------------------------------------------------------------------\n  INLINE bool operator!() const { return Base::V == 0; }\n\n  // Bitwise complement\n  // -------------------------------------------------------------------------\n  // XXX different from Mentor's ac_fixed.\n  INLINE ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {\n    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;\n    r.V = ~Base::V;\n    return r;\n  }\n\n  // Shift\n  // -------------------------------------------------------------------------\n  // left shift is the same as moving point right, i.e. increate I.\n  template <int _AP_SHIFT>\n  INLINE ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {\n    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;\n    r.V = Base::V;\n    return r;\n  }\n\n  template <int _AP_SHIFT>\n  INLINE ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {\n    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;\n    r.V = Base::V;\n    return r;\n  }\n\n  // Because the return type is the type of the the first operand, shift assign\n  // operators do not carry out any quantization or overflow\n  // While systemc, shift assigns for sc_fixed/sc_ufixed will result in\n  // quantization or overflow (depending on the mode of the first operand)\n  INLINE ap_fixed_base operator<<(unsigned int sh) const {\n    ap_fixed_base r;\n    r.V = Base::V << sh;\n// TODO check shift overflow?\n#ifdef __SC_COMPATIBLE__\n    if (sh == 0) return r;\n    if (_AP_O != AP_WRAP || _AP_N != 0) {\n      bool neg_src = _AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1);\n      bool allones, allzeros;\n      ap_int_base<_AP_W, false> ones(-1);\n      if (sh <= _AP_W) {\n        ap_int_base<_AP_W, false> range1;\n        range1.V = _AP_ROOT_op_get_range(\n            const_cast<ap_fixed_base*>(this)->Base::V, _AP_W - sh, _AP_W - 1);\n        allones = range1 == (ones >> (_AP_W - sh));\n        allzeros = range1 == 0;\n      } else {\n        allones = false;\n        allzeros = Base::V == 0;\n      }\n      bool overflow = !allzeros && !neg_src;\n      bool underflow = !allones && neg_src;\n      if ((_AP_O == AP_SAT_SYM) && _AP_S)\n        underflow |=\n            neg_src &&\n            (_AP_W > 1 ? _AP_ROOT_op_get_range(r.V, 0, _AP_W - 2) == 0 : true);\n      bool lD = false;\n      if (sh < _AP_W) lD = _AP_ROOT_op_get_bit(Base::V, _AP_W - sh - 1);\n      r.overflow_adjust(underflow, overflow, lD, neg_src);\n    }\n#endif\n    return r;\n  }\n\n  INLINE ap_fixed_base operator>>(unsigned int sh) const {\n    ap_fixed_base r;\n    r.V = Base::V >> sh;\n// TODO check shift overflow?\n#ifdef __SC_COMPATIBLE__\n    if (sh == 0) return r;\n    if (_AP_Q != AP_TRN) {\n      bool qb = false;\n      if (sh <= _AP_W) qb = _AP_ROOT_op_get_bit(Base::V, sh - 1);\n      bool rb = false;\n      if (sh > 1 && sh <= _AP_W)\n        rb = _AP_ROOT_op_get_range(const_cast<ap_fixed_base*>(this)->Base::V, 0,\n                                   sh - 2) != 0;\n      else if (sh > _AP_W)\n        rb = Base::V != 0;\n      r.quantization_adjust(qb, rb,\n                            _AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1));\n    }\n#endif\n    return r;\n  }\n\n  // left and right shift for int\n  INLINE ap_fixed_base operator<<(int sh) const {\n    ap_fixed_base r;\n    bool isNeg = sh < 0;\n    unsigned int ush = isNeg ? -sh : sh;\n    if (isNeg) {\n      return operator>>(ush);\n    } else {\n      return operator<<(ush);\n    }\n  }\n\n  INLINE ap_fixed_base operator>>(int sh) const {\n    bool isNeg = sh < 0;\n    unsigned int ush = isNeg ? -sh : sh;\n    if (isNeg) {\n      return operator<<(ush);\n    } else {\n      return operator>>(ush);\n    }\n  }\n\n  // left and right shift for ap_int.\n  template <int _AP_W2>\n  INLINE ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {\n    // TODO the code seems not optimal. ap_fixed<8,8> << ap_int<2> needs only a\n    // small mux, but integer need a big one!\n    int sh = op2.to_int();\n    return operator<<(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {\n    int sh = op2.to_int();\n    return operator>>(sh);\n  }\n\n  // left and right shift for ap_uint.\n  template <int _AP_W2>\n  INLINE ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {\n    unsigned int sh = op2.to_uint();\n    return operator<<(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {\n    unsigned int sh = op2.to_uint();\n    return operator>>(sh);\n  }\n\n  // left and right shift for ap_fixed\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base operator<<(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          op2) {\n    return operator<<(op2.to_ap_int_base());\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base operator>>(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          op2) {\n    return operator>>(op2.to_ap_int_base());\n  }\n\n  // Shift assign.\n  // -------------------------------------------------------------------------\n\n  // left shift assign.\n  INLINE ap_fixed_base& operator<<=(const int sh) {\n    *this = operator<<(sh);\n    return *this;\n  }\n\n  INLINE ap_fixed_base& operator<<=(const unsigned int sh) {\n    *this = operator<<(sh);\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {\n    *this = operator<<(sh.to_int());\n    return *this;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base& operator<<=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          sh) {\n    *this = operator<<(sh.to_int());\n    return *this;\n  }\n\n  // right shift assign.\n  INLINE ap_fixed_base& operator>>=(const int sh) {\n    *this = operator>>(sh);\n    return *this;\n  }\n\n  INLINE ap_fixed_base& operator>>=(const unsigned int sh) {\n    *this = operator>>(sh);\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {\n    *this = operator>>(sh.to_int());\n    return *this;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed_base& operator>>=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          sh) {\n    *this = operator>>(sh.to_int());\n    return *this;\n  }\n\n// Comparisons.\n// -------------------------------------------------------------------------\n#define OP_CMP_AF(Sym)                                                         \\\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,             \\\n            ap_o_mode _AP_O2, int _AP_N2>                                      \\\n  INLINE bool operator Sym(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, \\\n                                               _AP_O2, _AP_N2>& op2) const {   \\\n    enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 };                      \\\n    if (_AP_F == F2)                                                           \\\n      return Base::V Sym op2.V;                                                \\\n    else if (_AP_F > F2)                                                       \\\n      return Base::V Sym ap_fixed_base<AP_MAX(_AP_W2 + _AP_F - F2, 1), _AP_I2, \\\n                                       _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; \\\n    else                                                                       \\\n      return ap_fixed_base<AP_MAX(_AP_W + F2 - _AP_F + 1, 1), _AP_I + 1,       \\\n                           _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V Sym op2.V;     \\\n    return false;                                                              \\\n  }\n\n  OP_CMP_AF(>)\n  OP_CMP_AF(<)\n  OP_CMP_AF(>=)\n  OP_CMP_AF(<=)\n  OP_CMP_AF(==)\n  OP_CMP_AF(!=)\n// FIXME: Move compare with double out of struct ap_fixed_base defination\n//        and combine it with compare operator(double, ap_fixed_base)\n#define DOUBLE_CMP_AF(Sym) \\\n  INLINE bool operator Sym(double d) const { return to_double() Sym d; }\n\n  DOUBLE_CMP_AF(>)\n  DOUBLE_CMP_AF(<)\n  DOUBLE_CMP_AF(>=)\n  DOUBLE_CMP_AF(<=)\n  DOUBLE_CMP_AF(==)\n  DOUBLE_CMP_AF(!=)\n\n  // Bit and Slice Select\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](\n      unsigned index) {\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](\n      const ap_int_base<_AP_W2, _AP_S2>& index) {\n    _AP_WARNING(index < 0, \"Attempting to read bit with negative index\");\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,\n                                                                index.to_int());\n  }\n\n  INLINE bool operator[](unsigned index) const {\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return _AP_ROOT_op_get_bit(const_cast<ap_fixed_base*>(this)->V, index);\n  }\n\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(\n      unsigned index) {\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(\n      const ap_int_base<_AP_W2, _AP_S2>& index) {\n    _AP_WARNING(index < 0, \"Attempting to read bit with negative index\");\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,\n                                                                index.to_int());\n  }\n\n  INLINE bool bit(unsigned index) const {\n    _AP_WARNING(index >= _AP_W, \"Attempting to read bit beyond MSB\");\n    return _AP_ROOT_op_get_bit(const_cast<ap_fixed_base*>(this)->V, index);\n  }\n\n  template <int _AP_W2>\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(\n      const ap_int_base<_AP_W2, true>& index) {\n    _AP_WARNING(index < _AP_I - _AP_W,\n                \"Attempting to read bit with negative index\");\n    _AP_WARNING(index >= _AP_I, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(\n        this, index.to_int() + _AP_W - _AP_I);\n  }\n\n  INLINE bool get_bit(int index) const {\n    _AP_WARNING(index >= _AP_I, \"Attempting to read bit beyond MSB\");\n    _AP_WARNING(index < _AP_I - _AP_W, \"Attempting to read bit beyond MSB\");\n    return _AP_ROOT_op_get_bit(const_cast<ap_fixed_base*>(this)->V,\n                               index + _AP_W - _AP_I);\n  }\n#if 0\n  INLINE af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(\n      int index) {\n    _AP_WARNING(index < _AP_I - _AP_W,\n              \"Attempting to read bit with negative index\");\n    _AP_WARNING(index >= _AP_I, \"Attempting to read bit beyond MSB\");\n    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(\n        this, index + _AP_W - _AP_I);\n  }\n#endif\n\n  template <int _AP_W2>\n  INLINE bool get_bit(const ap_int_base<_AP_W2, true>& index) const {\n    _AP_WARNING(index >= _AP_I, \"Attempting to read bit beyond MSB\");\n    _AP_WARNING(index < _AP_I - _AP_W, \"Attempting to read bit beyond MSB\");\n    return _AP_ROOT_op_get_bit(const_cast<ap_fixed_base*>(this)->V,\n                               index.to_int() + _AP_W - _AP_I);\n  }\n\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,\n                                                                      int Lo) {\n    _AP_WARNING((Hi >= _AP_W) || (Lo >= _AP_W), \"Out of bounds in range()\");\n    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);\n  }\n\n  // This is a must to strip constness to produce reference type.\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(\n      int Hi, int Lo) const {\n    _AP_WARNING((Hi >= _AP_W) || (Lo >= _AP_W), \"Out of bounds in range()\");\n    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(\n        const_cast<ap_fixed_base*>(this), Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {\n    return this->range(_AP_W - 1, 0);\n  }\n\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {\n    return this->range(_AP_W - 1, 0);\n  }\n\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(\n      int Hi, int Lo) {\n    return this->range(Hi, Lo);\n  }\n\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(\n      int Hi, int Lo) const {\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  INLINE bool is_zero() const { return Base::V == 0; }\n\n  INLINE bool is_neg() const {\n    if (_AP_S && _AP_ROOT_op_get_bit(Base::V, _AP_W - 1)) return true;\n    return false;\n  }\n\n  INLINE int wl() const { return _AP_W; }\n\n  INLINE int iwl() const { return _AP_I; }\n\n  INLINE ap_q_mode q_mode() const { return _AP_Q; }\n\n  INLINE ap_o_mode o_mode() const { return _AP_O; }\n\n  INLINE int n_bits() const { return _AP_N; }\n\n  // print a string representation of this number in the given radix.\n  // Radix support is 2, 8, 10, or 16.\n  // The result will include a prefix indicating the radix, except for decimal,\n  // where no prefix is needed.  The default is to output a signed representation\n  // of signed numbers, or an unsigned representation  of unsigned numbers.  For\n  // non-decimal formats, this can be changed by the 'sign' argument.\n#ifndef __SYNTHESIS__\n  std::string to_string(unsigned char radix = 2, bool sign = _AP_S) const {\n    // XXX in autosim/autowrap.tcl \"(${name}).to_string(2).c_str()\" is used to\n    // initialize sc_lv, which seems incapable of handling format \"-0b\".\n    if (radix == 2) sign = false;\n\n    std::string str;\n    str.clear();\n    char step = 0;\n    bool isNeg = sign && (Base::V < 0);\n\n    // Extend to take care of the -MAX case.\n    ap_fixed_base<_AP_W + 1, _AP_I + 1> tmp(*this);\n    if (isNeg) {\n      tmp = -tmp;\n      str += '-';\n    }\n    std::string prefix;\n    switch (radix) {\n      case 2:\n        prefix = \"0b\";\n        step = 1;\n        break;\n      case 8:\n        prefix = \"0o\";\n        step = 3;\n        break;\n      case 16:\n        prefix = \"0x\";\n        step = 4;\n        break;\n      default:\n        break;\n    }\n\n    if (_AP_I > 0) {\n      // Note we drop the quantization and rounding flags here.  The\n      // integer part is always in range, and the fractional part we\n      // want to drop.  Also, the number is always positive, because\n      // of the absolute value above.\n      ap_int_base<AP_MAX(_AP_I + 1, 1), false> int_part;\n      //   [1] [ I ] d [ W - I ]\n      //    |     |            |\n      //    |    W-I           0\n      //    W\n      int_part.V = _AP_ROOT_op_get_range(\n          tmp.V, _AP_W - _AP_I, _AP_W);\n      str += int_part.to_string(radix, false);\n    } else {\n      str += prefix;\n      str += '0';\n    }\n\n    ap_fixed_base<AP_MAX(_AP_W - _AP_I, 1), 0, false> frac_part = tmp;\n\n    if (radix == 10) {\n      if (frac_part != 0) {\n        str += \".\";\n        while (frac_part != 0) {\n          char digit = (frac_part * radix).to_char();\n          str += static_cast<char>(digit + '0');\n          frac_part *= radix;\n        }\n      }\n    } else {\n      if (frac_part != 0) {\n        str += \".\";\n        for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {\n          char digit = frac_part.range(i, AP_MAX(0, i - step + 1)).to_char();\n          // If we have a partial bit pattern at the end, then we need\n          // to put it in the high-order bits of 'digit'.\n          int offset = AP_MIN(0, i - step + 1);\n          digit <<= -offset;\n          str += digit < 10 ? static_cast<char>(digit + '0')\n                            : static_cast<char>(digit - 10 + 'a');\n        }\n        if (radix == 16)\n          str += \"p0\"; // C99 Hex constants are required to have an exponent.\n      }\n    }\n    return str;\n  }\n#else\n  // XXX HLS will delete this in synthesis\n  INLINE char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {\n    return 0;\n  }\n#endif\n}; // struct ap_fixed_base.\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE void b_not(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {\n  ret.V = ~op.V;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE void b_and(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  ret.V = op1.V & op2.V;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE void b_or(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  ret.V = op1.V | op2.V;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE void b_xor(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  ret.V = op1.V ^ op2.V;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n          ap_o_mode _AP_O2, int _AP_N2>\nINLINE void neg(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,\n                _AP_N2>\n      t;\n  t.V = -op.V;\n  ret = t;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n          ap_o_mode _AP_O2, int _AP_N2>\nINLINE void lshift(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,\n    int i) {\n  enum {\n    F2 = _AP_W2 - _AP_I2,\n    _AP_I3 = AP_MAX(_AP_I, _AP_I2),\n    _AP_W3 = _AP_I3 + F2,\n  };\n  // wide buffer\n  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;\n  t.V = op.V;\n  t.V <<= i; // FIXME overflow?\n  // handle quantization and overflow\n  ret = t;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n          ap_o_mode _AP_O2, int _AP_N2>\nINLINE void rshift(\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,\n    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,\n    int i) {\n  enum {\n    F = _AP_W - _AP_I,\n    F2 = _AP_W2 - _AP_I2,\n    F3 = AP_MAX(F, F2),\n    _AP_W3 = _AP_I2 + F3,\n    sh = F - F2,\n  };\n  // wide buffer\n  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;\n  t.V = op.V;\n  if (sh >= 0)\n    t.V <<= (int) sh;\n  t.V >>= i;\n  // handle quantization and overflow\n  ret = t;\n}\n\n//// FIXME\n//// These partial specialization ctors allow code like\n////   char c = 'a';\n////   ap_fixed_base<8, 8, true> x(c);\n//// but what bout ap_fixed_base<9, 9, true> y(c) ?\n//\n\n#ifndef __SYNTHESIS__\nINLINE std::string scientificFormat(std::string& input) {\n  if (input.length() == 0) return input;\n\n  size_t decPosition = input.find('.');\n  if (decPosition == std::string::npos) decPosition = input.length();\n\n  size_t firstNonZeroPos = 0;\n  for (; input[firstNonZeroPos] > '9' || input[firstNonZeroPos] < '1';\n       firstNonZeroPos++)\n    ;\n\n  int exp;\n  if (firstNonZeroPos > decPosition)\n    exp = decPosition - firstNonZeroPos;\n  else\n    exp = decPosition - firstNonZeroPos - 1;\n  std::string expString = \"\";\n  if (exp == 0)\n    ;\n  else if (exp < 0) {\n    expString += \"e-\";\n    exp = -exp;\n  } else\n    expString += \"e+\";\n\n  if (exp < 10 && exp > 0) {\n    expString += '0';\n    expString += (char)('0' + exp);\n  } else if (exp != 0) {\n    std::string tmp;\n\n    std::ostringstream oss;\n    oss << exp;\n\n    tmp = oss.str();\n    expString += tmp;\n  }\n\n  int lastNonZeroPos = (int)(input.length() - 1);\n  for (; lastNonZeroPos >= 0; --lastNonZeroPos)\n    if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0') break;\n\n  std::string ans = \"\";\n  ans += input[firstNonZeroPos];\n  if (firstNonZeroPos != (size_t)lastNonZeroPos) {\n    ans += '.';\n    for (int i = firstNonZeroPos + 1; i <= lastNonZeroPos; i++)\n      if (input[i] != '.') ans += input[i];\n  }\n\n  ans += expString;\n  return ans;\n}\n\nINLINE std::string reduceToPrecision(std::string& input, int precision) {\n  bool isZero = true;\n  size_t inputLen = input.length();\n  for (size_t i = 0; i < inputLen && isZero; i++)\n    if (input[i] != '.' && input[i] != '0') isZero = false;\n  if (isZero) return \"0\";\n\n  // Find the first valid number, skip '-'\n  int FirstNonZeroPos = 0;\n  int LastNonZeroPos = (int)inputLen - 1;\n  int truncBitPosition = 0;\n  size_t decPosition = input.find('.');\n  for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';\n       FirstNonZeroPos++)\n    ;\n\n  for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';\n       LastNonZeroPos--)\n    ;\n\n  if (decPosition == std::string::npos) decPosition = inputLen;\n  // Count the valid number, to decide whether we need to truncate\n  if ((int)decPosition > LastNonZeroPos) {\n    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) return input;\n    truncBitPosition = FirstNonZeroPos + precision;\n  } else if ((int)decPosition < FirstNonZeroPos) { // This is pure decimal\n    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {\n      if (FirstNonZeroPos - decPosition - 1 < 4) {\n        return input;\n      } else {\n        if (input[0] == '-') {\n          std::string tmp = input.substr(1, inputLen - 1);\n          return std::string(\"-\") + scientificFormat(tmp);\n        } else\n          return scientificFormat(input);\n      }\n    }\n    truncBitPosition = FirstNonZeroPos + precision;\n  } else {\n    if (LastNonZeroPos - FirstNonZeroPos <= precision) return input;\n    truncBitPosition = FirstNonZeroPos + precision + 1;\n  }\n\n  // duplicate the input string, we want to add \"0\" before the valid numbers\n  // This is easy for quantization, since we may change 9999 to 10000\n  std::string ans = \"\";\n  std::string dupInput = \"0\";\n  if (input[0] == '-') {\n    ans += '-';\n    dupInput += input.substr(1, inputLen - 1);\n  } else {\n    dupInput += input.substr(0, inputLen);\n    ++truncBitPosition;\n  }\n\n  // Add 'carry' after truncation, if necessary\n  bool carry = dupInput[truncBitPosition] > '4';\n  for (int i = truncBitPosition - 1; i >= 0 && carry; i--) {\n    if (dupInput[i] == '.') continue;\n    if (dupInput[i] == '9')\n      dupInput[i] = '0';\n    else {\n      ++dupInput[i];\n      carry = false;\n    }\n  }\n\n  // bits outside precision range should be set to 0\n  if (dupInput[0] == '1')\n    FirstNonZeroPos = 0;\n  else {\n    FirstNonZeroPos = 0;\n    while (dupInput[FirstNonZeroPos] < '1' || dupInput[FirstNonZeroPos] > '9')\n      ++FirstNonZeroPos;\n  }\n\n  unsigned it = FirstNonZeroPos;\n  int NValidNumber = 0;\n  while (it < dupInput.length()) {\n    if (dupInput[it] == '.') {\n      ++it;\n      continue;\n    }\n    ++NValidNumber;\n    if (NValidNumber > precision) dupInput[it] = '0';\n    ++it;\n  }\n\n  // Here we wanted to adjust the truncate position and the value\n  decPosition = dupInput.find('.');\n  if (decPosition == std::string::npos) // When this is integer\n    truncBitPosition = (int)dupInput.length();\n  else\n    for (truncBitPosition = (int)(dupInput.length() - 1); truncBitPosition >= 0;\n         --truncBitPosition) {\n      if (dupInput[truncBitPosition] == '.') break;\n      if (dupInput[truncBitPosition] != '0') {\n        truncBitPosition++;\n        break;\n      }\n    }\n\n  if (dupInput[0] == '1')\n    dupInput = dupInput.substr(0, truncBitPosition);\n  else\n    dupInput = dupInput.substr(1, truncBitPosition - 1);\n\n  decPosition = dupInput.find('.');\n  if (decPosition != std::string::npos) {\n    size_t it = 0;\n    for (it = decPosition + 1; dupInput[it] == '0'; it++)\n      ;\n    if (it - decPosition - 1 < 4) {\n      ans += dupInput;\n      return ans;\n    } else {\n      ans += scientificFormat(dupInput);\n      return ans;\n    }\n  } else if ((int)(dupInput.length()) <= precision) {\n    ans += dupInput;\n    return ans;\n  }\n\n  ans += scientificFormat(dupInput);\n  return ans;\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE void print(\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {\n  if (_AP_I > 0) {\n    ap_int_base<_AP_I, _AP_S> p1;\n    p1.V = x.V >> (_AP_W - _AP_I);\n    print(p1.V); // print overlaod for .V should exit\n  } else {\n    printf(\"0\");\n  }\n  printf(\".\");\n  if (_AP_I < _AP_W) {\n    ap_int_base<_AP_W - _AP_I, false> p2;\n    p2.V = _AP_ROOT_op_get_range(x.V, 0, _AP_W - _AP_I);\n    print(p2.V, false); // print overlaod for .V should exit\n  }\n}\n#endif // ifndef __SYNTHESIS__\n\n// XXX the following two functions have to exist in synthesis,\n// as some old HLS Video Library code uses the ostream overload,\n// although HLS will later delete I/O function call.\n\n/// Output streaming\n//-----------------------------------------------------------------------------\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE std::ostream& operator<<(\n    std::ostream& out,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {\n  // TODO support std::ios_base::fmtflags\n  unsigned width = out.width();\n  unsigned precision = out.precision();\n  char fill = out.fill();\n  std::string str = x.to_string(10, _AP_S);\n  str = reduceToPrecision(str, precision);\n  if (width > str.length()) {\n    for (unsigned i = 0; i < width - str.length(); ++i)\n      out << fill;\n  }\n  out << str;\n  return out;\n}\n#endif // ifndef __SYNTHESIS__\n\n/// Input streaming\n// -----------------------------------------------------------------------------\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE std::istream& operator>>(\n    std::istream& in,\n    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {\n  double d;\n  in >> d;\n  x = ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(d);\n  return in;\n}\n#endif\n#endif // ifndef AP_AUTOCC\n\n/// Operators mixing Integers with ap_fixed_base\n// -----------------------------------------------------------------------------\n#define AF_BIN_OP_WITH_INT_SF(BIN_OP, C_TYPE, _AP_W2, _AP_S2, RTYPE)     \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,           \\\n            ap_o_mode _AP_O, int _AP_N>                                  \\\n  INLINE typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<    \\\n      _AP_W2, _AP_W2, _AP_S2>::RTYPE                                     \\\n  operator BIN_OP(                                                       \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, \\\n      C_TYPE i_op) {                                                     \\\n    return op.operator BIN_OP(ap_int_base<_AP_W2, _AP_S2>(i_op));        \\\n  }\n\n#define AF_BIN_OP_WITH_INT(BIN_OP, C_TYPE, _AP_W2, _AP_S2, RTYPE)           \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<       \\\n      _AP_W2, _AP_W2, _AP_S2>::RTYPE                                        \\\n  operator BIN_OP(                                                          \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,    \\\n      C_TYPE i_op) {                                                        \\\n    return op.operator BIN_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<       \\\n      _AP_W2, _AP_W2, _AP_S2>::RTYPE                                        \\\n  operator BIN_OP(                                                          \\\n      C_TYPE i_op,                                                          \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {  \\\n    return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator BIN_OP(op); \\\n  }\n\n#define AF_REL_OP_WITH_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)                  \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE bool operator REL_OP(                                              \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,    \\\n      C_TYPE i_op) {                                                        \\\n    return op.operator REL_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE bool operator REL_OP(                                              \\\n      C_TYPE i_op,                                                          \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {  \\\n    return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator REL_OP(op); \\\n  }\n\n#define AF_ASSIGN_OP_WITH_INT(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2)               \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,                 \\\n            ap_o_mode _AP_O, int _AP_N>                                        \\\n  INLINE ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>&              \\\n  operator ASSIGN_OP(                                                          \\\n      ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,             \\\n      C_TYPE i_op) {                                                           \\\n    return op.operator ASSIGN_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }\n\n#define AF_ASSIGN_OP_WITH_INT_SF(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2)  \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,       \\\n            ap_o_mode _AP_O, int _AP_N>                              \\\n  INLINE ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>&    \\\n  operator ASSIGN_OP(                                                \\\n      ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,   \\\n      C_TYPE i_op) {                                                 \\\n    return op.operator ASSIGN_OP(ap_int_base<_AP_W2, _AP_S2>(i_op)); \\\n  }\n\n#define ALL_AF_OP_WITH_INT(C_TYPE, BITS, SIGN)               \\\n  AF_BIN_OP_WITH_INT(+, C_TYPE, (BITS), (SIGN), plus)     \\\n  AF_BIN_OP_WITH_INT(-, C_TYPE, (BITS), (SIGN), minus)    \\\n  AF_BIN_OP_WITH_INT(*, C_TYPE, (BITS), (SIGN), mult)     \\\n  AF_BIN_OP_WITH_INT(/, C_TYPE, (BITS), (SIGN), div)      \\\n  AF_BIN_OP_WITH_INT(&, C_TYPE, (BITS), (SIGN), logic)    \\\n  AF_BIN_OP_WITH_INT(|, C_TYPE, (BITS), (SIGN), logic)    \\\n  AF_BIN_OP_WITH_INT(^, C_TYPE, (BITS), (SIGN), logic)    \\\n  AF_BIN_OP_WITH_INT_SF(>>, C_TYPE, (BITS), (SIGN), lhs)  \\\n  AF_BIN_OP_WITH_INT_SF(<<, C_TYPE, (BITS), (SIGN), lhs)  \\\n                                                          \\\n  AF_ASSIGN_OP_WITH_INT(+=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(-=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(*=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(/=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(&=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(|=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT(^=, C_TYPE, (BITS), (SIGN))     \\\n  AF_ASSIGN_OP_WITH_INT_SF(>>=, C_TYPE, (BITS), (SIGN)) \\\n  AF_ASSIGN_OP_WITH_INT_SF(<<=, C_TYPE, (BITS), (SIGN)) \\\n                                                          \\\n  AF_REL_OP_WITH_INT(>, C_TYPE, (BITS), (SIGN))           \\\n  AF_REL_OP_WITH_INT(<, C_TYPE, (BITS), (SIGN))           \\\n  AF_REL_OP_WITH_INT(>=, C_TYPE, (BITS), (SIGN))          \\\n  AF_REL_OP_WITH_INT(<=, C_TYPE, (BITS), (SIGN))          \\\n  AF_REL_OP_WITH_INT(==, C_TYPE, (BITS), (SIGN))          \\\n  AF_REL_OP_WITH_INT(!=, C_TYPE, (BITS), (SIGN))\n\nALL_AF_OP_WITH_INT(bool, 1, false)\nALL_AF_OP_WITH_INT(char, 8, CHAR_IS_SIGNED)\nALL_AF_OP_WITH_INT(signed char, 8, true)\nALL_AF_OP_WITH_INT(unsigned char, 8, false)\nALL_AF_OP_WITH_INT(short, _AP_SIZE_short, true)\nALL_AF_OP_WITH_INT(unsigned short, _AP_SIZE_short, false)\nALL_AF_OP_WITH_INT(int, _AP_SIZE_int, true)\nALL_AF_OP_WITH_INT(unsigned int, _AP_SIZE_int, false)\nALL_AF_OP_WITH_INT(long, _AP_SIZE_long, true)\nALL_AF_OP_WITH_INT(unsigned long, _AP_SIZE_long, false)\nALL_AF_OP_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nALL_AF_OP_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef ALL_AF_OP_WITH_INT\n#undef AF_BIN_OP_WITH_INT\n#undef AF_BIN_OP_WITH_INT_SF\n#undef AF_ASSIGN_OP_WITH_INT\n#undef AF_ASSIGN_OP_WITH_INT_SF\n#undef AF_REL_OP_WITH_INT\n\n/*\n * **********************************************************************\n * TODO\n * There is no operator defined with float/double/long double, so that\n * code like\n *   ap_fixed<8,4> a = 1.5f;\n *   a += 0.5f;\n * will fail in compilation.\n * Operator with warning about conversion might be wanted.\n * **********************************************************************\n */\n\n#define AF_BIN_OP_WITH_AP_INT(BIN_OP, RTYPE)                                \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>            \\\n  INLINE typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType<    \\\n      _AP_W, _AP_I, _AP_S>::RTYPE                                           \\\n  operator BIN_OP(                                                          \\\n      const ap_int_base<_AP_W2, _AP_S2>& i_op,                              \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {  \\\n    return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator BIN_OP(op); \\\n  }                                                                         \\\n                                                                            \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>            \\\n  INLINE typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<       \\\n      _AP_W2, _AP_W2, _AP_S2>::RTYPE                                        \\\n  operator BIN_OP(                                                          \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,    \\\n      const ap_int_base<_AP_W2, _AP_S2>& i_op) {                            \\\n    return op.operator BIN_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }\n\n#define AF_REL_OP_WITH_AP_INT(REL_OP)                                       \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>            \\\n  INLINE bool operator REL_OP(                                              \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,    \\\n      const ap_int_base<_AP_W2, _AP_S2>& i_op) {                            \\\n    return op.operator REL_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }                                                                         \\\n                                                                            \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>            \\\n  INLINE bool operator REL_OP(                                              \\\n      const ap_int_base<_AP_W2, _AP_S2>& i_op,                              \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {  \\\n    return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator REL_OP(op); \\\n  }\n\n#define AF_ASSIGN_OP_WITH_AP_INT(ASSIGN_OP)                                    \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,                 \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>               \\\n  INLINE ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>&              \\\n  operator ASSIGN_OP(                                                          \\\n      ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,             \\\n      const ap_int_base<_AP_W2, _AP_S2>& i_op) {                               \\\n    return op.operator ASSIGN_OP(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); \\\n  }                                                                            \\\n                                                                               \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,                 \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>               \\\n  INLINE ap_int_base<_AP_W2, _AP_S2>& operator ASSIGN_OP(                      \\\n      ap_int_base<_AP_W2, _AP_S2>& i_op,                                       \\\n      const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {     \\\n    return i_op.operator ASSIGN_OP(op.to_ap_int_base());                       \\\n  }\n\nAF_BIN_OP_WITH_AP_INT(+, plus)\nAF_BIN_OP_WITH_AP_INT(-, minus)\nAF_BIN_OP_WITH_AP_INT(*, mult)\nAF_BIN_OP_WITH_AP_INT(/, div)\nAF_BIN_OP_WITH_AP_INT(&, logic)\nAF_BIN_OP_WITH_AP_INT(|, logic)\nAF_BIN_OP_WITH_AP_INT(^, logic)\n\n#undef AF_BIN_OP_WITH_AP_INT\n\nAF_ASSIGN_OP_WITH_AP_INT(+=)\nAF_ASSIGN_OP_WITH_AP_INT(-=)\nAF_ASSIGN_OP_WITH_AP_INT(*=)\nAF_ASSIGN_OP_WITH_AP_INT(/=)\nAF_ASSIGN_OP_WITH_AP_INT(&=)\nAF_ASSIGN_OP_WITH_AP_INT(|=)\nAF_ASSIGN_OP_WITH_AP_INT(^=)\n\n#undef AF_ASSIGN_OP_WITH_AP_INT\n\nAF_REL_OP_WITH_AP_INT(==)\nAF_REL_OP_WITH_AP_INT(!=)\nAF_REL_OP_WITH_AP_INT(>)\nAF_REL_OP_WITH_AP_INT(>=)\nAF_REL_OP_WITH_AP_INT(<)\nAF_REL_OP_WITH_AP_INT(<=)\n\n#undef AF_REL_OP_WITH_AP_INT\n\n// Relational Operators with double\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator==(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator==(op1);\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator!=(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator!=(op1);\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator>(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator<(op1);\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator>=(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator<=(op1);\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator<(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator>(op1);\n}\n\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE bool operator<=(\n    double op1,\n    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {\n  return op2.operator>=(op1);\n}\n\n#endif // ifndef __cplusplus else\n\n#endif // ifndef __AP_FIXED_BASE_H__ else\n\n// -*- cpp -*-\n\n\n",
    "gmp.h": "/* Definitions for GNU multiple precision functions.   -*- mode: c -*-\n\nCopyright 1991, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003,\n2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n\nCopyright 2008 William Hart, Gonzalo Tornaria\n\nThis file is part of the MPIR Library.\n\nThe MPIR Library is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or (at your\noption) any later version.\n\nThe MPIR Library is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\nLicense for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with the GNU MP Library.  If not, see http://www.gnu.org/licenses/.  */\n\n#ifndef __GMP_H__\n\n#if defined (__cplusplus)\n#include \"iosfwd\"   /* for std::istream, std::ostream, std::string */\n#include \"cstdio\"\n#endif\n\n\n/* Instantiated by configure. */\n#if ! defined (__GMP_WITHIN_CONFIGURE)\n#define __GMP_BITS_PER_MP_LIMB             64\n#define __GMP_HAVE_HOST_CPU_FAMILY_power   0\n#define __GMP_HAVE_HOST_CPU_FAMILY_powerpc 0\n#define GMP_LIMB_BITS                      64\n#define GMP_NAIL_BITS                      0\n#endif\n#define GMP_NUMB_BITS     (GMP_LIMB_BITS - GMP_NAIL_BITS)\n#define GMP_NUMB_MASK     ((~ __GMP_CAST (mp_limb_t, 0)) >> GMP_NAIL_BITS)\n#define GMP_NUMB_MAX      GMP_NUMB_MASK\n#define GMP_NAIL_MASK     (~ GMP_NUMB_MASK)\n\n\n/* The following (everything under ifndef __GNU_MP__) must be identical in\n   mpir.h and mp.h to allow both to be included in an application or during\n   the library build.  */\n#ifndef __GNU_MP__\n#define __GNU_MP__ 4\n\n#define __need_size_t  /* tell gcc stddef.h we only want size_t */\n#if defined (__cplusplus)\n#include \"cstddef\"     /* for size_t */\n#else\n#include \"stddef.h\"    /* for size_t */\n#endif\n#undef __need_size_t\n\n/* Instantiated by configure. */\n#if ! defined (__GMP_WITHIN_CONFIGURE)\n/* #undef _LONG_LONG_LIMB */\n#define __GMP_LIBGMP_DLL  0\n#endif\n\n/*  #if defined(__GMP_WITHIN_CONFIGURE) && defined(_WIN64)   */\n#ifdef __WIN64\n#define _LONG_LONG_LIMB\t1\n#endif\n\n\n/* __STDC__ - some ANSI compilers define this only to 0, hence the use of\n       \"defined\" and not \"__STDC__-0\".  In particular Sun workshop C 5.0\n       sets __STDC__ to 0, but requires \"##\" for token pasting.\n\n   _AIX - gnu ansidecl.h asserts that all known AIX compilers are ANSI but\n       don't always define __STDC__.\n\n   __DECC - current versions of DEC C (5.9 for instance) for alpha are ANSI,\n       but don't define __STDC__ in their default mode.  Don't know if old\n       versions might have been K&R, but let's not worry about that unless\n       someone is still using one.\n\n   _mips - gnu ansidecl.h says the RISC/OS MIPS compiler is ANSI in SVR4\n       mode, but doesn't define __STDC__.\n\n   _MSC_VER - Microsoft C is ANSI, but __STDC__ is undefined unless the /Za\n       option is given (in which case it's 1).\n\n   _WIN32 - tested for by gnu ansidecl.h, no doubt on the assumption that\n      all w32 compilers are ansi.\n\n   Note: This same set of tests is used by gen-psqr.c and\n   demos/expr/expr-impl.h, so if anything needs adding, then be sure to\n   update those too.  */\n\n#if  defined (__STDC__)                                 \\\n  || defined (__cplusplus)                              \\\n  || defined (_AIX)                                     \\\n  || defined (__DECC)                                   \\\n  || (defined (__mips) && defined (_SYSTYPE_SVR4))      \\\n  || defined (_MSC_VER)                                 \\\n  || defined (_WIN32)\n#define __GMP_HAVE_CONST        1\n#define __GMP_HAVE_PROTOTYPES   1\n#define __GMP_HAVE_TOKEN_PASTE  1\n#else\n#define __GMP_HAVE_CONST        0\n#define __GMP_HAVE_PROTOTYPES   0\n#define __GMP_HAVE_TOKEN_PASTE  0\n#endif\n\n\n#if __GMP_HAVE_CONST\n#define __gmp_const   const\n#define __gmp_signed  signed\n#else\n#define __gmp_const\n#define __gmp_signed\n#endif\n\n\n/* __GMP_DECLSPEC supports Windows DLL versions of libmpir, and is empty in\n   all other circumstances.\n\n   When compiling objects for libmpir, __GMP_DECLSPEC is an export directive,\n   or when compiling for an application it's an import directive.  The two\n   cases are differentiated by __GMP_WITHIN_GMP defined by the GMP Makefiles\n   (and not defined from an application).\n\n   __GMP_DECLSPEC_XX is similarly used for libmpirxx.  __GMP_WITHIN_GMPXX\n   indicates when building libmpirxx, and in that case libmpirxx functions are\n   exports, but libmpir functions which might get called are imports.\n\n   libmp.la uses __GMP_DECLSPEC, just as if it were libmpir.la.  libmpir and\n   libmp don't call each other, so there's no conflict or confusion.\n\n   Libtool DLL_EXPORT define is not used.\n\n   There's no attempt to support GMP built both static and DLL.  Doing so\n   would mean applications would have to tell us which of the two is going\n   to be used when linking, and that seems very tedious and error prone if\n   using GMP by hand, and equally tedious from a package since autoconf and\n   automake don't give much help.\n\n   __GMP_DECLSPEC is required on all documented global functions and\n   variables, the various internals in gmp-impl.h etc can be left unadorned.\n   But internals used by the test programs or speed measuring programs\n   should have __GMP_DECLSPEC, and certainly constants or variables must\n   have it or the wrong address will be resolved.\n\n   In gcc __declspec can go at either the start or end of a prototype.\n\n   In Microsoft C __declspec must go at the start, or after the type like\n   void __declspec(...) *foo()\".  There's no __dllexport or anything to\n   guard against someone foolish #defining dllexport.  _export used to be\n   available, but no longer.\n\n   In Borland C _export still exists, but needs to go after the type, like\n   \"void _export foo();\".  Would have to change the __GMP_DECLSPEC syntax to\n   make use of that.  Probably more trouble than it's worth.  */\n\n#if defined (__GNUC__)\n#define __GMP_DECLSPEC_EXPORT  __declspec(__dllexport__)\n#define __GMP_DECLSPEC_IMPORT  __declspec(__dllimport__)\n#endif\n#if defined (_MSC_VER) || defined (__BORLANDC__)\n#define __GMP_DECLSPEC_EXPORT  __declspec(dllexport)\n#define __GMP_DECLSPEC_IMPORT  __declspec(dllimport)\n#endif\n#ifdef __WATCOMC__\n#define __GMP_DECLSPEC_EXPORT  __export\n#define __GMP_DECLSPEC_IMPORT  __import\n#endif\n#ifdef __IBMC__\n#define __GMP_DECLSPEC_EXPORT  _Export\n#define __GMP_DECLSPEC_IMPORT  _Import\n#endif\n\n#if __GMP_LIBGMP_DLL\n#if __GMP_WITHIN_GMP\n/* compiling to go into a DLL libmpir */\n#define __GMP_DECLSPEC  __GMP_DECLSPEC_EXPORT\n#else\n/* compiling to go into an application which will link to a DLL libmpir */\n#define __GMP_DECLSPEC  __GMP_DECLSPEC_IMPORT\n#endif\n#else\n/* all other cases */\n#define __GMP_DECLSPEC\n#endif\n\n\n#ifdef __GMP_SHORT_LIMB\ntypedef unsigned int\t\tmp_limb_t;\ntypedef int\t\t\tmp_limb_signed_t;\n#else\n#ifdef _LONG_LONG_LIMB\ntypedef unsigned long long int\tmp_limb_t;\ntypedef long long int\t\tmp_limb_signed_t;\n#else\ntypedef unsigned long int\tmp_limb_t;\ntypedef long int\t\tmp_limb_signed_t;\n#endif\n#endif\n\n#ifdef _WIN64\ntypedef unsigned long long int\tmp_bitcnt_t;\n#else\ntypedef unsigned long int mp_bitcnt_t;\n#endif\n\n/* For reference, note that the name __mpz_struct gets into C++ mangled\n   function names, which means although the \"__\" suggests an internal, we\n   must leave this name for binary compatibility.  */\ntypedef struct\n{\n  int _mp_alloc;\t\t/* Number of *limbs* allocated and pointed\n\t\t\t\t   to by the _mp_d field.  */\n  int _mp_size;\t\t\t/* abs(_mp_size) is the number of limbs the\n\t\t\t\t   last field points to.  If _mp_size is\n\t\t\t\t   negative this is a negative number.  */\n  mp_limb_t *_mp_d;\t\t/* Pointer to the limbs.  */\n} __mpz_struct;\n\n#endif /* __GNU_MP__ */\n\ntypedef __mpz_struct mpz_t[1];\n\ntypedef mp_limb_t *\t\tmp_ptr;\ntypedef __gmp_const mp_limb_t *\tmp_srcptr;\n#if defined( _WIN64)\n#define __GMP_MP_SIZE_T_INT     0\ntypedef long long int\tmp_size_t;\ntypedef long int\t\tmp_exp_t;\n#else\n#define __GMP_MP_SIZE_T_INT     0\ntypedef long int\t\tmp_size_t;\ntypedef long int\t\tmp_exp_t;\n#endif\n\ntypedef struct\n{\n  __mpz_struct _mp_num;\n  __mpz_struct _mp_den;\n} __mpq_struct;\n\ntypedef __mpq_struct mpq_t[1];\n\ntypedef struct\n{\n  int _mp_prec;\t\t\t/* Max precision, in number of `mp_limb_t's.\n\t\t\t\t   Set by mpf_init and modified by\n\t\t\t\t   mpf_set_prec.  The area pointed to by the\n\t\t\t\t   _mp_d field contains `prec' + 1 limbs.  */\n  int _mp_size;\t\t\t/* abs(_mp_size) is the number of limbs the\n\t\t\t\t   last field points to.  If _mp_size is\n\t\t\t\t   negative this is a negative number.  */\n  mp_exp_t _mp_exp;\t\t/* Exponent, in the base of `mp_limb_t'.  */\n  mp_limb_t *_mp_d;\t\t/* Pointer to the limbs.  */\n} __mpf_struct;\n\ntypedef __mpf_struct mpf_t[1];\n\n/* Available random number generation algorithms.  */\ntypedef enum\n{\n  GMP_RAND_ALG_DEFAULT = 0,\n  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT /* Linear congruential.  */\n} gmp_randalg_t;\n\n/* Random state struct.  */\ntypedef struct\n{\n  mpz_t _mp_seed;\t  /* _mp_d member points to state of the generator. */\n  gmp_randalg_t _mp_alg;  /* Currently unused. */\n  union {\n    void *_mp_lc;         /* Pointer to function pointers structure.  */\n  } _mp_algdata;\n} __gmp_randstate_struct;\ntypedef __gmp_randstate_struct gmp_randstate_t[1];\n\n/* Types for function declarations in gmp files.  */\n/* ??? Should not pollute user name space with these ??? */\ntypedef __gmp_const __mpz_struct *mpz_srcptr;\ntypedef __mpz_struct *mpz_ptr;\ntypedef __gmp_const __mpf_struct *mpf_srcptr;\ntypedef __mpf_struct *mpf_ptr;\ntypedef __gmp_const __mpq_struct *mpq_srcptr;\ntypedef __mpq_struct *mpq_ptr;\n\n\n/* This is not wanted in mp.h, so put it outside the __GNU_MP__ common\n   section. */\n#if __GMP_LIBGMP_DLL\n#if __GMP_WITHIN_GMPXX\n/* compiling to go into a DLL libmpirxx */\n#define __GMP_DECLSPEC_XX  __GMP_DECLSPEC_EXPORT\n#else\n/* compiling to go into a application which will link to a DLL libmpirxx */\n#define __GMP_DECLSPEC_XX  __GMP_DECLSPEC_IMPORT\n#endif\n#else\n/* all other cases */\n#define __GMP_DECLSPEC_XX\n#endif\n\n\n#if __GMP_HAVE_PROTOTYPES\n#define __GMP_PROTO(x) x\n#else\n#define __GMP_PROTO(x) ()\n#endif\n\n#ifndef __MPN\n#if __GMP_HAVE_TOKEN_PASTE\n#define __MPN(x) __gmpn_##x\n#else\n#define __MPN(x) __gmpn_/**/x\n#endif\n#endif\n\n/* For reference, \"defined(EOF)\" cannot be used here.  In g++ 2.95.4,\n   <iostream> defines EOF but not FILE.  */\n#if defined (FILE)                                              \\\n  || defined (H_STDIO)                                          \\\n  || defined (_H_STDIO)               /* AIX */                 \\\n  || defined (_STDIO_H)               /* glibc, Sun, SCO */     \\\n  || defined (_STDIO_H_)              /* BSD, OSF */            \\\n  || defined (__STDIO_H)              /* Borland */             \\\n  || defined (__STDIO_H__)            /* IRIX */                \\\n  || defined (_STDIO_INCLUDED)        /* HPUX */                \\\n  || defined (_FILE_DEFINED)          /* Microsoft */           \\\n  || defined (__STDIO__)              /* Apple MPW MrC */       \\\n  || defined (_MSL_STDIO_H)           /* Metrowerks */          \\\n  || defined (_STDIO_H_INCLUDED)      /* QNX4 */\t\t\\\n  || defined (_ISO_STDIO_ISO_H)       /* Sun C++ */\n#define _GMP_H_HAVE_FILE 1\n#endif\n\n/* In ISO C, if a prototype involving \"struct obstack *\" is given without\n   that structure defined, then the struct is scoped down to just the\n   prototype, causing a conflict if it's subsequently defined for real.  So\n   only give prototypes if we've got obstack.h.  */\n#if defined (_OBSTACK_H)   /* glibc <obstack.h> */\n#define _GMP_H_HAVE_OBSTACK 1\n#endif\n\n/* The prototypes for gmp_vprintf etc are provided only if va_list is\n   available, via an application having included <stdarg.h> or <varargs.h>.\n   Usually va_list is a typedef so can't be tested directly, but C99\n   specifies that va_start is a macro (and it was normally a macro on past\n   systems too), so look for that.\n\n   <stdio.h> will define some sort of va_list for vprintf and vfprintf, but\n   let's not bother trying to use that since it's not standard and since\n   application uses for gmp_vprintf etc will almost certainly require the\n   whole <stdarg.h> or <varargs.h> anyway.  */\n\n#ifdef va_start\n#define _GMP_H_HAVE_VA_LIST 1\n#endif\n\n/* Test for gcc >= maj.min, as per __GNUC_PREREQ in glibc */\n#if defined (__GNUC__) && defined (__GNUC_MINOR__)\n#define __GMP_GNUC_PREREQ(maj, min) \\\n  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n#else\n#define __GMP_GNUC_PREREQ(maj, min)  0\n#endif\n\n/* \"pure\" is in gcc 2.96 and up, see \"(gcc)Function Attributes\".  Basically\n   it means a function does nothing but examine its arguments and memory\n   (global or via arguments) to generate a return value, but changes nothing\n   and has no side-effects.  __GMP_NO_ATTRIBUTE_CONST_PURE lets\n   tune/common.c etc turn this off when trying to write timing loops.  */\n#if __GMP_GNUC_PREREQ (2,96) && ! defined (__GMP_NO_ATTRIBUTE_CONST_PURE)\n#define __GMP_ATTRIBUTE_PURE   __attribute__ ((__pure__))\n#else\n#define __GMP_ATTRIBUTE_PURE\n#endif\n\n\n/* __GMP_CAST allows us to use static_cast in C++, so our macros are clean\n   to \"g++ -Wold-style-cast\".\n\n   Casts in \"extern inline\" code within an extern \"C\" block don't induce\n   these warnings, so __GMP_CAST only needs to be used on documented\n   macros.  */\n\n#ifdef __cplusplus\n#define __GMP_CAST(type, expr)  (static_cast<type> (expr))\n#else\n#define __GMP_CAST(type, expr)  ((type) (expr))\n#endif\n\n\n/* An empty \"throw ()\" means the function doesn't throw any C++ exceptions,\n   this can save some stack frame info in applications.\n\n   Currently it's given only on functions which never divide-by-zero etc,\n   don't allocate memory, and are expected to never need to allocate memory.\n   This leaves open the possibility of a C++ throw from a future GMP\n   exceptions scheme.\n\n   mpz_set_ui etc are omitted to leave open the lazy allocation scheme\n   described in doc/tasks.html.  mpz_get_d etc are omitted to leave open\n   exceptions for float overflows.\n\n   Note that __GMP_NOTHROW must be given on any inlines the same as on their\n   prototypes (for g++ at least, where they're used together).  Note also\n   that g++ 3.0 demands that __GMP_NOTHROW is before other attributes like\n   __GMP_ATTRIBUTE_PURE.  */\n\n#if defined (__cplusplus)\n#define __GMP_NOTHROW  throw ()\n#else\n#define __GMP_NOTHROW\n#endif\n\n/* PORTME: What other compilers have a useful \"extern inline\"?  \"static\n   inline\" would be an acceptable substitute if the compiler (or linker)\n   discards unused statics.  */\n\n/* gcc has __inline__ in all modes, including strict ansi.  Give a prototype\n   for an inline too, so as to correctly specify \"dllimport\" on windows, in\n   case the function is called rather than inlined.  */\n\n#ifdef __GNUC__\n#if defined(__APPLE_CC__) && (__APPLE_CC__ != 1) /* FSF GCC sets this flag to 1 on Apple machines */\n\n#if ! (__APPLE_CC__ >= 5465 && __STDC_VERSION__ >= 199901L)\n#define __GMP_EXTERN_INLINE extern __inline__\n#define __GMP_INLINE_PROTOTYPES  1\n#endif\n\n#else /*GNU CC*/\n\n#if defined(__GNUC_STDC_INLINE__) || defined (__GNUC_GNU_INLINE__)\n#define __GMP_EXTERN_INLINE extern __inline__ __attribute__((__gnu_inline__))\n#else\n#define __GMP_EXTERN_INLINE extern __inline__\n#endif\n#define __GMP_INLINE_PROTOTYPES  1\n\n#endif\n#endif\n\n/* DEC C (eg. version 5.9) supports \"static __inline foo()\", even in -std1\n   strict ANSI mode.  Inlining is done even when not optimizing (ie. -O0\n   mode, which is the default), but an unnecessary local copy of foo is\n   emitted unless -O is used.  \"extern __inline\" is accepted, but the\n   \"extern\" appears to be ignored, ie. it becomes a plain global function\n   but which is inlined within its file.  Don't know if all old versions of\n   DEC C supported __inline, but as a start let's do the right thing for\n   current versions.  */\n#ifdef __DECC\n#define __GMP_EXTERN_INLINE  static __inline\n#endif\n\n/* SCO OpenUNIX 8 cc supports \"static inline foo()\" but not in -Xc strict\n   ANSI mode (__STDC__ is 1 in that mode).  Inlining only actually takes\n   place under -O.  Without -O \"foo\" seems to be emitted whether it's used\n   or not, which is wasteful.  \"extern inline foo()\" isn't useful, the\n   \"extern\" is apparently ignored, so foo is inlined if possible but also\n   emitted as a global, which causes multiple definition errors when\n   building a shared libmpir.  */\n#ifdef __SCO_VERSION__\n#if __SCO_VERSION__ > 400000000 && __STDC__ != 1 \\\n  && ! defined (__GMP_EXTERN_INLINE)\n#define __GMP_EXTERN_INLINE  static inline\n#endif\n#endif\n\n#if defined _MSC_VER\n#define __GMP_EXTERN_INLINE  static __inline\n#endif\n\n/* C++ always has \"inline\" and since it's a normal feature the linker should\n   discard duplicate non-inlined copies, or if it doesn't then that's a\n   problem for everyone, not just GMP.  */\n#if defined (__cplusplus) && ! defined (__GMP_EXTERN_INLINE)\n#define __GMP_EXTERN_INLINE  inline\n#endif\n\n/* Don't do any inlining within a configure run, since if the compiler ends\n   up emitting copies of the code into the object file it can end up\n   demanding the various support routines (like mpn_popcount) for linking,\n   making the \"alloca\" test and perhaps others fail.  And on hppa ia64 a\n   pre-release gcc 3.2 was seen not respecting the \"extern\" in \"extern\n   __inline__\", triggering this problem too.  */\n#if defined (__GMP_WITHIN_CONFIGURE) && ! __GMP_WITHIN_CONFIGURE_INLINE\n#undef __GMP_EXTERN_INLINE\n#endif\n\n/* By default, don't give a prototype when there's going to be an inline\n   version.  Note in particular that Cray C++ objects to the combination of\n   prototype and inline.  */\n#ifdef __GMP_EXTERN_INLINE\n#ifndef __GMP_INLINE_PROTOTYPES\n#define __GMP_INLINE_PROTOTYPES  0\n#endif\n#else\n#define __GMP_INLINE_PROTOTYPES  1\n#endif\n\n\n#define __GMP_ABS(x)   ((x) >= 0 ? (x) : -(x))\n#define __GMP_MAX(h,i) ((h) > (i) ? (h) : (i))\n\n/* __GMP_USHRT_MAX is not \"~ (unsigned short) 0\" because short is promoted\n   to int by \"~\".  */\n#define __GMP_UINT_MAX   (~ (unsigned) 0)\n#define __GMP_ULONG_MAX  (~ (unsigned long) 0)\n#define __GMP_USHRT_MAX  ((unsigned short) ~0)\n\n\n/* __builtin_expect is in gcc 3.0, and not in 2.95. */\n#if __GMP_GNUC_PREREQ (3,0)\n#define __GMP_LIKELY(cond)    __builtin_expect ((cond) != 0, 1)\n#define __GMP_UNLIKELY(cond)  __builtin_expect ((cond) != 0, 0)\n#else\n#define __GMP_LIKELY(cond)    (cond)\n#define __GMP_UNLIKELY(cond)  (cond)\n#endif\n\n/* Allow direct user access to numerator and denominator of a mpq_t object.  */\n#define mpq_numref(Q) (&((Q)->_mp_num))\n#define mpq_denref(Q) (&((Q)->_mp_den))\n\n\n#if defined (__cplusplus)\nextern \"C\" {\nusing std::FILE;\n#endif\n\n#define mp_set_memory_functions __gmp_set_memory_functions\n__GMP_DECLSPEC void mp_set_memory_functions __GMP_PROTO ((void *(*) (size_t),\n\t\t\t\t      void *(*) (void *, size_t, size_t),\n\t\t\t\t      void (*) (void *, size_t))) __GMP_NOTHROW;\n\n#define mp_get_memory_functions __gmp_get_memory_functions\n__GMP_DECLSPEC void mp_get_memory_functions __GMP_PROTO ((void *(**) (size_t),\n                                      void *(**) (void *, size_t, size_t),\n                                      void (**) (void *, size_t))) __GMP_NOTHROW;\n\n#define mp_bits_per_limb __gmp_bits_per_limb\n__GMP_DECLSPEC extern __gmp_const int mp_bits_per_limb;\n\n#define gmp_errno __gmp_errno\n__GMP_DECLSPEC extern int gmp_errno;\n\n#define gmp_version __gmp_version\n__GMP_DECLSPEC extern __gmp_const char * __gmp_const gmp_version;\n\n#define mpir_version __mpir_version\n__GMP_DECLSPEC extern __gmp_const char * __gmp_const mpir_version;\n\n\n/**************** Random number routines.  ****************/\n\n#define gmp_randinit_default __gmp_randinit_default\n__GMP_DECLSPEC void gmp_randinit_default __GMP_PROTO ((gmp_randstate_t));\n\n#define gmp_randinit_lc_2exp __gmp_randinit_lc_2exp\n__GMP_DECLSPEC void gmp_randinit_lc_2exp __GMP_PROTO ((gmp_randstate_t,\n\t\t\t\t\t\t       mpz_srcptr, unsigned long int,\n\t\t\t\t\t\t       mp_bitcnt_t));\n\n#define gmp_randinit_lc_2exp_size __gmp_randinit_lc_2exp_size\n__GMP_DECLSPEC int gmp_randinit_lc_2exp_size __GMP_PROTO ((gmp_randstate_t, mp_bitcnt_t));\n\n#define gmp_randinit_mt __gmp_randinit_mt\n__GMP_DECLSPEC void gmp_randinit_mt __GMP_PROTO ((gmp_randstate_t));\n\n#define gmp_randinit_set __gmp_randinit_set\n__GMP_DECLSPEC void gmp_randinit_set __GMP_PROTO ((gmp_randstate_t, __gmp_const __gmp_randstate_struct *));\n\n#define gmp_randseed __gmp_randseed\n__GMP_DECLSPEC void gmp_randseed __GMP_PROTO ((gmp_randstate_t, mpz_srcptr));\n\n#define gmp_randseed_ui __gmp_randseed_ui\n__GMP_DECLSPEC void gmp_randseed_ui __GMP_PROTO ((gmp_randstate_t, unsigned long int));\n\n#define gmp_randclear __gmp_randclear\n__GMP_DECLSPEC void gmp_randclear __GMP_PROTO ((gmp_randstate_t));\n\n#define gmp_urandomb_ui __gmp_urandomb_ui\n__GMP_DECLSPEC unsigned long gmp_urandomb_ui __GMP_PROTO ((gmp_randstate_t, unsigned long));\n\n#define gmp_urandomm_ui __gmp_urandomm_ui\n__GMP_DECLSPEC unsigned long gmp_urandomm_ui __GMP_PROTO ((gmp_randstate_t, unsigned long));\n\n\n/**************** Formatted output routines.  ****************/\n\n#define gmp_asprintf __gmp_asprintf\n__GMP_DECLSPEC int gmp_asprintf __GMP_PROTO ((char **, __gmp_const char *, ...));\n\n#define gmp_fprintf __gmp_fprintf\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC int gmp_fprintf __GMP_PROTO ((FILE *, __gmp_const char *, ...));\n#endif\n\n#define gmp_obstack_printf __gmp_obstack_printf\n#if defined (_GMP_H_HAVE_OBSTACK)\n__GMP_DECLSPEC int gmp_obstack_printf __GMP_PROTO ((struct obstack *, __gmp_const char *, ...));\n#endif\n\n#define gmp_obstack_vprintf __gmp_obstack_vprintf\n#if defined (_GMP_H_HAVE_OBSTACK) && defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_obstack_vprintf __GMP_PROTO ((struct obstack *, __gmp_const char *, va_list));\n#endif\n\n#define gmp_printf __gmp_printf\n__GMP_DECLSPEC int gmp_printf __GMP_PROTO ((__gmp_const char *, ...));\n\n#define gmp_snprintf __gmp_snprintf\n__GMP_DECLSPEC int gmp_snprintf __GMP_PROTO ((char *, size_t, __gmp_const char *, ...));\n\n#define gmp_sprintf __gmp_sprintf\n__GMP_DECLSPEC int gmp_sprintf __GMP_PROTO ((char *, __gmp_const char *, ...));\n\n#define gmp_vasprintf __gmp_vasprintf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vasprintf __GMP_PROTO ((char **, __gmp_const char *, va_list));\n#endif\n\n#define gmp_vfprintf __gmp_vfprintf\n#if defined (_GMP_H_HAVE_FILE) && defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vfprintf __GMP_PROTO ((FILE *, __gmp_const char *, va_list));\n#endif\n\n#define gmp_vprintf __gmp_vprintf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vprintf __GMP_PROTO ((__gmp_const char *, va_list));\n#endif\n\n#define gmp_vsnprintf __gmp_vsnprintf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vsnprintf __GMP_PROTO ((char *, size_t, __gmp_const char *, va_list));\n#endif\n\n#define gmp_vsprintf __gmp_vsprintf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vsprintf __GMP_PROTO ((char *, __gmp_const char *, va_list));\n#endif\n\n\n/**************** Formatted input routines.  ****************/\n\n#define gmp_fscanf __gmp_fscanf\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC int gmp_fscanf __GMP_PROTO ((FILE *, __gmp_const char *, ...));\n#endif\n\n#define gmp_scanf __gmp_scanf\n__GMP_DECLSPEC int gmp_scanf __GMP_PROTO ((__gmp_const char *, ...));\n\n#define gmp_sscanf __gmp_sscanf\n__GMP_DECLSPEC int gmp_sscanf __GMP_PROTO ((__gmp_const char *, __gmp_const char *, ...));\n\n#define gmp_vfscanf __gmp_vfscanf\n#if defined (_GMP_H_HAVE_FILE) && defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vfscanf __GMP_PROTO ((FILE *, __gmp_const char *, va_list));\n#endif\n\n#define gmp_vscanf __gmp_vscanf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vscanf __GMP_PROTO ((__gmp_const char *, va_list));\n#endif\n\n#define gmp_vsscanf __gmp_vsscanf\n#if defined (_GMP_H_HAVE_VA_LIST)\n__GMP_DECLSPEC int gmp_vsscanf __GMP_PROTO ((__gmp_const char *, __gmp_const char *, va_list));\n#endif\n\n\n/**************** Integer (i.e. Z) routines.  ****************/\n\n#define __GMP_BITS_PER_ULONG\t(8*sizeof(unsigned long))\n\n#define _mpz_realloc __gmpz_realloc\n#define mpz_realloc __gmpz_realloc\n__GMP_DECLSPEC void *_mpz_realloc __GMP_PROTO ((mpz_ptr, mp_size_t));\n\n#define mpz_abs __gmpz_abs\n#define __GMP_MPZ_ABS_MIN_ALLOC(x,y) (__GMP_ABS(y->_mp_size))\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_abs)\n__GMP_DECLSPEC void mpz_abs __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n#endif\n\n#define __GMP_MPZ_ADD_MIN_ALLOC(x,y,z) (__GMP_MAX(__GMP_ABS(y->_mp_size),__GMP_ABS(z->_mp_size))+1)\n#define mpz_add __gmpz_add\n__GMP_DECLSPEC void mpz_add __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define __GMP_MPZ_ADD_UI_MIN_ALLOC(x,y,z) (__GMP_MAX(__GMP_ABS(y->_mp_size),1+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS)+1)\n#define mpz_add_ui __gmpz_add_ui\n__GMP_DECLSPEC void mpz_add_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_addmul __gmpz_addmul\n__GMP_DECLSPEC void mpz_addmul __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_addmul_ui __gmpz_addmul_ui\n__GMP_DECLSPEC void mpz_addmul_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_and __gmpz_and\n__GMP_DECLSPEC void mpz_and __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_array_init __gmpz_array_init\n__GMP_DECLSPEC void mpz_array_init __GMP_PROTO ((mpz_ptr, mp_size_t, mp_size_t));\n\n#define mpz_bin_ui __gmpz_bin_ui\n__GMP_DECLSPEC void mpz_bin_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_bin_uiui __gmpz_bin_uiui\n__GMP_DECLSPEC void mpz_bin_uiui __GMP_PROTO ((mpz_ptr, unsigned long int, unsigned long int));\n\n#define mpz_cdiv_q __gmpz_cdiv_q\n__GMP_DECLSPEC void mpz_cdiv_q __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_cdiv_q_2exp __gmpz_cdiv_q_2exp\n__GMP_DECLSPEC void mpz_cdiv_q_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long));\n\n#define mpz_cdiv_q_ui __gmpz_cdiv_q_ui\n__GMP_DECLSPEC unsigned long int mpz_cdiv_q_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_cdiv_qr __gmpz_cdiv_qr\n__GMP_DECLSPEC void mpz_cdiv_qr __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_cdiv_qr_ui __gmpz_cdiv_qr_ui\n__GMP_DECLSPEC unsigned long int mpz_cdiv_qr_ui __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_cdiv_r __gmpz_cdiv_r\n__GMP_DECLSPEC void mpz_cdiv_r __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_cdiv_r_2exp __gmpz_cdiv_r_2exp\n__GMP_DECLSPEC void mpz_cdiv_r_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define mpz_cdiv_r_ui __gmpz_cdiv_r_ui\n__GMP_DECLSPEC unsigned long int mpz_cdiv_r_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_cdiv_ui __gmpz_cdiv_ui\n__GMP_DECLSPEC unsigned long int mpz_cdiv_ui __GMP_PROTO ((mpz_srcptr, unsigned long int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_clear __gmpz_clear\n__GMP_DECLSPEC void mpz_clear __GMP_PROTO ((mpz_ptr));\n\n#define mpz_clears __gmpz_clears\n__GMP_DECLSPEC void mpz_clears __GMP_PROTO ((mpz_ptr, ...));\n\n#define mpz_clrbit __gmpz_clrbit\n__GMP_DECLSPEC void mpz_clrbit __GMP_PROTO ((mpz_ptr, mp_bitcnt_t));\n\n#define mpz_cmp __gmpz_cmp\n__GMP_DECLSPEC int mpz_cmp __GMP_PROTO ((mpz_srcptr, mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_cmp_d __gmpz_cmp_d\n__GMP_DECLSPEC int mpz_cmp_d __GMP_PROTO ((mpz_srcptr, double)) __GMP_ATTRIBUTE_PURE;\n\n#define _mpz_cmp_si __gmpz_cmp_si\n__GMP_DECLSPEC int _mpz_cmp_si __GMP_PROTO ((mpz_srcptr, signed long int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define _mpz_cmp_ui __gmpz_cmp_ui\n__GMP_DECLSPEC int _mpz_cmp_ui __GMP_PROTO ((mpz_srcptr, unsigned long int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_cmpabs __gmpz_cmpabs\n__GMP_DECLSPEC int mpz_cmpabs __GMP_PROTO ((mpz_srcptr, mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_cmpabs_d __gmpz_cmpabs_d\n__GMP_DECLSPEC int mpz_cmpabs_d __GMP_PROTO ((mpz_srcptr, double)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_cmpabs_ui __gmpz_cmpabs_ui\n__GMP_DECLSPEC int mpz_cmpabs_ui __GMP_PROTO ((mpz_srcptr, unsigned long int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_com __gmpz_com\n__GMP_DECLSPEC void mpz_com __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n\n#define mpz_combit __gmpz_combit\n__GMP_DECLSPEC void mpz_combit __GMP_PROTO ((mpz_ptr, mp_bitcnt_t));\n\n#define mpz_congruent_p __gmpz_congruent_p\n__GMP_DECLSPEC int mpz_congruent_p __GMP_PROTO ((mpz_srcptr, mpz_srcptr, mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_congruent_2exp_p __gmpz_congruent_2exp_p\n__GMP_DECLSPEC int mpz_congruent_2exp_p __GMP_PROTO ((mpz_srcptr, mpz_srcptr, mp_bitcnt_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_congruent_ui_p __gmpz_congruent_ui_p\n__GMP_DECLSPEC int mpz_congruent_ui_p __GMP_PROTO ((mpz_srcptr, unsigned long, unsigned long)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_divexact __gmpz_divexact\n__GMP_DECLSPEC void mpz_divexact __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_divexact_ui __gmpz_divexact_ui\n__GMP_DECLSPEC void mpz_divexact_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long));\n\n#define mpz_divisible_p __gmpz_divisible_p\n__GMP_DECLSPEC int mpz_divisible_p __GMP_PROTO ((mpz_srcptr, mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_divisible_ui_p __gmpz_divisible_ui_p\n__GMP_DECLSPEC int mpz_divisible_ui_p __GMP_PROTO ((mpz_srcptr, unsigned long)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_divisible_2exp_p __gmpz_divisible_2exp_p\n__GMP_DECLSPEC int mpz_divisible_2exp_p __GMP_PROTO ((mpz_srcptr, mp_bitcnt_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_dump __gmpz_dump\n__GMP_DECLSPEC void mpz_dump __GMP_PROTO ((mpz_srcptr));\n\n#define mpz_export __gmpz_export\n__GMP_DECLSPEC void *mpz_export __GMP_PROTO ((void *, size_t *, int, size_t, int, size_t, mpz_srcptr));\n\n#define mpz_fac_ui __gmpz_fac_ui\n__GMP_DECLSPEC void mpz_fac_ui __GMP_PROTO ((mpz_ptr, unsigned long int));\n\n#define mpz_fdiv_q __gmpz_fdiv_q\n__GMP_DECLSPEC void mpz_fdiv_q __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_fdiv_q_2exp __gmpz_fdiv_q_2exp\n__GMP_DECLSPEC void mpz_fdiv_q_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define mpz_fdiv_q_ui __gmpz_fdiv_q_ui\n__GMP_DECLSPEC unsigned long int mpz_fdiv_q_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_fdiv_qr __gmpz_fdiv_qr\n__GMP_DECLSPEC void mpz_fdiv_qr __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_fdiv_qr_ui __gmpz_fdiv_qr_ui\n__GMP_DECLSPEC unsigned long int mpz_fdiv_qr_ui __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_fdiv_r __gmpz_fdiv_r\n__GMP_DECLSPEC void mpz_fdiv_r __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_fdiv_r_2exp __gmpz_fdiv_r_2exp\n__GMP_DECLSPEC void mpz_fdiv_r_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define mpz_fdiv_r_ui __gmpz_fdiv_r_ui\n__GMP_DECLSPEC unsigned long int mpz_fdiv_r_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_fdiv_ui __gmpz_fdiv_ui\n__GMP_DECLSPEC unsigned long int mpz_fdiv_ui __GMP_PROTO ((mpz_srcptr, unsigned long int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_fib_ui __gmpz_fib_ui\n__GMP_DECLSPEC void mpz_fib_ui __GMP_PROTO ((mpz_ptr, unsigned long int));\n\n#define mpz_fib2_ui __gmpz_fib2_ui\n__GMP_DECLSPEC void mpz_fib2_ui __GMP_PROTO ((mpz_ptr, mpz_ptr, unsigned long int));\n\n#define mpz_fits_sint_p __gmpz_fits_sint_p\n__GMP_DECLSPEC int mpz_fits_sint_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_fits_slong_p __gmpz_fits_slong_p\n__GMP_DECLSPEC int mpz_fits_slong_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_fits_sshort_p __gmpz_fits_sshort_p\n__GMP_DECLSPEC int mpz_fits_sshort_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_fits_uint_p __gmpz_fits_uint_p\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_uint_p)\n__GMP_DECLSPEC int mpz_fits_uint_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_fits_ulong_p __gmpz_fits_ulong_p\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_ulong_p)\n__GMP_DECLSPEC int mpz_fits_ulong_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_fits_ushort_p __gmpz_fits_ushort_p\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_ushort_p)\n__GMP_DECLSPEC int mpz_fits_ushort_p __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_gcd __gmpz_gcd\n__GMP_DECLSPEC void mpz_gcd __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_gcd_ui __gmpz_gcd_ui\n__GMP_DECLSPEC unsigned long int mpz_gcd_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_gcdext __gmpz_gcdext\n__GMP_DECLSPEC void mpz_gcdext __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_get_d __gmpz_get_d\n__GMP_DECLSPEC double mpz_get_d __GMP_PROTO ((mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_get_d_2exp __gmpz_get_d_2exp\n__GMP_DECLSPEC double mpz_get_d_2exp __GMP_PROTO ((signed long int *, mpz_srcptr));\n\n#define mpz_get_si __gmpz_get_si\n__GMP_DECLSPEC /* signed */ long int mpz_get_si __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_get_str __gmpz_get_str\n__GMP_DECLSPEC char *mpz_get_str __GMP_PROTO ((char *, int, mpz_srcptr));\n\n#define mpz_get_ui __gmpz_get_ui\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_get_ui)\n__GMP_DECLSPEC unsigned long int mpz_get_ui __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_getlimbn __gmpz_getlimbn\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_getlimbn)\n__GMP_DECLSPEC mp_limb_t mpz_getlimbn __GMP_PROTO ((mpz_srcptr, mp_size_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_hamdist __gmpz_hamdist\n__GMP_DECLSPEC mp_bitcnt_t mpz_hamdist __GMP_PROTO ((mpz_srcptr, mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_import __gmpz_import\n__GMP_DECLSPEC void mpz_import __GMP_PROTO ((mpz_ptr, size_t, int, size_t, int, size_t, __gmp_const void *));\n\n#define mpz_init __gmpz_init\n__GMP_DECLSPEC void mpz_init __GMP_PROTO ((mpz_ptr));\n\n#define mpz_init2 __gmpz_init2\n__GMP_DECLSPEC void mpz_init2 __GMP_PROTO ((mpz_ptr, mp_bitcnt_t));\n\n#define mpz_inits __gmpz_inits\n__GMP_DECLSPEC void mpz_inits __GMP_PROTO ((mpz_ptr, ...));\n\n#define mpz_init_set __gmpz_init_set\n__GMP_DECLSPEC void mpz_init_set __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n\n#define mpz_init_set_d __gmpz_init_set_d\n__GMP_DECLSPEC void mpz_init_set_d __GMP_PROTO ((mpz_ptr, double));\n\n#define mpz_init_set_si __gmpz_init_set_si\n__GMP_DECLSPEC void mpz_init_set_si __GMP_PROTO ((mpz_ptr, signed long int));\n\n#define mpz_init_set_str __gmpz_init_set_str\n__GMP_DECLSPEC int mpz_init_set_str __GMP_PROTO ((mpz_ptr, __gmp_const char *, int));\n\n#define mpz_init_set_ui __gmpz_init_set_ui\n__GMP_DECLSPEC void mpz_init_set_ui __GMP_PROTO ((mpz_ptr, unsigned long int));\n\n#define mpz_inp_raw __gmpz_inp_raw\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpz_inp_raw __GMP_PROTO ((mpz_ptr, FILE *));\n#endif\n\n#define mpz_inp_str __gmpz_inp_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpz_inp_str __GMP_PROTO ((mpz_ptr, FILE *, int));\n#endif\n\n#define mpz_invert __gmpz_invert\n__GMP_DECLSPEC int mpz_invert __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_ior __gmpz_ior\n__GMP_DECLSPEC void mpz_ior __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_jacobi __gmpz_jacobi\n__GMP_DECLSPEC int mpz_jacobi __GMP_PROTO ((mpz_srcptr, mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_kronecker mpz_jacobi  /* alias */\n\n#define mpz_kronecker_si __gmpz_kronecker_si\n__GMP_DECLSPEC int mpz_kronecker_si __GMP_PROTO ((mpz_srcptr, long)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_kronecker_ui __gmpz_kronecker_ui\n__GMP_DECLSPEC int mpz_kronecker_ui __GMP_PROTO ((mpz_srcptr, unsigned long)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_si_kronecker __gmpz_si_kronecker\n__GMP_DECLSPEC int mpz_si_kronecker __GMP_PROTO ((long, mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_ui_kronecker __gmpz_ui_kronecker\n__GMP_DECLSPEC int mpz_ui_kronecker __GMP_PROTO ((unsigned long, mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_lcm __gmpz_lcm\n__GMP_DECLSPEC void mpz_lcm __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_lcm_ui __gmpz_lcm_ui\n__GMP_DECLSPEC void mpz_lcm_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long));\n\n#define mpz_legendre mpz_jacobi  /* alias */\n\n#define mpz_lucnum_ui __gmpz_lucnum_ui\n__GMP_DECLSPEC void mpz_lucnum_ui __GMP_PROTO ((mpz_ptr, unsigned long int));\n\n#define mpz_lucnum2_ui __gmpz_lucnum2_ui\n__GMP_DECLSPEC void mpz_lucnum2_ui __GMP_PROTO ((mpz_ptr, mpz_ptr, unsigned long int));\n\n#define mpz_millerrabin __gmpz_millerrabin\n__GMP_DECLSPEC int mpz_millerrabin __GMP_PROTO ((mpz_srcptr, int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_mod __gmpz_mod\n__GMP_DECLSPEC void mpz_mod __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_mod_ui mpz_fdiv_r_ui /* same as fdiv_r because divisor unsigned */\n\n#define __GMP_MPZ_MUL_MIN_ALLOC(x,y,z) (__GMP_ABS(y->_mp_size)+__GMP_ABS(z->_mp_size)+1)\n#define mpz_mul __gmpz_mul\n__GMP_DECLSPEC void mpz_mul __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_mul_2exp __gmpz_mul_2exp\n__GMP_DECLSPEC void mpz_mul_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define __GMP_MPZ_MUL_SI_MIN_ALLOC(x,y,z) (__GMP_ABS(y->_mp_size)+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS+1)\n#define mpz_mul_si __gmpz_mul_si\n__GMP_DECLSPEC void mpz_mul_si __GMP_PROTO ((mpz_ptr, mpz_srcptr, long int));\n\n#define __GMP_MPZ_MUL_UI_MIN_ALLOC(x,y,z) (__GMP_ABS(y->_mp_size)+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS+1)\n#define mpz_mul_ui __gmpz_mul_ui\n__GMP_DECLSPEC void mpz_mul_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_neg __gmpz_neg\n#define __GMP_MPZ_NEG_MIN_ALLOC(x,y) (__GMP_ABS(y->_mp_size))\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_neg)\n__GMP_DECLSPEC void mpz_neg __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n#endif\n\n#define mpz_nextprime __gmpz_nextprime\n__GMP_DECLSPEC void mpz_nextprime __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n\n#define mpz_next_likely_prime __gmpz_next_likely_prime\n__GMP_DECLSPEC void mpz_next_likely_prime __GMP_PROTO ((mpz_ptr, mpz_srcptr,gmp_randstate_t));\n\n#define mpz_out_raw __gmpz_out_raw\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpz_out_raw __GMP_PROTO ((FILE *, mpz_srcptr));\n#endif\n\n#define mpz_out_str __gmpz_out_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpz_out_str __GMP_PROTO ((FILE *, int, mpz_srcptr));\n#endif\n\n#define mpz_perfect_power_p __gmpz_perfect_power_p\n__GMP_DECLSPEC int mpz_perfect_power_p __GMP_PROTO ((mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_perfect_square_p __gmpz_perfect_square_p\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_perfect_square_p)\n__GMP_DECLSPEC int mpz_perfect_square_p __GMP_PROTO ((mpz_srcptr)) __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_popcount __gmpz_popcount\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_popcount)\n__GMP_DECLSPEC mp_bitcnt_t mpz_popcount __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_pow_ui __gmpz_pow_ui\n__GMP_DECLSPEC void mpz_pow_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_powm __gmpz_powm\n__GMP_DECLSPEC void mpz_powm __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_powm_ui __gmpz_powm_ui\n__GMP_DECLSPEC void mpz_powm_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr));\n\n#define mpz_probab_prime_p __gmpz_probab_prime_p\n__GMP_DECLSPEC int mpz_probab_prime_p __GMP_PROTO ((mpz_srcptr, int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_probable_prime_p __gmpz_probable_prime_p\n__GMP_DECLSPEC int mpz_probable_prime_p __GMP_PROTO ((mpz_srcptr,gmp_randstate_t, int,unsigned long));\n\n#define mpz_likely_prime_p __gmpz_likely_prime_p\n__GMP_DECLSPEC int mpz_likely_prime_p __GMP_PROTO ((mpz_srcptr,gmp_randstate_t, unsigned long));\n\n#define mpz_realloc2 __gmpz_realloc2\n__GMP_DECLSPEC void mpz_realloc2 __GMP_PROTO ((mpz_ptr, mp_bitcnt_t));\n\n#define mpz_remove __gmpz_remove\n__GMP_DECLSPEC unsigned long int mpz_remove __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_root __gmpz_root\n__GMP_DECLSPEC int mpz_root __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_nthroot __gmpz_nthroot\n__GMP_DECLSPEC void mpz_nthroot __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_rootrem __gmpz_rootrem\n__GMP_DECLSPEC void mpz_rootrem __GMP_PROTO ((mpz_ptr,mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_rrandomb __gmpz_rrandomb\n__GMP_DECLSPEC void mpz_rrandomb __GMP_PROTO ((mpz_ptr, gmp_randstate_t, mp_bitcnt_t));\n\n#define mpz_scan0 __gmpz_scan0\n__GMP_DECLSPEC mp_bitcnt_t mpz_scan0 __GMP_PROTO ((mpz_srcptr, mp_bitcnt_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_scan1 __gmpz_scan1\n__GMP_DECLSPEC mp_bitcnt_t mpz_scan1 __GMP_PROTO ((mpz_srcptr, mp_bitcnt_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define __GMP_MPZ_SET_MIN_ALLOC(x,y) __GMP_ABS(y->_mp_size)\n#define mpz_set __gmpz_set\n__GMP_DECLSPEC void mpz_set __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n\n#define mpz_set_d __gmpz_set_d\n__GMP_DECLSPEC void mpz_set_d __GMP_PROTO ((mpz_ptr, double));\n\n#define mpz_set_f __gmpz_set_f\n__GMP_DECLSPEC void mpz_set_f __GMP_PROTO ((mpz_ptr, mpf_srcptr));\n\n#define mpz_set_q __gmpz_set_q\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_set_q)\n__GMP_DECLSPEC void mpz_set_q __GMP_PROTO ((mpz_ptr, mpq_srcptr));\n#endif\n\n#define __GMP_MPZ_SET_SI_MIN_ALLOC(x,y) (1+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS)\n#define mpz_set_si __gmpz_set_si\n__GMP_DECLSPEC void mpz_set_si __GMP_PROTO ((mpz_ptr, signed long int));\n\n#define mpz_set_str __gmpz_set_str\n__GMP_DECLSPEC int mpz_set_str __GMP_PROTO ((mpz_ptr, __gmp_const char *, int));\n\n#define __GMP_MPZ_SET_UI_MIN_ALLOC(x,y) (1+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS)\n#define mpz_set_ui __gmpz_set_ui\n__GMP_DECLSPEC void mpz_set_ui __GMP_PROTO ((mpz_ptr, unsigned long int));\n\n#define mpz_setbit __gmpz_setbit\n__GMP_DECLSPEC void mpz_setbit __GMP_PROTO ((mpz_ptr, mp_bitcnt_t));\n\n#define mpz_size __gmpz_size\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_size)\n__GMP_DECLSPEC size_t mpz_size __GMP_PROTO ((mpz_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpz_sizeinbase __gmpz_sizeinbase\n__GMP_DECLSPEC size_t mpz_sizeinbase __GMP_PROTO ((mpz_srcptr, int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_sqrt __gmpz_sqrt\n__GMP_DECLSPEC void mpz_sqrt __GMP_PROTO ((mpz_ptr, mpz_srcptr));\n\n#define mpz_sqrtrem __gmpz_sqrtrem\n__GMP_DECLSPEC void mpz_sqrtrem __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr));\n\n#define __GMP_MPZ_SUB_MIN_ALLOC(x,y,z) (__GMP_MAX(__GMP_ABS(y->_mp_size),__GMP_ABS(z->_mp_size))+1)\n#define mpz_sub __gmpz_sub\n__GMP_DECLSPEC void mpz_sub __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define __GMP_MPZ_SUB_UI_MIN_ALLOC(x,y,z) (__GMP_MAX(__GMP_ABS(y->_mp_size),1+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS)+1)\n#define mpz_sub_ui __gmpz_sub_ui\n__GMP_DECLSPEC void mpz_sub_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define __GMP_MPZ_UI_SUB_MIN_ALLOC(x,y,z) (__GMP_MAX(__GMP_ABS(z->_mp_size),1+(__GMP_BITS_PER_ULONG-1)/GMP_NUMB_BITS)+1)\n#define mpz_ui_sub __gmpz_ui_sub\n__GMP_DECLSPEC void mpz_ui_sub __GMP_PROTO ((mpz_ptr, unsigned long int, mpz_srcptr));\n\n#define mpz_submul __gmpz_submul\n__GMP_DECLSPEC void mpz_submul __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_submul_ui __gmpz_submul_ui\n__GMP_DECLSPEC void mpz_submul_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_swap __gmpz_swap\n__GMP_DECLSPEC void mpz_swap __GMP_PROTO ((mpz_ptr, mpz_ptr)) __GMP_NOTHROW;\n\n#define mpz_tdiv_ui __gmpz_tdiv_ui\n__GMP_DECLSPEC unsigned long int mpz_tdiv_ui __GMP_PROTO ((mpz_srcptr, unsigned long int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpz_tdiv_q __gmpz_tdiv_q\n__GMP_DECLSPEC void mpz_tdiv_q __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_tdiv_q_2exp __gmpz_tdiv_q_2exp\n__GMP_DECLSPEC void mpz_tdiv_q_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define mpz_tdiv_q_ui __gmpz_tdiv_q_ui\n__GMP_DECLSPEC unsigned long int mpz_tdiv_q_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_tdiv_qr __gmpz_tdiv_qr\n__GMP_DECLSPEC void mpz_tdiv_qr __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_tdiv_qr_ui __gmpz_tdiv_qr_ui\n__GMP_DECLSPEC unsigned long int mpz_tdiv_qr_ui __GMP_PROTO ((mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_tdiv_r __gmpz_tdiv_r\n__GMP_DECLSPEC void mpz_tdiv_r __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n#define mpz_tdiv_r_2exp __gmpz_tdiv_r_2exp\n__GMP_DECLSPEC void mpz_tdiv_r_2exp __GMP_PROTO ((mpz_ptr, mpz_srcptr, mp_bitcnt_t));\n\n#define mpz_tdiv_r_ui __gmpz_tdiv_r_ui\n__GMP_DECLSPEC unsigned long int mpz_tdiv_r_ui __GMP_PROTO ((mpz_ptr, mpz_srcptr, unsigned long int));\n\n#define mpz_tstbit __gmpz_tstbit\n__GMP_DECLSPEC int mpz_tstbit __GMP_PROTO ((mpz_srcptr, mp_bitcnt_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpz_ui_pow_ui __gmpz_ui_pow_ui\n__GMP_DECLSPEC void mpz_ui_pow_ui __GMP_PROTO ((mpz_ptr, unsigned long int, unsigned long int));\n\n#define mpz_urandomb __gmpz_urandomb\n__GMP_DECLSPEC void mpz_urandomb __GMP_PROTO ((mpz_ptr, gmp_randstate_t, mp_bitcnt_t));\n\n#define mpz_urandomm __gmpz_urandomm\n__GMP_DECLSPEC void mpz_urandomm __GMP_PROTO ((mpz_ptr, gmp_randstate_t, mpz_srcptr));\n\n#define mpz_xor __gmpz_xor\n#define mpz_eor __gmpz_xor\n__GMP_DECLSPEC void mpz_xor __GMP_PROTO ((mpz_ptr, mpz_srcptr, mpz_srcptr));\n\n\n/**************** Rational (i.e. Q) routines.  ****************/\n\n#define mpq_abs __gmpq_abs\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpq_abs)\n__GMP_DECLSPEC void mpq_abs __GMP_PROTO ((mpq_ptr, mpq_srcptr));\n#endif\n\n#define mpq_add __gmpq_add\n__GMP_DECLSPEC void mpq_add __GMP_PROTO ((mpq_ptr, mpq_srcptr, mpq_srcptr));\n\n#define mpq_canonicalize __gmpq_canonicalize\n__GMP_DECLSPEC void mpq_canonicalize __GMP_PROTO ((mpq_ptr));\n\n#define mpq_clear __gmpq_clear\n__GMP_DECLSPEC void mpq_clear __GMP_PROTO ((mpq_ptr));\n\n#define mpq_clears __gmpq_clears\n__GMP_DECLSPEC void mpq_clears __GMP_PROTO ((mpq_ptr, ...));\n\n#define mpq_cmp __gmpq_cmp\n__GMP_DECLSPEC int mpq_cmp __GMP_PROTO ((mpq_srcptr, mpq_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define _mpq_cmp_si __gmpq_cmp_si\n__GMP_DECLSPEC int _mpq_cmp_si __GMP_PROTO ((mpq_srcptr, long, unsigned long)) __GMP_ATTRIBUTE_PURE;\n\n#define _mpq_cmp_ui __gmpq_cmp_ui\n__GMP_DECLSPEC int _mpq_cmp_ui __GMP_PROTO ((mpq_srcptr, unsigned long int, unsigned long int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpq_div __gmpq_div\n__GMP_DECLSPEC void mpq_div __GMP_PROTO ((mpq_ptr, mpq_srcptr, mpq_srcptr));\n\n#define mpq_div_2exp __gmpq_div_2exp\n__GMP_DECLSPEC void mpq_div_2exp __GMP_PROTO ((mpq_ptr, mpq_srcptr, mp_bitcnt_t));\n\n#define mpq_equal __gmpq_equal\n__GMP_DECLSPEC int mpq_equal __GMP_PROTO ((mpq_srcptr, mpq_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpq_get_num __gmpq_get_num\n__GMP_DECLSPEC void mpq_get_num __GMP_PROTO ((mpz_ptr, mpq_srcptr));\n\n#define mpq_get_den __gmpq_get_den\n__GMP_DECLSPEC void mpq_get_den __GMP_PROTO ((mpz_ptr, mpq_srcptr));\n\n#define mpq_get_d __gmpq_get_d\n__GMP_DECLSPEC double mpq_get_d __GMP_PROTO ((mpq_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpq_get_str __gmpq_get_str\n__GMP_DECLSPEC char *mpq_get_str __GMP_PROTO ((char *, int, mpq_srcptr));\n\n#define mpq_init __gmpq_init\n__GMP_DECLSPEC void mpq_init __GMP_PROTO ((mpq_ptr));\n\n#define mpq_inits __gmpq_inits\n__GMP_DECLSPEC void mpq_inits __GMP_PROTO ((mpq_ptr, ...));\n\n#define mpq_inp_str __gmpq_inp_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpq_inp_str __GMP_PROTO ((mpq_ptr, FILE *, int));\n#endif\n\n#define mpq_inv __gmpq_inv\n__GMP_DECLSPEC void mpq_inv __GMP_PROTO ((mpq_ptr, mpq_srcptr));\n\n#define mpq_mul __gmpq_mul\n__GMP_DECLSPEC void mpq_mul __GMP_PROTO ((mpq_ptr, mpq_srcptr, mpq_srcptr));\n\n#define mpq_mul_2exp __gmpq_mul_2exp\n__GMP_DECLSPEC void mpq_mul_2exp __GMP_PROTO ((mpq_ptr, mpq_srcptr, mp_bitcnt_t));\n\n#define mpq_neg __gmpq_neg\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpq_neg)\n__GMP_DECLSPEC void mpq_neg __GMP_PROTO ((mpq_ptr, mpq_srcptr));\n#endif\n\n#define mpq_out_str __gmpq_out_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpq_out_str __GMP_PROTO ((FILE *, int, mpq_srcptr));\n#endif\n\n#define mpq_set __gmpq_set\n__GMP_DECLSPEC void mpq_set __GMP_PROTO ((mpq_ptr, mpq_srcptr));\n\n#define mpq_set_d __gmpq_set_d\n__GMP_DECLSPEC void mpq_set_d __GMP_PROTO ((mpq_ptr, double));\n\n#define mpq_set_den __gmpq_set_den\n__GMP_DECLSPEC void mpq_set_den __GMP_PROTO ((mpq_ptr, mpz_srcptr));\n\n#define mpq_set_f __gmpq_set_f\n__GMP_DECLSPEC void mpq_set_f __GMP_PROTO ((mpq_ptr, mpf_srcptr));\n\n#define mpq_set_num __gmpq_set_num\n__GMP_DECLSPEC void mpq_set_num __GMP_PROTO ((mpq_ptr, mpz_srcptr));\n\n#define mpq_set_si __gmpq_set_si\n__GMP_DECLSPEC void mpq_set_si __GMP_PROTO ((mpq_ptr, signed long int, unsigned long int));\n\n#define mpq_set_str __gmpq_set_str\n__GMP_DECLSPEC int mpq_set_str __GMP_PROTO ((mpq_ptr, __gmp_const char *, int));\n\n#define mpq_set_ui __gmpq_set_ui\n__GMP_DECLSPEC void mpq_set_ui __GMP_PROTO ((mpq_ptr, unsigned long int, unsigned long int));\n\n#define mpq_set_z __gmpq_set_z\n__GMP_DECLSPEC void mpq_set_z __GMP_PROTO ((mpq_ptr, mpz_srcptr));\n\n#define mpq_sub __gmpq_sub\n__GMP_DECLSPEC void mpq_sub __GMP_PROTO ((mpq_ptr, mpq_srcptr, mpq_srcptr));\n\n#define mpq_swap __gmpq_swap\n__GMP_DECLSPEC void mpq_swap __GMP_PROTO ((mpq_ptr, mpq_ptr)) __GMP_NOTHROW;\n\n\n/**************** Float (i.e. F) routines.  ****************/\n\n#define mpf_abs __gmpf_abs\n__GMP_DECLSPEC void mpf_abs __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_add __gmpf_add\n__GMP_DECLSPEC void mpf_add __GMP_PROTO ((mpf_ptr, mpf_srcptr, mpf_srcptr));\n\n#define mpf_add_ui __gmpf_add_ui\n__GMP_DECLSPEC void mpf_add_ui __GMP_PROTO ((mpf_ptr, mpf_srcptr, unsigned long int));\n#define mpf_ceil __gmpf_ceil\n__GMP_DECLSPEC void mpf_ceil __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_clear __gmpf_clear\n__GMP_DECLSPEC void mpf_clear __GMP_PROTO ((mpf_ptr));\n\n#define mpf_clears __gmpf_clears\n__GMP_DECLSPEC void mpf_clears __GMP_PROTO ((mpf_ptr, ...));\n\n#define mpf_cmp __gmpf_cmp\n__GMP_DECLSPEC int mpf_cmp __GMP_PROTO ((mpf_srcptr, mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_cmp_d __gmpf_cmp_d\n__GMP_DECLSPEC int mpf_cmp_d __GMP_PROTO ((mpf_srcptr, double)) __GMP_ATTRIBUTE_PURE;\n\n#define mpf_cmp_si __gmpf_cmp_si\n__GMP_DECLSPEC int mpf_cmp_si __GMP_PROTO ((mpf_srcptr, signed long int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_cmp_ui __gmpf_cmp_ui\n__GMP_DECLSPEC int mpf_cmp_ui __GMP_PROTO ((mpf_srcptr, unsigned long int)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_div __gmpf_div\n__GMP_DECLSPEC void mpf_div __GMP_PROTO ((mpf_ptr, mpf_srcptr, mpf_srcptr));\n\n#define mpf_div_2exp __gmpf_div_2exp\n__GMP_DECLSPEC void mpf_div_2exp __GMP_PROTO ((mpf_ptr, mpf_srcptr, mp_bitcnt_t));\n\n#define mpf_div_ui __gmpf_div_ui\n__GMP_DECLSPEC void mpf_div_ui __GMP_PROTO ((mpf_ptr, mpf_srcptr, unsigned long int));\n\n#define mpf_dump __gmpf_dump\n__GMP_DECLSPEC void mpf_dump __GMP_PROTO ((mpf_srcptr));\n\n#define mpf_eq __gmpf_eq\n__GMP_DECLSPEC int mpf_eq __GMP_PROTO ((mpf_srcptr, mpf_srcptr, unsigned long int)) __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_sint_p __gmpf_fits_sint_p\n__GMP_DECLSPEC int mpf_fits_sint_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_slong_p __gmpf_fits_slong_p\n__GMP_DECLSPEC int mpf_fits_slong_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_sshort_p __gmpf_fits_sshort_p\n__GMP_DECLSPEC int mpf_fits_sshort_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_uint_p __gmpf_fits_uint_p\n__GMP_DECLSPEC int mpf_fits_uint_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_ulong_p __gmpf_fits_ulong_p\n__GMP_DECLSPEC int mpf_fits_ulong_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_fits_ushort_p __gmpf_fits_ushort_p\n__GMP_DECLSPEC int mpf_fits_ushort_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_floor __gmpf_floor\n__GMP_DECLSPEC void mpf_floor __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_get_d __gmpf_get_d\n__GMP_DECLSPEC double mpf_get_d __GMP_PROTO ((mpf_srcptr)) __GMP_ATTRIBUTE_PURE;\n\n#define mpf_get_d_2exp __gmpf_get_d_2exp\n__GMP_DECLSPEC double mpf_get_d_2exp __GMP_PROTO ((signed long int *, mpf_srcptr));\n\n#define mpf_get_default_prec __gmpf_get_default_prec\n__GMP_DECLSPEC mp_bitcnt_t mpf_get_default_prec __GMP_PROTO ((void)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_get_prec __gmpf_get_prec\n__GMP_DECLSPEC mp_bitcnt_t mpf_get_prec __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_get_si __gmpf_get_si\n__GMP_DECLSPEC long mpf_get_si __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_get_str __gmpf_get_str\n__GMP_DECLSPEC char *mpf_get_str __GMP_PROTO ((char *, mp_exp_t *, int, size_t, mpf_srcptr));\n\n#define mpf_get_ui __gmpf_get_ui\n__GMP_DECLSPEC unsigned long mpf_get_ui __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_init __gmpf_init\n__GMP_DECLSPEC void mpf_init __GMP_PROTO ((mpf_ptr));\n\n#define mpf_init2 __gmpf_init2\n__GMP_DECLSPEC void mpf_init2 __GMP_PROTO ((mpf_ptr, mp_bitcnt_t));\n\n#define mpf_inits __gmpf_inits\n__GMP_DECLSPEC void mpf_inits __GMP_PROTO ((mpf_ptr, ...));\n\n#define mpf_init_set __gmpf_init_set\n__GMP_DECLSPEC void mpf_init_set __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_init_set_d __gmpf_init_set_d\n__GMP_DECLSPEC void mpf_init_set_d __GMP_PROTO ((mpf_ptr, double));\n\n#define mpf_init_set_si __gmpf_init_set_si\n__GMP_DECLSPEC void mpf_init_set_si __GMP_PROTO ((mpf_ptr, signed long int));\n\n#define mpf_init_set_str __gmpf_init_set_str\n__GMP_DECLSPEC int mpf_init_set_str __GMP_PROTO ((mpf_ptr, __gmp_const char *, int));\n\n#define mpf_init_set_ui __gmpf_init_set_ui\n__GMP_DECLSPEC void mpf_init_set_ui __GMP_PROTO ((mpf_ptr, unsigned long int));\n\n#define mpf_inp_str __gmpf_inp_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpf_inp_str __GMP_PROTO ((mpf_ptr, FILE *, int));\n#endif\n\n#define mpf_integer_p __gmpf_integer_p\n__GMP_DECLSPEC int mpf_integer_p __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_mul __gmpf_mul\n__GMP_DECLSPEC void mpf_mul __GMP_PROTO ((mpf_ptr, mpf_srcptr, mpf_srcptr));\n\n#define mpf_mul_2exp __gmpf_mul_2exp\n__GMP_DECLSPEC void mpf_mul_2exp __GMP_PROTO ((mpf_ptr, mpf_srcptr, mp_bitcnt_t));\n\n#define mpf_mul_ui __gmpf_mul_ui\n__GMP_DECLSPEC void mpf_mul_ui __GMP_PROTO ((mpf_ptr, mpf_srcptr, unsigned long int));\n\n#define mpf_neg __gmpf_neg\n__GMP_DECLSPEC void mpf_neg __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_out_str __gmpf_out_str\n#ifdef _GMP_H_HAVE_FILE\n__GMP_DECLSPEC size_t mpf_out_str __GMP_PROTO ((FILE *, int, size_t, mpf_srcptr));\n#endif\n\n#define mpf_pow_ui __gmpf_pow_ui\n__GMP_DECLSPEC void mpf_pow_ui __GMP_PROTO ((mpf_ptr, mpf_srcptr, unsigned long int));\n\n#define mpf_random2 __gmpf_random2\n__GMP_DECLSPEC void mpf_random2 __GMP_PROTO ((mpf_ptr, mp_size_t, mp_exp_t));\n\n#define mpf_rrandomb __gmpf_rrandomb\n__GMP_DECLSPEC void mpf_rrandomb __GMP_PROTO ((mpf_ptr, gmp_randstate_t, mp_size_t, mp_exp_t));\n\n#define mpf_reldiff __gmpf_reldiff\n__GMP_DECLSPEC void mpf_reldiff __GMP_PROTO ((mpf_ptr, mpf_srcptr, mpf_srcptr));\n\n#define mpf_set __gmpf_set\n__GMP_DECLSPEC void mpf_set __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_set_d __gmpf_set_d\n__GMP_DECLSPEC void mpf_set_d __GMP_PROTO ((mpf_ptr, double));\n\n#define mpf_set_default_prec __gmpf_set_default_prec\n__GMP_DECLSPEC void mpf_set_default_prec __GMP_PROTO ((mp_bitcnt_t)) __GMP_NOTHROW;\n\n#define mpf_set_prec __gmpf_set_prec\n__GMP_DECLSPEC void mpf_set_prec __GMP_PROTO ((mpf_ptr, mp_bitcnt_t));\n\n#define mpf_set_prec_raw __gmpf_set_prec_raw\n__GMP_DECLSPEC void mpf_set_prec_raw __GMP_PROTO ((mpf_ptr, mp_bitcnt_t)) __GMP_NOTHROW;\n\n#define mpf_set_q __gmpf_set_q\n__GMP_DECLSPEC void mpf_set_q __GMP_PROTO ((mpf_ptr, mpq_srcptr));\n\n#define mpf_set_si __gmpf_set_si\n__GMP_DECLSPEC void mpf_set_si __GMP_PROTO ((mpf_ptr, signed long int));\n\n#define mpf_set_str __gmpf_set_str\n__GMP_DECLSPEC int mpf_set_str __GMP_PROTO ((mpf_ptr, __gmp_const char *, int));\n\n#define mpf_set_ui __gmpf_set_ui\n__GMP_DECLSPEC void mpf_set_ui __GMP_PROTO ((mpf_ptr, unsigned long int));\n\n#define mpf_set_z __gmpf_set_z\n__GMP_DECLSPEC void mpf_set_z __GMP_PROTO ((mpf_ptr, mpz_srcptr));\n\n#define mpf_size __gmpf_size\n__GMP_DECLSPEC size_t mpf_size __GMP_PROTO ((mpf_srcptr)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpf_sqrt __gmpf_sqrt\n__GMP_DECLSPEC void mpf_sqrt __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_sqrt_ui __gmpf_sqrt_ui\n__GMP_DECLSPEC void mpf_sqrt_ui __GMP_PROTO ((mpf_ptr, unsigned long int));\n\n#define mpf_sub __gmpf_sub\n__GMP_DECLSPEC void mpf_sub __GMP_PROTO ((mpf_ptr, mpf_srcptr, mpf_srcptr));\n\n#define mpf_sub_ui __gmpf_sub_ui\n__GMP_DECLSPEC void mpf_sub_ui __GMP_PROTO ((mpf_ptr, mpf_srcptr, unsigned long int));\n\n#define mpf_swap __gmpf_swap\n__GMP_DECLSPEC void mpf_swap __GMP_PROTO ((mpf_ptr, mpf_ptr)) __GMP_NOTHROW;\n\n#define mpf_trunc __gmpf_trunc\n__GMP_DECLSPEC void mpf_trunc __GMP_PROTO ((mpf_ptr, mpf_srcptr));\n\n#define mpf_ui_div __gmpf_ui_div\n__GMP_DECLSPEC void mpf_ui_div __GMP_PROTO ((mpf_ptr, unsigned long int, mpf_srcptr));\n\n#define mpf_ui_sub __gmpf_ui_sub\n__GMP_DECLSPEC void mpf_ui_sub __GMP_PROTO ((mpf_ptr, unsigned long int, mpf_srcptr));\n\n#define mpf_urandomb __gmpf_urandomb\n__GMP_DECLSPEC void mpf_urandomb __GMP_PROTO ((mpf_t, gmp_randstate_t, mp_bitcnt_t));\n\n\n/************ Low level positive-integer (i.e. N) routines.  ************/\n\n/* This is ugly, but we need to make user calls reach the prefixed function. */\n\n#define mpn_add __MPN(add)\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_add)\n__GMP_DECLSPEC mp_limb_t mpn_add __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t));\n#endif\n\n#define mpn_add_1 __MPN(add_1)\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_add_1)\n__GMP_DECLSPEC mp_limb_t mpn_add_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)) __GMP_NOTHROW;\n#endif\n\n#define mpn_add_n __MPN(add_n)\n__GMP_DECLSPEC mp_limb_t mpn_add_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n\n#define mpn_addmul_1 __MPN(addmul_1)\n__GMP_DECLSPEC mp_limb_t mpn_addmul_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t));\n\n#define mpn_bdivmod __MPN(bdivmod)\n__GMP_DECLSPEC mp_limb_t mpn_bdivmod __GMP_PROTO ((mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, unsigned long int));\n\n#define mpn_divrem __MPN(divrem)\n__GMP_DECLSPEC mp_limb_t mpn_divrem __GMP_PROTO ((mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t));\n\n#define mpn_mulmod_2expp1 __MPN(mulmod_2expp1)\n__GMP_DECLSPEC int mpn_mulmod_2expp1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr,int,unsigned long, mp_ptr));\n\n#define mpn_mulmod_2expm1 __MPN(mulmod_2expm1)\n__GMP_DECLSPEC void mpn_mulmod_2expm1 __GMP_PROTO ((mp_ptr, mp_ptr, mp_ptr,unsigned long, mp_ptr));\n\n#define mpn_cmp __MPN(cmp)\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_cmp)\n__GMP_DECLSPEC int mpn_cmp __GMP_PROTO ((mp_srcptr, mp_srcptr, mp_size_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n#endif\n\n#define mpn_divexact_by3(dst,src,size) \\\n  mpn_divexact_by3c (dst, src, size, __GMP_CAST (mp_limb_t, 0))\n\n#define mpn_divexact_by3c __MPN(divexact_by3c)\n__GMP_DECLSPEC mp_limb_t mpn_divexact_by3c __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t));\n\n#define mpn_divmod_1(qp,np,nsize,dlimb) \\\n  mpn_divrem_1 (qp, __GMP_CAST (mp_size_t, 0), np, nsize, dlimb)\n\n#define mpn_divrem_1 __MPN(divrem_1)\n__GMP_DECLSPEC mp_limb_t mpn_divrem_1 __GMP_PROTO ((mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t));\n\n#define mpn_divrem_2 __MPN(divrem_2)\n__GMP_DECLSPEC mp_limb_t mpn_divrem_2 __GMP_PROTO ((mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr));\n\n#define mpn_invert __MPN(invert)\n__GMP_DECLSPEC void mpn_invert __GMP_PROTO ((mp_ptr xp, mp_srcptr ap, mp_size_t n));\n\n#define mpn_sb_divappr_q __MPN(sb_divappr_q)\n__GMP_DECLSPEC mp_limb_t mpn_sb_divappr_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t  mp_srcptr dp, mp_size_t dn, mp_limb_t dip)); \n\n#define mpn_dc_divappr_q_n __MPN(dc_divappr_q_n)\n__GMP_DECLSPEC mp_limb_t mpn_dc_divappr_q_n __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, \n\t\t         mp_limb_t dip, mp_ptr tp));\n\n#define mpn_dc_bdiv_q_n __MPN(dc_bdiv_q_n)\n__GMP_DECLSPEC void mpn_dc_bdiv_q_n __GMP_PROTO ((mp_ptr qp, mp_ptr wp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n                 mp_limb_t dinv, mp_ptr scratch));\n\n#define mpn_inv_divappr_q_n __MPN(inv_divappr_q_n)\n__GMP_DECLSPEC mp_limb_t mpn_inv_divappr_q_n __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n                         mp_srcptr dip));\n\n#define mpn_dc_divappr_q __MPN(dc_divappr_q)\n__GMP_DECLSPEC mp_limb_t mpn_dc_divappr_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n,\n                 mp_limb_t dinv));\n\n#define mpn_dc_div_q __MPN(dc_div_q)\n__GMP_DECLSPEC mp_limb_t mpn_dc_div_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_inv_divappr_q __MPN(inv_divappr_q)\n__GMP_DECLSPEC mp_limb_t mpn_inv_divappr_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n,\n                 mp_srcptr dinv));\n\n#define mpn_inv_div_q __MPN(inv_div_q)\n__GMP_DECLSPEC mp_limb_t mpn_inv_div_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_srcptr dinv));\n\n#define mpn_inv_div_qr __MPN(inv_div_qr)\n__GMP_DECLSPEC mp_limb_t mpn_inv_div_qr __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_srcptr dinv));\n\n#define mpn_inv_div_qr_n __MPN(inv_div_qr_n)\n__GMP_DECLSPEC mp_limb_t mpn_inv_div_qr_n __GMP_PROTO ((mp_ptr qp, mp_ptr np,\n         mp_srcptr dp, mp_size_t dn, mp_srcptr dinv));\n\n#define mpn_dc_div_qr __MPN(dc_div_qr)\n__GMP_DECLSPEC mp_limb_t mpn_dc_div_qr __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_dc_div_qr_n __MPN(dc_div_qr_n)\n__GMP_DECLSPEC mp_limb_t mpn_dc_div_qr_n __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n,\n         mp_limb_t dinv, mp_ptr tp));\n\n#define mpn_sb_div_q __MPN(sb_div_q)\n__GMP_DECLSPEC mp_limb_t mpn_sb_div_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_sb_bdiv_q __MPN(sb_bdiv_q)\n__GMP_DECLSPEC void mpn_sb_bdiv_q __GMP_PROTO ((mp_ptr qp, mp_ptr wp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_dc_bdiv_q __MPN(dc_bdiv_q)\n__GMP_DECLSPEC void mpn_dc_bdiv_q __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_dc_bdiv_qr __MPN(dc_bdiv_qr)\n__GMP_DECLSPEC mp_limb_t mpn_dc_bdiv_qr __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_dc_bdiv_qr_n __MPN(dc_bdiv_qr_n)\n__GMP_DECLSPEC mp_limb_t mpn_dc_bdiv_qr_n __GMP_PROTO ((mp_ptr qp, mp_ptr np,\n         mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp));\n\n#define mpn_sb_div_qr __MPN(sb_div_qr)\n__GMP_DECLSPEC mp_limb_t mpn_sb_div_qr __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_sb_bdiv_qr __MPN(sb_bdiv_qr)\n__GMP_DECLSPEC mp_limb_t mpn_sb_bdiv_qr __GMP_PROTO ((mp_ptr qp, mp_ptr np, mp_size_t nn,\n         mp_srcptr dp, mp_size_t dn, mp_limb_t dinv));\n\n#define mpn_tdiv_q __MPN(tdiv_q)\n__GMP_DECLSPEC void mpn_tdiv_q __GMP_PROTO ((mp_ptr qp, mp_srcptr np, mp_size_t nn, \n                                   mp_srcptr dp, mp_size_t dn));\n\n#define mpn_divexact __MPN(divexact)\n__GMP_DECLSPEC void  mpn_divexact __GMP_PROTO ((mp_ptr qp,\n\t      mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn));\n\n#define mpn_redc_1 __MPN(redc_1)\n__GMP_DECLSPEC void mpn_redc_1 __GMP_PROTO ((mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);)\n\n#define mpn_gcd __MPN(gcd)\n__GMP_DECLSPEC mp_size_t mpn_gcd __GMP_PROTO ((mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t));\n\n#define mpn_gcd_1 __MPN(gcd_1)\n__GMP_DECLSPEC mp_limb_t mpn_gcd_1 __GMP_PROTO ((mp_srcptr, mp_size_t, mp_limb_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_gcdext __MPN(gcdext)\n__GMP_DECLSPEC mp_size_t mpn_gcdext __GMP_PROTO ((mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t));\n\n#define mpn_get_str __MPN(get_str)\n__GMP_DECLSPEC size_t mpn_get_str __GMP_PROTO ((unsigned char *, int, mp_ptr, mp_size_t));\n\n#define mpn_hamdist __MPN(hamdist)\n__GMP_DECLSPEC mp_bitcnt_t mpn_hamdist __GMP_PROTO ((mp_srcptr, mp_srcptr, mp_size_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpn_lshift __MPN(lshift)\n__GMP_DECLSPEC mp_limb_t mpn_lshift __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, unsigned int));\n\n#define mpn_mod_1 __MPN(mod_1)\n__GMP_DECLSPEC mp_limb_t mpn_mod_1 __GMP_PROTO ((mp_srcptr, mp_size_t, mp_limb_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_mul __MPN(mul)\n__GMP_DECLSPEC mp_limb_t mpn_mul __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t));\n\n#define mpn_mul_1 __MPN(mul_1)\n__GMP_DECLSPEC mp_limb_t mpn_mul_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t));\n\n#define mpn_mul_n __MPN(mul_n)\n__GMP_DECLSPEC void mpn_mul_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n\n#define mpn_sqr   __MPN(sqr)\n__GMP_DECLSPEC void mpn_sqr __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t));\n\n#define mpn_neg_n __MPN(neg_n)\n#define mpn_neg   __MPN(neg_n)\n__GMP_DECLSPEC mp_limb_t mpn_neg_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t));\n\n#define mpn_com_n __MPN(com_n)\n#define mpn_com   __MPN(com_n)\n__GMP_DECLSPEC void mpn_com_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t));\n\n#define mpn_perfect_square_p __MPN(perfect_square_p)\n__GMP_DECLSPEC int mpn_perfect_square_p __GMP_PROTO ((mp_srcptr, mp_size_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_popcount __MPN(popcount)\n__GMP_DECLSPEC mp_bitcnt_t mpn_popcount __GMP_PROTO ((mp_srcptr, mp_size_t)) __GMP_NOTHROW __GMP_ATTRIBUTE_PURE;\n\n#define mpn_pow_1 __MPN(pow_1)\n__GMP_DECLSPEC mp_size_t mpn_pow_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr));\n\n/* undocumented now, but retained here for upward compatibility */\n#define mpn_preinv_mod_1 __MPN(preinv_mod_1)\n__GMP_DECLSPEC mp_limb_t mpn_preinv_mod_1 __GMP_PROTO ((mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_random __MPN(random)\n__GMP_DECLSPEC void mpn_random __GMP_PROTO ((mp_ptr, mp_size_t));\n\n#define mpn_random2 __MPN(random2)\n__GMP_DECLSPEC void mpn_random2 __GMP_PROTO ((mp_ptr, mp_size_t));\n\n#define mpn_urandomb __MPN(urandomb)\n__GMP_DECLSPEC void mpn_urandomb __GMP_PROTO ((mp_ptr, gmp_randstate_t, unsigned long));\n\n#define mpn_urandomm __MPN(urandomm)\n__GMP_DECLSPEC void mpn_urandomm __GMP_PROTO ((mp_ptr, gmp_randstate_t, mp_srcptr, mp_size_t));\n\n#define mpn_randomb __MPN(randomb)\n__GMP_DECLSPEC void mpn_randomb __GMP_PROTO ((mp_ptr, gmp_randstate_t, mp_size_t));\n\n#define mpn_rrandom __MPN(rrandom)\n__GMP_DECLSPEC void mpn_rrandom __GMP_PROTO ((mp_ptr, gmp_randstate_t, mp_size_t));\n\n#define mpn_rshift __MPN(rshift)\n__GMP_DECLSPEC mp_limb_t mpn_rshift __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, unsigned int));\n\n#define mpn_scan0 __MPN(scan0)\n__GMP_DECLSPEC mp_bitcnt_t mpn_scan0 __GMP_PROTO ((mp_srcptr, mp_bitcnt_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_scan1 __MPN(scan1)\n__GMP_DECLSPEC mp_bitcnt_t mpn_scan1 __GMP_PROTO ((mp_srcptr, mp_bitcnt_t)) __GMP_ATTRIBUTE_PURE;\n\n#define mpn_set_str __MPN(set_str)\n__GMP_DECLSPEC mp_size_t mpn_set_str __GMP_PROTO ((mp_ptr, __gmp_const unsigned char *, size_t, int));\n\n#define mpn_sqrtrem __MPN(sqrtrem)\n__GMP_DECLSPEC mp_size_t mpn_sqrtrem __GMP_PROTO ((mp_ptr, mp_ptr, mp_srcptr, mp_size_t));\n\n#define mpn_sub __MPN(sub)\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_sub)\n__GMP_DECLSPEC mp_limb_t mpn_sub __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t));\n#endif\n\n#define mpn_sub_1 __MPN(sub_1)\n#if __GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_sub_1)\n__GMP_DECLSPEC mp_limb_t mpn_sub_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)) __GMP_NOTHROW;\n#endif\n\n#define mpn_sub_n __MPN(sub_n)\n__GMP_DECLSPEC mp_limb_t mpn_sub_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n\n#define mpn_submul_1 __MPN(submul_1)\n__GMP_DECLSPEC mp_limb_t mpn_submul_1 __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t, mp_limb_t));\n\n#define mpn_tdiv_qr __MPN(tdiv_qr)\n__GMP_DECLSPEC void mpn_tdiv_qr __GMP_PROTO ((mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t));\n\n#define mpn_and_n __MPN(and_n)\n__GMP_DECLSPEC void mpn_and_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_andn_n __MPN(andn_n)\n__GMP_DECLSPEC void mpn_andn_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_nand_n __MPN(nand_n)\n__GMP_DECLSPEC void mpn_nand_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_ior_n __MPN(ior_n)\n__GMP_DECLSPEC void mpn_ior_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_iorn_n __MPN(iorn_n)\n__GMP_DECLSPEC void mpn_iorn_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_nior_n __MPN(nior_n)\n__GMP_DECLSPEC void mpn_nior_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_xor_n __MPN(xor_n)\n__GMP_DECLSPEC void mpn_xor_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n#define mpn_xnor_n __MPN(xnor_n)\n__GMP_DECLSPEC void mpn_xnor_n __GMP_PROTO ((mp_ptr, mp_srcptr, mp_srcptr, mp_size_t));\n\n#define mpn_copyi __MPN(copyi)\n__GMP_DECLSPEC void mpn_copyi __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t));\n#define mpn_copyd __MPN(copyd)\n__GMP_DECLSPEC void mpn_copyd __GMP_PROTO ((mp_ptr, mp_srcptr, mp_size_t));\n#define mpn_zero __MPN(zero)\n__GMP_DECLSPEC void mpn_zero __GMP_PROTO ((mp_ptr, mp_size_t));\n\n/**************** mpz inlines ****************/\n\n/* The following are provided as inlines where possible, but always exist as\n   library functions too, for binary compatibility.\n\n   Within gmp itself this inlining generally isn't relied on, since it\n   doesn't get done for all compilers, whereas if something is worth\n   inlining then it's worth arranging always.\n\n   There are two styles of inlining here.  When the same bit of code is\n   wanted for the inline as for the library version, then __GMP_FORCE_foo\n   arranges for that code to be emitted and the __GMP_EXTERN_INLINE\n   directive suppressed, eg. mpz_fits_uint_p.  When a different bit of code\n   is wanted for the inline than for the library version, then\n   __GMP_FORCE_foo arranges the inline to be suppressed, eg. mpz_abs.  */\n\n#if defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpz_abs)\n__GMP_EXTERN_INLINE void\nmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)\n{\n  if (__gmp_w != __gmp_u)\n    mpz_set (__gmp_w, __gmp_u);\n  __gmp_w->_mp_size = __GMP_ABS (__gmp_w->_mp_size);\n}\n#endif\n\n#if GMP_NAIL_BITS == 0\n#define __GMPZ_FITS_UTYPE_P(z,maxval)\t\t\t\t\t\\\n  mp_size_t  __gmp_n = z->_mp_size;\t\t\t\t\t\\\n  mp_ptr  __gmp_p = z->_mp_d;\t\t\t\t\t\t\\\n  return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= maxval));\n#else\n#define __GMPZ_FITS_UTYPE_P(z,maxval)\t\t\t\t\t\\\n  mp_size_t  __gmp_n = z->_mp_size;\t\t\t\t\t\\\n  mp_ptr  __gmp_p = z->_mp_d;\t\t\t\t\t\t\\\n  return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= maxval)\t\\\n\t  || (__gmp_n == 2 && __gmp_p[1] <= ((mp_limb_t) maxval >> GMP_NUMB_BITS)));\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_uint_p)\n#if ! defined (__GMP_FORCE_mpz_fits_uint_p)\n__GMP_EXTERN_INLINE\n#endif\nint\nmpz_fits_uint_p (mpz_srcptr __gmp_z) __GMP_NOTHROW\n{\n  __GMPZ_FITS_UTYPE_P (__gmp_z, __GMP_UINT_MAX);\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_ulong_p)\n#if ! defined (__GMP_FORCE_mpz_fits_ulong_p)\n__GMP_EXTERN_INLINE\n#endif\nint\nmpz_fits_ulong_p (mpz_srcptr __gmp_z) __GMP_NOTHROW\n{\n  __GMPZ_FITS_UTYPE_P (__gmp_z, __GMP_ULONG_MAX);\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_ushort_p)\n#if ! defined (__GMP_FORCE_mpz_fits_ushort_p)\n__GMP_EXTERN_INLINE\n#endif\nint\nmpz_fits_ushort_p (mpz_srcptr __gmp_z) __GMP_NOTHROW\n{\n  __GMPZ_FITS_UTYPE_P (__gmp_z, __GMP_USHRT_MAX);\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_get_ui)\n#if ! defined (__GMP_FORCE_mpz_get_ui)\n__GMP_EXTERN_INLINE\n#endif\nunsigned long\nmpz_get_ui (mpz_srcptr __gmp_z) __GMP_NOTHROW\n{\n  mp_ptr __gmp_p = __gmp_z->_mp_d;\n  mp_size_t __gmp_n = __gmp_z->_mp_size;\n  mp_limb_t __gmp_l = __gmp_p[0];\n  /* This is a \"#if\" rather than a plain \"if\" so as to avoid gcc warnings\n     about \"<< GMP_NUMB_BITS\" exceeding the type size, and to avoid Borland\n     C++ 6.0 warnings about condition always true for something like\n     \"__GMP_ULONG_MAX < GMP_NUMB_MASK\".  */\n#if GMP_NAIL_BITS == 0 || defined (_LONG_LONG_LIMB)\n  /* limb==long and no nails, or limb==longlong, one limb is enough */\n  return (unsigned long)(__gmp_n != 0 ? __gmp_l : 0);\n#else\n  /* limb==long and nails, need two limbs when available */\n  __gmp_n = __GMP_ABS (__gmp_n);\n  if (__gmp_n <= 1)\n    return (__gmp_n != 0 ? __gmp_l : 0);\n  else\n    return __gmp_l + (__gmp_p[1] << GMP_NUMB_BITS);\n#endif\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_getlimbn)\n#if ! defined (__GMP_FORCE_mpz_getlimbn)\n__GMP_EXTERN_INLINE\n#endif\nmp_limb_t\nmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) __GMP_NOTHROW\n{\n  mp_limb_t  __gmp_result = 0;\n  if (__GMP_LIKELY (__gmp_n >= 0 && __gmp_n < __GMP_ABS (__gmp_z->_mp_size)))\n    __gmp_result = __gmp_z->_mp_d[__gmp_n];\n  return __gmp_result;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpz_neg)\n__GMP_EXTERN_INLINE void\nmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)\n{\n  if (__gmp_w != __gmp_u)\n    mpz_set (__gmp_w, __gmp_u);\n  __gmp_w->_mp_size = - __gmp_w->_mp_size;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_perfect_square_p)\n#if ! defined (__GMP_FORCE_mpz_perfect_square_p)\n__GMP_EXTERN_INLINE\n#endif\nint\nmpz_perfect_square_p (mpz_srcptr __gmp_a)\n{\n  mp_size_t __gmp_asize;\n  int       __gmp_result;\n\n  __gmp_asize = __gmp_a->_mp_size;\n  __gmp_result = (__gmp_asize >= 0);  /* zero is a square, negatives are not */\n  if (__GMP_LIKELY (__gmp_asize > 0))\n    __gmp_result = mpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);\n  return __gmp_result;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_popcount)\n#if ! defined (__GMP_FORCE_mpz_popcount)\n__GMP_EXTERN_INLINE\n#endif\nmp_bitcnt_t\nmpz_popcount (mpz_srcptr __gmp_u) __GMP_NOTHROW\n{\n  mp_size_t      __gmp_usize;\n  mp_bitcnt_t    __gmp_result;\n\n  __gmp_usize = __gmp_u->_mp_size;\n  __gmp_result = (__gmp_usize < 0 ? __GMP_ULONG_MAX : 0);\n  if (__GMP_LIKELY (__gmp_usize > 0))\n    __gmp_result =  mpn_popcount (__gmp_u->_mp_d, __gmp_usize);\n  return __gmp_result;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_set_q)\n#if ! defined (__GMP_FORCE_mpz_set_q)\n__GMP_EXTERN_INLINE\n#endif\nvoid\nmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)\n{\n  mpz_tdiv_q (__gmp_w, mpq_numref (__gmp_u), mpq_denref (__gmp_u));\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_size)\n#if ! defined (__GMP_FORCE_mpz_size)\n__GMP_EXTERN_INLINE\n#endif\nsize_t\nmpz_size (mpz_srcptr __gmp_z) __GMP_NOTHROW\n{\n  return __GMP_ABS (__gmp_z->_mp_size);\n}\n#endif\n\n\n/**************** mpq inlines ****************/\n\n#if defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpq_abs)\n__GMP_EXTERN_INLINE void\nmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)\n{\n  if (__gmp_w != __gmp_u)\n    mpq_set (__gmp_w, __gmp_u);\n  __gmp_w->_mp_num._mp_size = __GMP_ABS (__gmp_w->_mp_num._mp_size);\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpq_neg)\n__GMP_EXTERN_INLINE void\nmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)\n{\n  if (__gmp_w != __gmp_u)\n    mpq_set (__gmp_w, __gmp_u);\n  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;\n}\n#endif\n\n\n/**************** mpn inlines ****************/\n\n/* The comments with __GMPN_ADD_1 below apply here too.\n\n   The test for FUNCTION returning 0 should predict well.  If it's assumed\n   {yp,ysize} will usually have a random number of bits then the high limb\n   won't be full and a carry out will occur a good deal less than 50% of the\n   time.\n\n   ysize==0 isn't a documented feature, but is used internally in a few\n   places.\n\n   Producing cout last stops it using up a register during the main part of\n   the calculation, though gcc (as of 3.0) on an \"if (mpn_add (...))\"\n   doesn't seem able to move the true and false legs of the conditional up\n   to the two places cout is generated.  */\n\n#define __GMPN_AORS(cout, wp, xp, xsize, yp, ysize, FUNCTION, TEST)     \\\n  do {                                                                  \\\n    mp_size_t  __gmp_i;                                                 \\\n    mp_limb_t  __gmp_x;                                                 \\\n                                                                        \\\n    /* ASSERT ((ysize) >= 0); */                                        \\\n    /* ASSERT ((xsize) >= (ysize)); */                                  \\\n    /* ASSERT (MPN_SAME_OR_SEPARATE2_P (wp, xsize, xp, xsize)); */      \\\n    /* ASSERT (MPN_SAME_OR_SEPARATE2_P (wp, xsize, yp, ysize)); */      \\\n                                                                        \\\n    __gmp_i = (ysize);                                                  \\\n    if (__gmp_i != 0)                                                   \\\n      {                                                                 \\\n        if (FUNCTION (wp, xp, yp, __gmp_i))                             \\\n          {                                                             \\\n            do                                                          \\\n              {                                                         \\\n                if (__gmp_i >= (xsize))                                 \\\n                  {                                                     \\\n                    (cout) = 1;                                         \\\n                    goto __gmp_done;                                    \\\n                  }                                                     \\\n                __gmp_x = (xp)[__gmp_i];                                \\\n              }                                                         \\\n            while (TEST);                                               \\\n          }                                                             \\\n      }                                                                 \\\n    if ((wp) != (xp))                                                   \\\n      __GMPN_COPY_REST (wp, xp, xsize, __gmp_i);                        \\\n    (cout) = 0;                                                         \\\n  __gmp_done:                                                           \\\n    ;                                                                   \\\n  } while (0)\n\n#define __GMPN_ADD(cout, wp, xp, xsize, yp, ysize)              \\\n  __GMPN_AORS (cout, wp, xp, xsize, yp, ysize, mpn_add_n,       \\\n               (((wp)[__gmp_i++] = (__gmp_x + 1) & GMP_NUMB_MASK) == 0))\n#define __GMPN_SUB(cout, wp, xp, xsize, yp, ysize)              \\\n  __GMPN_AORS (cout, wp, xp, xsize, yp, ysize, mpn_sub_n,       \\\n               (((wp)[__gmp_i++] = (__gmp_x - 1) & GMP_NUMB_MASK), __gmp_x == 0))\n\n\n/* The use of __gmp_i indexing is designed to ensure a compile time src==dst\n   remains nice and clear to the compiler, so that __GMPN_COPY_REST can\n   disappear, and the load/add/store gets a chance to become a\n   read-modify-write on CISC CPUs.\n\n   Alternatives:\n\n   Using a pair of pointers instead of indexing would be possible, but gcc\n   isn't able to recognise compile-time src==dst in that case, even when the\n   pointers are incremented more or less together.  Other compilers would\n   very likely have similar difficulty.\n\n   gcc could use \"if (__builtin_constant_p(src==dst) && src==dst)\" or\n   similar to detect a compile-time src==dst.  This works nicely on gcc\n   2.95.x, it's not good on gcc 3.0 where __builtin_constant_p(p==p) seems\n   to be always false, for a pointer p.  But the current code form seems\n   good enough for src==dst anyway.\n\n   gcc on x86 as usual doesn't give particularly good flags handling for the\n   carry/borrow detection.  It's tempting to want some multi instruction asm\n   blocks to help it, and this was tried, but in truth there's only a few\n   instructions to save and any gain is all too easily lost by register\n   juggling setting up for the asm.  */\n\n#if GMP_NAIL_BITS == 0\n#define __GMPN_AORS_1(cout, dst, src, n, v, OP, CB)\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    mp_size_t  __gmp_i;\t\t\t\t\t\t\\\n    mp_limb_t  __gmp_x, __gmp_r;                                \\\n\t\t\t\t\t\t\t\t\\\n    /* ASSERT ((n) >= 1); */\t\t\t\t\t\\\n    /* ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, n)); */\t\\\n\t\t\t\t\t\t\t\t\\\n    __gmp_x = (src)[0];\t\t\t\t\t\t\\\n    __gmp_r = __gmp_x OP (v);                                   \\\n    (dst)[0] = __gmp_r;\t\t\t\t\t\t\\\n    if (CB (__gmp_r, __gmp_x, (v)))                             \\\n      {\t\t\t\t\t\t\t\t\\\n\t(cout) = 1;\t\t\t\t\t\t\\\n\tfor (__gmp_i = 1; __gmp_i < (n);)                       \\\n\t  {\t\t\t\t\t\t\t\\\n\t    __gmp_x = (src)[__gmp_i];                           \\\n\t    __gmp_r = __gmp_x OP 1;                             \\\n\t    (dst)[__gmp_i] = __gmp_r;                           \\\n\t    ++__gmp_i;\t\t\t\t\t\t\\\n\t    if (!CB (__gmp_r, __gmp_x, 1))                      \\\n\t      {\t\t\t\t\t\t\t\\\n\t\tif ((src) != (dst))\t\t\t\t\\\n\t\t  __GMPN_COPY_REST (dst, src, n, __gmp_i);      \\\n\t\t(cout) = 0;\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n\tif ((src) != (dst))\t\t\t\t\t\\\n\t  __GMPN_COPY_REST (dst, src, n, 1);\t\t\t\\\n\t(cout) = 0;\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if GMP_NAIL_BITS >= 1\n#define __GMPN_AORS_1(cout, dst, src, n, v, OP, CB)\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    mp_size_t  __gmp_i;\t\t\t\t\t\t\\\n    mp_limb_t  __gmp_x, __gmp_r;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n    /* ASSERT ((n) >= 1); */\t\t\t\t\t\\\n    /* ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, n)); */\t\\\n\t\t\t\t\t\t\t\t\\\n    __gmp_x = (src)[0];\t\t\t\t\t\t\\\n    __gmp_r = __gmp_x OP (v);\t\t\t\t\t\\\n    (dst)[0] = __gmp_r & GMP_NUMB_MASK;\t\t\t\t\\\n    if (__gmp_r >> GMP_NUMB_BITS != 0)\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n\t(cout) = 1;\t\t\t\t\t\t\\\n\tfor (__gmp_i = 1; __gmp_i < (n);)\t\t\t\\\n\t  {\t\t\t\t\t\t\t\\\n\t    __gmp_x = (src)[__gmp_i];\t\t\t\t\\\n\t    __gmp_r = __gmp_x OP 1;\t\t\t\t\\\n\t    (dst)[__gmp_i] = __gmp_r & GMP_NUMB_MASK;\t\t\\\n\t    ++__gmp_i;\t\t\t\t\t\t\\\n\t    if (__gmp_r >> GMP_NUMB_BITS == 0)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\\\n\t\tif ((src) != (dst))\t\t\t\t\\\n\t\t  __GMPN_COPY_REST (dst, src, n, __gmp_i);\t\\\n\t\t(cout) = 0;\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\\\n\tif ((src) != (dst))\t\t\t\t\t\\\n\t  __GMPN_COPY_REST (dst, src, n, 1);\t\t\t\\\n\t(cout) = 0;\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#define __GMPN_ADDCB(r,x,y) ((r) < (y))\n#define __GMPN_SUBCB(r,x,y) ((x) < (y))\n\n#define __GMPN_ADD_1(cout, dst, src, n, v)\t     \\\n  __GMPN_AORS_1(cout, dst, src, n, v, +, __GMPN_ADDCB)\n#define __GMPN_SUB_1(cout, dst, src, n, v)\t     \\\n  __GMPN_AORS_1(cout, dst, src, n, v, -, __GMPN_SUBCB)\n\n\n/* Compare {xp,size} and {yp,size}, setting \"result\" to positive, zero or\n   negative.  size==0 is allowed.  On random data usually only one limb will\n   need to be examined to get a result, so it's worth having it inline.  */\n#define __GMPN_CMP(result, xp, yp, size)                                \\\n  do {                                                                  \\\n    mp_size_t  __gmp_i;                                                 \\\n    mp_limb_t  __gmp_x, __gmp_y;                                        \\\n                                                                        \\\n    /* ASSERT ((size) >= 0); */                                         \\\n                                                                        \\\n    (result) = 0;                                                       \\\n    __gmp_i = (size);                                                   \\\n    while (--__gmp_i >= 0)                                              \\\n      {                                                                 \\\n        __gmp_x = (xp)[__gmp_i];                                        \\\n        __gmp_y = (yp)[__gmp_i];                                        \\\n        if (__gmp_x != __gmp_y)                                         \\\n          {                                                             \\\n            /* Cannot use __gmp_x - __gmp_y, may overflow an \"int\" */   \\\n            (result) = (__gmp_x > __gmp_y ? 1 : -1);                    \\\n            break;                                                      \\\n          }                                                             \\\n      }                                                                 \\\n  } while (0)\n\n\n#if defined (__GMPN_COPY) && ! defined (__GMPN_COPY_REST)\n#define __GMPN_COPY_REST(dst, src, size, start)                 \\\n  do {                                                          \\\n    /* ASSERT ((start) >= 0); */                                \\\n    /* ASSERT ((start) <= (size)); */                           \\\n    __GMPN_COPY ((dst)+(start), (src)+(start), (size)-(start)); \\\n  } while (0)\n#endif\n\n/* Copy {src,size} to {dst,size}, starting at \"start\".  This is designed to\n   keep the indexing dst[j] and src[j] nice and simple for __GMPN_ADD_1,\n   __GMPN_ADD, etc.  */\n#if ! defined (__GMPN_COPY_REST)\n#define __GMPN_COPY_REST(dst, src, size, start)                 \\\n  do {                                                          \\\n    mp_size_t __gmp_j;                                          \\\n    /* ASSERT ((size) >= 0); */                                 \\\n    /* ASSERT ((start) >= 0); */                                \\\n    /* ASSERT ((start) <= (size)); */                           \\\n    /* ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, size)); */     \\\n    for (__gmp_j = (start); __gmp_j < (size); __gmp_j++)        \\\n      (dst)[__gmp_j] = (src)[__gmp_j];                          \\\n  } while (0)\n#endif\n\n/* Enhancement: Use some of the smarter code from gmp-impl.h.  Maybe use\n   mpn_copyi if there's a native version, and if we don't mind demanding\n   binary compatibility for it (on targets which use it).  */\n\n#if ! defined (__GMPN_COPY)\n#define __GMPN_COPY(dst, src, size)   __GMPN_COPY_REST (dst, src, size, 0)\n#endif\n\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_add)\n#if ! defined (__GMP_FORCE_mpn_add)\n__GMP_EXTERN_INLINE\n#endif\nmp_limb_t\nmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)\n{\n  mp_limb_t  __gmp_c;\n  __GMPN_ADD (__gmp_c, __gmp_wp, __gmp_xp, __gmp_xsize, __gmp_yp, __gmp_ysize);\n  return __gmp_c;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_add_1)\n#if ! defined (__GMP_FORCE_mpn_add_1)\n__GMP_EXTERN_INLINE\n#endif\nmp_limb_t\nmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) __GMP_NOTHROW\n{\n  mp_limb_t  __gmp_c;\n  __GMPN_ADD_1 (__gmp_c, __gmp_dst, __gmp_src, __gmp_size, __gmp_n);\n  return __gmp_c;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_cmp)\n#if ! defined (__GMP_FORCE_mpn_cmp)\n__GMP_EXTERN_INLINE\n#endif\nint\nmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) __GMP_NOTHROW\n{\n  int __gmp_result;\n  __GMPN_CMP (__gmp_result, __gmp_xp, __gmp_yp, __gmp_size);\n  return __gmp_result;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_sub)\n#if ! defined (__GMP_FORCE_mpn_sub)\n__GMP_EXTERN_INLINE\n#endif\nmp_limb_t\nmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)\n{\n  mp_limb_t  __gmp_c;\n  __GMPN_SUB (__gmp_c, __gmp_wp, __gmp_xp, __gmp_xsize, __gmp_yp, __gmp_ysize);\n  return __gmp_c;\n}\n#endif\n\n#if defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_sub_1)\n#if ! defined (__GMP_FORCE_mpn_sub_1)\n__GMP_EXTERN_INLINE\n#endif\nmp_limb_t\nmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) __GMP_NOTHROW\n{\n  mp_limb_t  __gmp_c;\n  __GMPN_SUB_1 (__gmp_c, __gmp_dst, __gmp_src, __gmp_size, __gmp_n);\n  return __gmp_c;\n}\n#endif\n\n#if defined (__cplusplus)\n}\n#endif\n\n\n/* Allow faster testing for negative, zero, and positive.  */\n#define mpz_sgn(Z) ((Z)->_mp_size < 0 ? -1 : (Z)->_mp_size > 0)\n#define mpf_sgn(F) ((F)->_mp_size < 0 ? -1 : (F)->_mp_size > 0)\n#define mpq_sgn(Q) ((Q)->_mp_num._mp_size < 0 ? -1 : (Q)->_mp_num._mp_size > 0)\n\n/* When using GCC, optimize certain common comparisons.  */\n#if defined (__GNUC__)\n#define mpz_cmp_ui(Z,UI) \\\n  (__builtin_constant_p (UI) && (UI) == 0\t\t\t\t\\\n   ? mpz_sgn (Z) : _mpz_cmp_ui (Z,UI))\n#define mpz_cmp_si(Z,SI) \\\n  (__builtin_constant_p (SI) && (SI) == 0 ? mpz_sgn (Z)\t\t\t\\\n   : __builtin_constant_p (SI) && (SI) > 0\t\t\t\t\\\n    ? _mpz_cmp_ui (Z, __GMP_CAST (unsigned long int, SI))\t\t\\\n   : _mpz_cmp_si (Z,SI))\n#define mpq_cmp_ui(Q,NUI,DUI) \\\n  (__builtin_constant_p (NUI) && (NUI) == 0\t\t\t\t\\\n   ? mpq_sgn (Q) : _mpq_cmp_ui (Q,NUI,DUI))\n#define mpq_cmp_si(q,n,d)                       \\\n  (__builtin_constant_p ((n) >= 0) && (n) >= 0  \\\n   ? mpq_cmp_ui (q, __GMP_CAST (unsigned long, n), d) \\\n   : _mpq_cmp_si (q, n, d))\n#else\n#define mpz_cmp_ui(Z,UI) _mpz_cmp_ui (Z,UI)\n#define mpz_cmp_si(Z,UI) _mpz_cmp_si (Z,UI)\n#define mpq_cmp_ui(Q,NUI,DUI) _mpq_cmp_ui (Q,NUI,DUI)\n#define mpq_cmp_si(q,n,d)  _mpq_cmp_si(q,n,d)\n#endif\n\n\n/* Using \"&\" rather than \"&&\" means these can come out branch-free.  Every\n   mpz_t has at least one limb allocated, so fetching the low limb is always\n   allowed.  */\n#define mpz_odd_p(z)   (((z)->_mp_size != 0) & __GMP_CAST (int, (z)->_mp_d[0]))\n#define mpz_even_p(z)  (! mpz_odd_p (z))\n\n\n/**************** C++ routines ****************/\n\n#ifdef __cplusplus\n__GMP_DECLSPEC_XX std::ostream& operator<< (std::ostream &, mpz_srcptr);\n__GMP_DECLSPEC_XX std::ostream& operator<< (std::ostream &, mpq_srcptr);\n__GMP_DECLSPEC_XX std::ostream& operator<< (std::ostream &, mpf_srcptr);\n__GMP_DECLSPEC_XX std::istream& operator>> (std::istream &, mpz_ptr);\n__GMP_DECLSPEC_XX std::istream& operator>> (std::istream &, mpq_ptr);\n__GMP_DECLSPEC_XX std::istream& operator>> (std::istream &, mpf_ptr);\n#endif\n\n/* Source-level compatibility with GMP 1.  */\n#define mpz_mdiv    mpz_fdiv_q\n#define mpz_mdivmod mpz_fdiv_qr\n#define mpz_mmod    mpz_fdiv_r\n#define mpz_mdiv_ui mpz_fdiv_q_ui\n#define mpz_mdivmod_ui(q,r,n,d) \\\n  (((r) == 0) ? mpz_fdiv_q_ui (q,n,d) : mpz_fdiv_qr_ui (q,r,n,d))\n#define mpz_mmod_ui(r,n,d) \\\n  (((r) == 0) ? mpz_fdiv_ui (n,d) : mpz_fdiv_r_ui (r,n,d))\n\n#define gmp_randinit(x,y,z)  gmp_randinit_lc_2exp_size(x,z)\n\ntypedef __mpz_struct MP_INT;    /* gmp 1 source compatibility */\ntypedef __mpq_struct MP_RAT;    /* gmp 1 source compatibility */\n\n#define mpz_div\t\t    mpz_fdiv_q\n#define mpz_divmod\t    mpz_fdiv_qr\n#define mpz_div_ui\t    mpz_fdiv_q_ui\n#define mpz_divmod_ui\tmpz_fdiv_qr_ui\n#define mpz_div_2exp\tmpz_fdiv_q_2exp\n#define mpz_mod_2exp\tmpz_fdiv_r_2exp\n\nenum\n{\n  GMP_ERROR_NONE = 0,\n  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,\n  GMP_ERROR_DIVISION_BY_ZERO = 2,\n  GMP_ERROR_SQRT_OF_NEGATIVE = 4,\n  GMP_ERROR_INVALID_ARGUMENT = 8\n};\n\n/* Major version number is the value of __GNU_MP__ too, above and in mp.h. */\n#define __GNU_MP_VERSION 5 \n#define __GNU_MP_VERSION_MINOR 0 \n#define __GNU_MP_VERSION_PATCHLEVEL 1\n#define GMP_VERSION \"5.0.1\"\n\n#define __MPIR_VERSION 2\n#define __MPIR_VERSION_MINOR 2\n#define __MPIR_VERSION_PATCHLEVEL 1\n#if defined( _MSC_VER )\n#define _MSC_MPIR_VERSION \"2.2.1\"\n#endif\n\n/* These are for programs like MPFR to use the same CC and CFLAGS as MPIR */\n\n#if ! defined (__GMP_WITHIN_CONFIGURE)\n#define __GMP_CC \"gcc\" \n#define __GMP_CFLAGS \"-O3\" \n#define __MPIR_CC \"gcc -std=gnu99\"\n#define __MPIR_CFLAGS \"-O3\"\n#endif\n\n#define __GMP_H__\n#endif /* __GMP_H__ */\n\n",
    "ap_fixed_special.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef AP_FIXED_SPECIAL_H\n#define AP_FIXED_SPECIAL_H\n#ifndef __SYNTHESIS__\n#include \"cstdio\"\n#include \"cstdlib\"\n#endif\n// FIXME AP_AUTOCC cannot handle many standard headers, so declare instead of\n// include.\n// #include \"complex\"\nnamespace std {\ntemplate<typename _Tp> class complex;\n}\n\n/*\n  TODO: Modernize the code using C++11/C++14\n  1. constexpr http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0415r0.html\n  2. move constructor\n*/\n\nnamespace std {\n/*\n   Specialize std::complex<ap_fixed> to zero initialization ap_fixed.\n\n   To reduce the area cost, ap_fixed is not zero initialized, just like basic\n   types float or double. However, libstdc++ provides specialization for float,\n   double and long double, initializing image part to 0 when not specified.\n\n   This has become a difficulty in switching legacy code from these C types to\n   ap_fixed. To ease the tranform of legacy code, we have to implement\n   specialization of std::complex<> for our type.\n\n   As ap_fixed is a template, it is impossible to specialize only the methods\n   that causes default initialization of value type in std::complex<>. An\n   explicit full specialization of the template class has to be done, covering\n   all the member functions and operators of std::complex<> as specified\n   in standard 26.2.4 and 26.2.5.\n*/\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\nclass complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {\n public:\n  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;\n  typedef _Tp value_type;\n\n  // 26.2.4/1\n  // Constructor without argument\n  // Default initialize, so that in dataflow, the variable is only written once.\n  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}\n  // Constructor with ap_fixed.\n  // Zero initialize image part when not specified, so that `C(1) == C(1,0)`\n  complex(const _Tp &__r, const _Tp &__i = _Tp(0))\n      : _M_real(__r), _M_imag(__i) {}\n\n  // Constructor with another complex number\n  template <typename _Up>\n  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}\n\n#if __cplusplus >= 201103L\n  const _Tp& real() const { return _M_real; }\n  const _Tp& imag() const { return _M_imag; }\n#else\n  _Tp& real() { return _M_real; }\n  const _Tp& real() const { return _M_real; }\n  _Tp& imag() { return _M_imag; }\n  const _Tp& imag() const { return _M_imag; }\n#endif\n \n  void real(_Tp __val) { _M_real = __val; }\n\n  void imag(_Tp __val) { _M_imag = __val; }\n\n  // Assign this complex number with ap_fixed.\n  // Zero initialize image poarrt, so that `C c; c = 1; c == C(1,0);`\n  complex<_Tp> &operator=(const _Tp __t) {\n    _M_real = __t;\n    _M_imag = _Tp(0);\n    return *this;\n  }\n\n  // 26.2.5/1\n  // Add ap_fixed to this complex number.\n  complex<_Tp> &operator+=(const _Tp &__t) {\n    _M_real += __t;\n    return *this;\n  }\n\n  // 26.2.5/3\n  // Subtract ap_fixed from this complex number.\n  complex<_Tp> &operator-=(const _Tp &__t) {\n    _M_real -= __t;\n    return *this;\n  }\n\n  // 26.2.5/5\n  // Multiply this complex number by ap_fixed.\n  complex<_Tp> &operator*=(const _Tp &__t) {\n    _M_real *= __t;\n    _M_imag *= __t;\n    return *this;\n  }\n\n  // 26.2.5/7\n  // Divide this complex number by ap_fixed.\n  complex<_Tp> &operator/=(const _Tp &__t) {\n    _M_real /= __t;\n    _M_imag /= __t;\n    return *this;\n  }\n\n  // Assign complex number to this complex number.\n  template <typename _Up>\n  complex<_Tp> &operator=(const complex<_Up> &__z) {\n    _M_real = __z.real();\n    _M_imag = __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/9\n  // Add complex number to this.\n  template <typename _Up>\n  complex<_Tp> &operator+=(const complex<_Up> &__z) {\n    _M_real += __z.real();\n    _M_imag += __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/11\n  // Subtract complex number from this.\n  template <typename _Up>\n  complex<_Tp> &operator-=(const complex<_Up> &__z) {\n    _M_real -= __z.real();\n    _M_imag -= __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/13\n  // Multiply this by complex number.\n  template <typename _Up>\n  complex<_Tp> &operator*=(const complex<_Up> &__z) {\n    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n    _M_real = __r;\n    return *this;\n  }\n\n  // 26.2.5/15\n  // Divide this by complex number.\n  template <typename _Up>\n  complex<_Tp> &operator/=(const complex<_Up> &__z) {\n    complex<_Tp> cj (__z.real(), -__z.imag());\n    complex<_Tp> a = (*this) * cj;\n    complex<_Tp> b = cj * __z;\n    _M_real = a.real() / b.real();\n    _M_imag = a.imag() / b.real();\n    return *this;\n  }\n\n private:\n  _Tp _M_real;\n  _Tp _M_imag;\n\n}; // class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> >\n\n/*\n   Non-member operations\n   These operations are not required by standard in 26.2.6, but libstdc++\n   defines them for\n   float, double or long double's specialization.\n*/\n// Compare complex number with ap_fixed.\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\ninline bool operator==(\n    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,\n    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {\n  return __x.real() == __y &&\n         __x.imag() == 0;\n}\n\n// Compare ap_fixed with complex number.\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\ninline bool operator==(\n    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,\n    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {\n  return __x == __y.real() &&\n         0 == __y.imag();\n}\n\n// Compare complex number with ap_fixed.\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\ninline bool operator!=(\n    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,\n    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {\n  return __x.real() != __y ||\n         __x.imag() != 0;\n}\n\n// Compare ap_fixed with complex number.\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\ninline bool operator!=(\n    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,\n    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {\n  return __x != __y.real() ||\n         0 != __y.imag();\n}\n\n}  // namespace std\n\n#endif  // ifndef AP_FIXED_SPECIAL_H\n\n\n",
    "etc/ap_private.h": "/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_PRIVATE_H__\n#define __AP_PRIVATE_H__\n\n// common macros and type declarations are now defined in ap_common.h, and\n// ap_private becomes part of it.\n#ifndef __AP_COMMON_H__\n#error \"etc/ap_private.h cannot be included directly.\"\n#endif\n\n// forward declarations\n//template <int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64>\n//class ap_private; // moved to ap_common.h\ntemplate <int _AP_W, bool _AP_S>\nstruct _private_range_ref;\ntemplate <int _AP_W, bool _AP_S>\nstruct _private_bit_ref;\n\n// TODO clean up this part.\n#ifndef LLVM_SUPPORT_MATHEXTRAS_H\n#define LLVM_SUPPORT_MATHEXTRAS_H\n\n#ifdef _MSC_VER\n#if _MSC_VER <= 1500\ntypedef __int8 int8_t;\ntypedef unsigned __int8 uint8_t;\ntypedef __int16 int16_t;\ntypedef unsigned __int16 uint16_t;\ntypedef __int32 int32_t;\ntypedef unsigned __int32 uint32_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#else\n#include \"stdint.h\"\n#endif\n#else\n#include \"stdint.h\"\n#endif\n\n// FIXME eventually, this should have nothing to do with half.\n#include \"../hls_half.h\"\n\n#ifndef INLINE\n#define INLINE inline\n// Enable to debug ap_int/ap_fixed\n// #define INLINE  __attribute__((weak))\n#endif\n\n// NOTE: The following support functions use the _32/_64 extensions instead of\n// type overloading so that signed and unsigned integers can be used without\n// ambiguity.\nnamespace AESL_std {\ntemplate <class DataType>\nDataType INLINE min(DataType a, DataType b) {\n  return (a >= b) ? b : a;\n}\n\ntemplate <class DataType>\nDataType INLINE max(DataType a, DataType b) {\n  return (a >= b) ? a : b;\n}\n} // namespace AESL_std\n\n// TODO clean up included headers.\n#include \"math.h\"\n#include \"stdio.h\"\n#include \"cassert\"\n#include \"cstdlib\"\n#include \"cstring\"\n#include \"iomanip\"\n#include \"limits\"\n#include \"sstream\"\n#include \"string\"\n\nnamespace ap_private_ops {\n/// Hi_32 - This function returns the high 32 bits of a 64 bit value.\nstatic INLINE uint32_t Hi_32(uint64_t Value) {\n  return static_cast<uint32_t>(Value >> 32);\n}\n\n/// Lo_32 - This function returns the low 32 bits of a 64 bit value.\nstatic INLINE uint32_t Lo_32(uint64_t Value) {\n  return static_cast<uint32_t>(Value);\n}\n\ntemplate <int _AP_W>\nINLINE bool isNegative(const ap_private<_AP_W, false>& a) {\n  return false;\n}\n\ntemplate <int _AP_W>\nINLINE bool isNegative(const ap_private<_AP_W, true>& a) {\n  enum {\n    APINT_BITS_PER_WORD = 64,\n    _AP_N = (_AP_W + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD\n  };\n  static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) % APINT_BITS_PER_WORD);\n  return (sign_mask & a.get_pVal(_AP_N - 1)) != 0;\n}\n\n/// CountLeadingZeros_32 - this function performs the platform optimal form of\n/// counting the number of zeros from the most significant bit to the first one\n/// bit.  Ex. CountLeadingZeros_32(0x00F000FF) == 8.\n/// Returns 32 if the word is zero.\nstatic INLINE unsigned CountLeadingZeros_32(uint32_t Value) {\n  unsigned Count; // result\n#if __GNUC__ >= 4\n// PowerPC is defined for __builtin_clz(0)\n#if !defined(__ppc__) && !defined(__ppc64__)\n  if (Value == 0) return 32;\n#endif\n  Count = __builtin_clz(Value);\n#else\n  if (Value == 0) return 32;\n  Count = 0;\n  // bisecton method for count leading zeros\n  for (unsigned Shift = 32 >> 1; Shift; Shift >>= 1) {\n    uint32_t Tmp = (Value) >> (Shift);\n    if (Tmp) {\n      Value = Tmp;\n    } else {\n      Count |= Shift;\n    }\n  }\n#endif\n  return Count;\n}\n\n/// CountLeadingZeros_64 - This function performs the platform optimal form\n/// of counting the number of zeros from the most significant bit to the first\n/// one bit (64 bit edition.)\n/// Returns 64 if the word is zero.\nstatic INLINE unsigned CountLeadingZeros_64(uint64_t Value) {\n  unsigned Count; // result\n#if __GNUC__ >= 4\n// PowerPC is defined for __builtin_clzll(0)\n#if !defined(__ppc__) && !defined(__ppc64__)\n  if (!Value) return 64;\n#endif\n  Count = __builtin_clzll(Value);\n#else\n  if (sizeof(long) == sizeof(int64_t)) {\n    if (!Value) return 64;\n    Count = 0;\n    // bisecton method for count leading zeros\n    for (unsigned Shift = 64 >> 1; Shift; Shift >>= 1) {\n      uint64_t Tmp = (Value) >> (Shift);\n      if (Tmp) {\n        Value = Tmp;\n      } else {\n        Count |= Shift;\n      }\n    }\n  } else {\n    // get hi portion\n    uint32_t Hi = Hi_32(Value);\n\n    // if some bits in hi portion\n    if (Hi) {\n      // leading zeros in hi portion plus all bits in lo portion\n      Count = CountLeadingZeros_32(Hi);\n    } else {\n      // get lo portion\n      uint32_t Lo = Lo_32(Value);\n      // same as 32 bit value\n      Count = CountLeadingZeros_32(Lo) + 32;\n    }\n  }\n#endif\n  return Count;\n}\n\n/// CountTrailingZeros_64 - This function performs the platform optimal form\n/// of counting the number of zeros from the least significant bit to the first\n/// one bit (64 bit edition.)\n/// Returns 64 if the word is zero.\nstatic INLINE unsigned CountTrailingZeros_64(uint64_t Value) {\n#if __GNUC__ >= 4\n  return (Value != 0) ? __builtin_ctzll(Value) : 64;\n#else\n  static const unsigned Mod67Position[] = {\n      64, 0,  1,  39, 2,  15, 40, 23, 3,  12, 16, 59, 41, 19, 24, 54, 4,\n      64, 13, 10, 17, 62, 60, 28, 42, 30, 20, 51, 25, 44, 55, 47, 5,  32,\n      65, 38, 14, 22, 11, 58, 18, 53, 63, 9,  61, 27, 29, 50, 43, 46, 31,\n      37, 21, 57, 52, 8,  26, 49, 45, 36, 56, 7,  48, 35, 6,  34, 33, 0};\n  return Mod67Position[(uint64_t)(-(int64_t)Value & (int64_t)Value) % 67];\n#endif\n}\n\n/// CountPopulation_64 - this function counts the number of set bits in a value,\n/// (64 bit edition.)\nstatic INLINE unsigned CountPopulation_64(uint64_t Value) {\n#if __GNUC__ >= 4\n  return __builtin_popcountll(Value);\n#else\n  uint64_t v = Value - (((Value) >> 1) & 0x5555555555555555ULL);\n  v = (v & 0x3333333333333333ULL) + (((v) >> 2) & 0x3333333333333333ULL);\n  v = (v + ((v) >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n  return unsigned((uint64_t)(v * 0x0101010101010101ULL) >> 56);\n#endif\n}\n\nstatic INLINE uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {\n  uint32_t Count = 0;\n  if (skip) (__V) <<= (skip);\n  while (__V && (__V & (1ULL << 63))) {\n    Count++;\n    (__V) <<= 1;\n  }\n  return Count;\n}\n\nstatic INLINE std::string oct2Bin(char oct) {\n  switch (oct) {\n    case '\\0': {\n      return \"\";\n    }\n    case '.': {\n      return \".\";\n    }\n    case '0': {\n      return \"000\";\n    }\n    case '1': {\n      return \"001\";\n    }\n    case '2': {\n      return \"010\";\n    }\n    case '3': {\n      return \"011\";\n    }\n    case '4': {\n      return \"100\";\n    }\n    case '5': {\n      return \"101\";\n    }\n    case '6': {\n      return \"110\";\n    }\n    case '7': {\n      return \"111\";\n    }\n  }\n  assert(0 && \"Invalid character in digit string\");\n  return \"\";\n}\n\nstatic INLINE std::string hex2Bin(char hex) {\n  switch (hex) {\n    case '\\0': {\n      return \"\";\n    }\n    case '.': {\n      return \".\";\n    }\n    case '0': {\n      return \"0000\";\n    }\n    case '1': {\n      return \"0001\";\n    }\n    case '2': {\n      return \"0010\";\n    }\n    case '3': {\n      return \"0011\";\n    }\n    case '4': {\n      return \"0100\";\n    }\n    case '5': {\n      return \"0101\";\n    }\n    case '6': {\n      return \"0110\";\n    }\n    case '7': {\n      return \"0111\";\n    }\n    case '8': {\n      return \"1000\";\n    }\n    case '9': {\n      return \"1001\";\n    }\n    case 'A':\n    case 'a': {\n      return \"1010\";\n    }\n    case 'B':\n    case 'b': {\n      return \"1011\";\n    }\n    case 'C':\n    case 'c': {\n      return \"1100\";\n    }\n    case 'D':\n    case 'd': {\n      return \"1101\";\n    }\n    case 'E':\n    case 'e': {\n      return \"1110\";\n    }\n    case 'F':\n    case 'f': {\n      return \"1111\";\n    }\n  }\n  assert(0 && \"Invalid character in digit string\");\n  return \"\";\n}\n\nstatic INLINE uint32_t decode_digit(char cdigit, int radix) {\n  uint32_t digit = 0;\n  if (radix == 16) {\n#define isxdigit(c)                                            \\\n  (((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || \\\n   ((c) >= 'A' && (c) <= 'F'))\n#define isdigit(c) ((c) >= '0' && (c) <= '9')\n    if (!isxdigit(cdigit)) assert(0 && \"Invalid hex digit in string\");\n    if (isdigit(cdigit))\n      digit = cdigit - '0';\n    else if (cdigit >= 'a')\n      digit = cdigit - 'a' + 10;\n    else if (cdigit >= 'A')\n      digit = cdigit - 'A' + 10;\n    else\n      assert(0 && \"huh? we shouldn't get here\");\n  } else if (isdigit(cdigit)) {\n    digit = cdigit - '0';\n  } else {\n    assert(0 && \"Invalid character in digit string\");\n  }\n#undef isxdigit\n#undef isdigit\n  return digit;\n}\n\n// Determine the radix of \"val\".\nstatic INLINE std::string parseString(const std::string& input, unsigned char& radix) {\n  size_t len = input.length();\n  if (len == 0) {\n    if (radix == 0) radix = 10;\n    return input;\n  }\n\n  size_t startPos = 0;\n  // Trim whitespace\n  while (input[startPos] == ' ' && startPos < len) startPos++;\n  while (input[len - 1] == ' ' && startPos < len) len--;\n\n  std::string val = input.substr(startPos, len - startPos);\n  // std::cout << \"val = \" << val << \"\\n\";\n  len = val.length();\n  startPos = 0;\n\n  // If the length of the string is less than 2, then radix\n  // is decimal and there is no exponent.\n  if (len < 2) {\n    if (radix == 0) radix = 10;\n    return val;\n  }\n\n  bool isNegative = false;\n  std::string ans;\n\n  // First check to see if we start with a sign indicator\n  if (val[0] == '-') {\n    ans = \"-\";\n    ++startPos;\n    isNegative = true;\n  } else if (val[0] == '+')\n    ++startPos;\n\n  if (len - startPos < 2) {\n    if (radix == 0) radix = 10;\n    return val;\n  }\n\n  if (val.substr(startPos, 2) == \"0x\" || val.substr(startPos, 2) == \"0X\") {\n    // If we start with \"0x\", then the radix is hex.\n    radix = 16;\n    startPos += 2;\n  } else if (val.substr(startPos, 2) == \"0b\" ||\n             val.substr(startPos, 2) == \"0B\") {\n    // If we start with \"0b\", then the radix is binary.\n    radix = 2;\n    startPos += 2;\n  } else if (val.substr(startPos, 2) == \"0o\" ||\n             val.substr(startPos, 2) == \"0O\") {\n    // If we start with \"0o\", then the radix is octal.\n    radix = 8;\n    startPos += 2;\n  } else if (radix == 0) {\n    radix = 10;\n  }\n\n  int exp = 0;\n  if (radix == 10) {\n    // If radix is decimal, then see if there is an\n    // exponent indicator.\n    size_t expPos = val.find('e');\n    bool has_exponent = true;\n    if (expPos == std::string::npos) expPos = val.find('E');\n    if (expPos == std::string::npos) {\n      // No exponent indicator, so the mantissa goes to the end.\n      expPos = len;\n      has_exponent = false;\n    }\n    // std::cout << \"startPos = \" << startPos << \" \" << expPos << \"\\n\";\n\n    ans += val.substr(startPos, expPos - startPos);\n    if (has_exponent) {\n      // Parse the exponent.\n      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));\n      iss >> exp;\n    }\n  } else {\n    // Check for a binary exponent indicator.\n    size_t expPos = val.find('p');\n    bool has_exponent = true;\n    if (expPos == std::string::npos) expPos = val.find('P');\n    if (expPos == std::string::npos) {\n      // No exponent indicator, so the mantissa goes to the end.\n      expPos = len;\n      has_exponent = false;\n    }\n\n    // std::cout << \"startPos = \" << startPos << \" \" << expPos << \"\\n\";\n\n    assert(startPos <= expPos);\n    // Convert to binary as we go.\n    for (size_t i = startPos; i < expPos; ++i) {\n      if (radix == 16) {\n        ans += hex2Bin(val[i]);\n      } else if (radix == 8) {\n        ans += oct2Bin(val[i]);\n      } else { // radix == 2\n        ans += val[i];\n      }\n    }\n    // End in binary\n    radix = 2;\n    if (has_exponent) {\n      // Parse the exponent.\n      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));\n      iss >> exp;\n    }\n  }\n  if (exp == 0) return ans;\n\n  size_t decPos = ans.find('.');\n  if (decPos == std::string::npos) decPos = ans.length();\n  if ((int)decPos + exp >= (int)ans.length()) {\n    int i = decPos;\n    for (; i < (int)ans.length() - 1; ++i) ans[i] = ans[i + 1];\n    for (; i < (int)ans.length(); ++i) ans[i] = '0';\n    for (; i < (int)decPos + exp; ++i) ans += '0';\n    return ans;\n  } else if ((int)decPos + exp < (int)isNegative) {\n    std::string dupAns = \"0.\";\n    if (ans[0] == '-') dupAns = \"-0.\";\n    for (int i = 0; i < isNegative - (int)decPos - exp; ++i) dupAns += '0';\n    for (size_t i = isNegative; i < ans.length(); ++i)\n      if (ans[i] != '.') dupAns += ans[i];\n    return dupAns;\n  }\n\n  if (exp > 0)\n    for (size_t i = decPos; i < decPos + exp; ++i) ans[i] = ans[i + 1];\n  else {\n    if (decPos == ans.length()) ans += ' ';\n    for (int i = decPos; i > (int)decPos + exp; --i) ans[i] = ans[i - 1];\n  }\n  ans[decPos + exp] = '.';\n  return ans;\n}\n\n/// sub_1 - This function subtracts a single \"digit\" (64-bit word), y, from\n/// the multi-digit integer array, x[], propagating the borrowed 1 value until\n/// no further borrowing is neeeded or it runs out of \"digits\" in x.  The result\n/// is 1 if \"borrowing\" exhausted the digits in x, or 0 if x was not exhausted.\n/// In other words, if y > x then this function returns 1, otherwise 0.\n/// @returns the borrow out of the subtraction\nstatic INLINE bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {\n  for (uint32_t i = 0; i < len; ++i) {\n    uint64_t __X = x[i];\n    x[i] -= y;\n    if (y > __X)\n      y = 1; // We have to \"borrow 1\" from next \"digit\"\n    else {\n      y = 0; // No need to borrow\n      break; // Remaining digits are unchanged so exit early\n    }\n  }\n  return (y != 0);\n}\n\n/// add_1 - This function adds a single \"digit\" integer, y, to the multiple\n/// \"digit\" integer array,  x[]. x[] is modified to reflect the addition and\n/// 1 is returned if there is a carry out, otherwise 0 is returned.\n/// @returns the carry of the addition.\nstatic INLINE bool add_1(uint64_t dest[], uint64_t x[], uint32_t len,\n                         uint64_t y) {\n  for (uint32_t i = 0; i < len; ++i) {\n    dest[i] = y + x[i];\n    if (dest[i] < y)\n      y = 1; // Carry one to next digit.\n    else {\n      y = 0; // No need to carry so exit early\n      break;\n    }\n  }\n  return (y != 0);\n}\n\n/// add - This function adds the integer array x to the integer array Y and\n/// places the result in dest.\n/// @returns the carry out from the addition\n/// @brief General addition of 64-bit integer arrays\nstatic INLINE bool add(uint64_t* dest, const uint64_t* x, const uint64_t* y,\n                       uint32_t destlen, uint32_t xlen, uint32_t ylen,\n                       bool xsigned, bool ysigned) {\n  bool carry = false;\n  uint32_t len = AESL_std::min(xlen, ylen);\n  uint32_t i;\n  for (i = 0; i < len && i < destlen; ++i) {\n    uint64_t limit =\n        AESL_std::min(x[i], y[i]); // must come first in case dest == x\n    dest[i] = x[i] + y[i] + carry;\n    carry = dest[i] < limit || (carry && dest[i] == limit);\n  }\n  if (xlen > ylen) {\n    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;\n    for (i = ylen; i < xlen && i < destlen; i++) {\n      uint64_t limit = AESL_std::min(x[i], yext);\n      dest[i] = x[i] + yext + carry;\n      carry = (dest[i] < limit) || (carry && dest[i] == limit);\n    }\n  } else if (ylen > xlen) {\n    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;\n    for (i = xlen; i < ylen && i < destlen; i++) {\n      uint64_t limit = AESL_std::min(xext, y[i]);\n      dest[i] = xext + y[i] + carry;\n      carry = (dest[i] < limit) || (carry && dest[i] == limit);\n    }\n  }\n  return carry;\n}\n\n/// @returns returns the borrow out.\n/// @brief Generalized subtraction of 64-bit integer arrays.\nstatic INLINE bool sub(uint64_t* dest, const uint64_t* x, const uint64_t* y,\n                       uint32_t destlen, uint32_t xlen, uint32_t ylen,\n                       bool xsigned, bool ysigned) {\n  bool borrow = false;\n  uint32_t i;\n  uint32_t len = AESL_std::min(xlen, ylen);\n  for (i = 0; i < len && i < destlen; ++i) {\n    uint64_t x_tmp = borrow ? x[i] - 1 : x[i];\n    borrow = y[i] > x_tmp || (borrow && x[i] == 0);\n    dest[i] = x_tmp - y[i];\n  }\n  if (xlen > ylen) {\n    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;\n    for (i = ylen; i < xlen && i < destlen; i++) {\n      uint64_t x_tmp = borrow ? x[i] - 1 : x[i];\n      borrow = yext > x_tmp || (borrow && x[i] == 0);\n      dest[i] = x_tmp - yext;\n    }\n  } else if (ylen > xlen) {\n    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;\n    for (i = xlen; i < ylen && i < destlen; i++) {\n      uint64_t x_tmp = borrow ? xext - 1 : xext;\n      borrow = y[i] > x_tmp || (borrow && xext == 0);\n      dest[i] = x_tmp - y[i];\n    }\n  }\n  return borrow;\n}\n\n/// Subtracts the RHS ap_private from this ap_private\n/// @returns this, after subtraction\n/// @brief Subtraction assignment operator.\n\n/// Multiplies an integer array, x by a a uint64_t integer and places the result\n/// into dest.\n/// @returns the carry out of the multiplication.\n/// @brief Multiply a multi-digit ap_private by a single digit (64-bit) integer.\nstatic INLINE uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len,\n                             uint64_t y) {\n  // Split y into high 32-bit part (hy)  and low 32-bit part (ly)\n  uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;\n  uint64_t carry = 0;\n  static const uint64_t two_power_32 = 1ULL << 32;\n  // For each digit of x.\n  for (uint32_t i = 0; i < len; ++i) {\n    // Split x into high and low words\n    uint64_t lx = x[i] & 0xffffffffULL;\n    uint64_t hx = (x[i]) >> 32;\n    // hasCarry - A flag to indicate if there is a carry to the next digit.\n    // hasCarry == 0, no carry\n    // hasCarry == 1, has carry\n    // hasCarry == 2, no carry and the calculation result == 0.\n    uint8_t hasCarry = 0;\n    dest[i] = carry + lx * ly;\n    // Determine if the add above introduces carry.\n    hasCarry = (dest[i] < carry) ? 1 : 0;\n    carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);\n    // The upper limit of carry can be (2^32 - 1)(2^32 - 1) +\n    // (2^32 - 1) + 2^32 = 2^64.\n    hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);\n\n    carry += (lx * hy) & 0xffffffffULL;\n    dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);\n    carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +\n            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;\n  }\n  return carry;\n}\n\n/// Multiplies integer array x by integer array y and stores the result into\n/// the integer array dest. Note that dest's size must be >= xlen + ylen in\n/// order to\n/// do a full precision computation. If it is not, then only the low-order words\n/// are returned.\n/// @brief Generalized multiplicate of integer arrays.\nstatic INLINE void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen,\n                       const uint64_t y[], uint32_t ylen, uint32_t destlen) {\n  assert(xlen > 0);\n  assert(ylen > 0);\n  assert(destlen >= xlen + ylen);\n  if (xlen < destlen) dest[xlen] = mul_1(dest, x, xlen, y[0]);\n  for (uint32_t i = 1; i < ylen; ++i) {\n    uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;\n    uint64_t carry = 0, lx = 0, hx = 0;\n    for (uint32_t j = 0; j < xlen; ++j) {\n      lx = x[j] & 0xffffffffULL;\n      hx = (x[j]) >> 32;\n      // hasCarry - A flag to indicate if has carry.\n      // hasCarry == 0, no carry\n      // hasCarry == 1, has carry\n      // hasCarry == 2, no carry and the calculation result == 0.\n      uint8_t hasCarry = 0;\n      uint64_t resul = carry + lx * ly;\n      hasCarry = (resul < carry) ? 1 : 0;\n      carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);\n      hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);\n      carry += (lx * hy) & 0xffffffffULL;\n      resul = ((carry) << 32) | (resul & 0xffffffffULL);\n      if (i + j < destlen) dest[i + j] += resul;\n      carry =\n          (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0) +\n          ((carry) >> 32) + (dest[i + j] < resul ? 1 : 0) + ((lx * hy) >> 32) +\n          hx * hy;\n    }\n    if (i + xlen < destlen) dest[i + xlen] = carry;\n  }\n}\n\n/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)\n/// from \"Art of Computer Programming, Volume 2\", section 4.3.1, p. 272. The\n/// variables here have the same names as in the algorithm. Comments explain\n/// the algorithm and any deviation from it.\nstatic INLINE void KnuthDiv(uint32_t* u, uint32_t* v, uint32_t* q, uint32_t* r,\n                            uint32_t m, uint32_t n) {\n  assert(u && \"Must provide dividend\");\n  assert(v && \"Must provide divisor\");\n  assert(q && \"Must provide quotient\");\n  assert(u != v && u != q && v != q && \"Must us different memory\");\n  assert(n > 1 && \"n must be > 1\");\n\n  // Knuth uses the value b as the base of the number system. In our case b\n  // is 2^31 so we just set it to -1u.\n  uint64_t b = uint64_t(1) << 32;\n\n  // DEBUG(cerr << \"KnuthDiv: m=\" << m << \" n=\" << n << '\\n');\n  // DEBUG(cerr << \"KnuthDiv: original:\");\n  // DEBUG(for (int i = m+n; i >=0; i--) cerr << \" \" << std::setbase(16) <<\n  // u[i]);\n  // DEBUG(cerr << \" by\");\n  // DEBUG(for (int i = n; i >0; i--) cerr << \" \" << std::setbase(16) <<\n  // v[i-1]);\n  // DEBUG(cerr << '\\n');\n  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of\n  // u and v by d. Note that we have taken Knuth's advice here to use a power\n  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of\n  // 2 allows us to shift instead of multiply and it is easy to determine the\n  // shift amount from the leading zeros.  We are basically normalizing the u\n  // and v so that its high bits are shifted to the top of v's range without\n  // overflow. Note that this can require an extra word in u so that u must\n  // be of length m+n+1.\n  uint32_t shift = CountLeadingZeros_32(v[n - 1]);\n  uint32_t v_carry = 0;\n  uint32_t u_carry = 0;\n  if (shift) {\n    for (uint32_t i = 0; i < m + n; ++i) {\n      uint32_t u_tmp = (u[i]) >> (32 - shift);\n      u[i] = ((u[i]) << (shift)) | u_carry;\n      u_carry = u_tmp;\n    }\n    for (uint32_t i = 0; i < n; ++i) {\n      uint32_t v_tmp = (v[i]) >> (32 - shift);\n      v[i] = ((v[i]) << (shift)) | v_carry;\n      v_carry = v_tmp;\n    }\n  }\n  u[m + n] = u_carry;\n  // DEBUG(cerr << \"KnuthDiv:   normal:\");\n  // DEBUG(for (int i = m+n; i >=0; i--) cerr << \" \" << std::setbase(16) <<\n  // u[i]);\n  // DEBUG(cerr << \" by\");\n  // DEBUG(for (int i = n; i >0; i--) cerr << \" \" << std::setbase(16) <<\n  // v[i-1]);\n  // DEBUG(cerr << '\\n');\n\n  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.\n  int j = m;\n  do {\n    // DEBUG(cerr << \"KnuthDiv: quotient digit #\" << j << '\\n');\n    // D3. [Calculate q'.].\n    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')\n    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')\n    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease\n    // qp by 1, inrease rp by v[n-1], and repeat this test if rp < b. The test\n    // on v[n-2] determines at high speed most of the cases in which the trial\n    // value qp is one too large, and it eliminates all cases where qp is two\n    // too large.\n    uint64_t dividend = ((uint64_t(u[j + n]) << 32) + u[j + n - 1]);\n    // DEBUG(cerr << \"KnuthDiv: dividend == \" << dividend << '\\n');\n    uint64_t qp = dividend / v[n - 1];\n    uint64_t rp = dividend % v[n - 1];\n    if (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2]) {\n      qp--;\n      rp += v[n - 1];\n      if (rp < b && (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2])) qp--;\n    }\n    // DEBUG(cerr << \"KnuthDiv: qp == \" << qp << \", rp == \" << rp << '\\n');\n\n    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with\n    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation\n    // consists of a simple multiplication by a one-place number, combined with\n    // a subtraction.\n    bool isNeg = false;\n    for (uint32_t i = 0; i < n; ++i) {\n      uint64_t u_tmp = uint64_t(u[j + i]) | ((uint64_t(u[j + i + 1])) << 32);\n      uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);\n      bool borrow = subtrahend > u_tmp;\n      /*DEBUG(cerr << \"KnuthDiv: u_tmp == \" << u_tmp\n        << \", subtrahend == \" << subtrahend\n        << \", borrow = \" << borrow << '\\n');*/\n\n      uint64_t result = u_tmp - subtrahend;\n      uint32_t k = j + i;\n      u[k++] = (uint32_t)(result & (b - 1)); // subtract low word\n      u[k++] = (uint32_t)((result) >> 32);   // subtract high word\n      while (borrow && k <= m + n) {         // deal with borrow to the left\n        borrow = u[k] == 0;\n        u[k]--;\n        k++;\n      }\n      isNeg |= borrow;\n      /*DEBUG(cerr << \"KnuthDiv: u[j+i] == \" << u[j+i] << \",  u[j+i+1] == \" <<\n        u[j+i+1] << '\\n');*/\n    }\n    /*DEBUG(cerr << \"KnuthDiv: after subtraction:\");\n      DEBUG(for (int i = m+n; i >=0; i--) cerr << \" \" << u[i]);\n      DEBUG(cerr << '\\n');*/\n    // The digits (u[j+n]...u[j]) should be kept positive; if the result of\n    // this step is actually negative, (u[j+n]...u[j]) should be left as the\n    // true value plus b**(n+1), namely as the b's complement of\n    // the true value, and a \"borrow\" to the left should be remembered.\n    //\n    if (isNeg) {\n      bool carry = true; // true because b's complement is \"complement + 1\"\n      for (uint32_t i = 0; i <= m + n; ++i) {\n        u[i] = ~u[i] + carry; // b's complement\n        carry = carry && u[i] == 0;\n      }\n    }\n    /*DEBUG(cerr << \"KnuthDiv: after complement:\");\n      DEBUG(for (int i = m+n; i >=0; i--) cerr << \" \" << u[i]);\n      DEBUG(cerr << '\\n');*/\n\n    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was\n    // negative, go to step D6; otherwise go on to step D7.\n    q[j] = (uint32_t)qp;\n    if (isNeg) {\n      // D6. [Add back]. The probability that this step is necessary is very\n      // small, on the order of only 2/b. Make sure that test data accounts for\n      // this possibility. Decrease q[j] by 1\n      q[j]--;\n      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).\n      // A carry will occur to the left of u[j+n], and it should be ignored\n      // since it cancels with the borrow that occurred in D4.\n      bool carry = false;\n      for (uint32_t i = 0; i < n; i++) {\n        uint32_t limit = AESL_std::min(u[j + i], v[i]);\n        u[j + i] += v[i] + carry;\n        carry = u[j + i] < limit || (carry && u[j + i] == limit);\n      }\n      u[j + n] += carry;\n    }\n    /*DEBUG(cerr << \"KnuthDiv: after correction:\");\n      DEBUG(for (int i = m+n; i >=0; i--) cerr <<\" \" << u[i]);\n      DEBUG(cerr << \"\\nKnuthDiv: digit result = \" << q[j] << '\\n');*/\n\n    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.\n  } while (--j >= 0);\n\n  /*DEBUG(cerr << \"KnuthDiv: quotient:\");\n    DEBUG(for (int i = m; i >=0; i--) cerr <<\" \" << q[i]);\n    DEBUG(cerr << '\\n');*/\n\n  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired\n  // remainder may be obtained by dividing u[...] by d. If r is non-null we\n  // compute the remainder (urem uses this).\n  if (r) {\n    // The value d is expressed by the \"shift\" value above since we avoided\n    // multiplication by d by using a shift left. So, all we have to do is\n    // shift right here. In order to mak\n    if (shift) {\n      uint32_t carry = 0;\n      // DEBUG(cerr << \"KnuthDiv: remainder:\");\n      for (int i = n - 1; i >= 0; i--) {\n        r[i] = ((u[i]) >> (shift)) | carry;\n        carry = (u[i]) << (32 - shift);\n        // DEBUG(cerr << \" \" << r[i]);\n      }\n    } else {\n      for (int i = n - 1; i >= 0; i--) {\n        r[i] = u[i];\n        // DEBUG(cerr << \" \" << r[i]);\n      }\n    }\n    // DEBUG(cerr << '\\n');\n  }\n  // DEBUG(cerr << std::setbase(10) << '\\n');\n}\n\ntemplate <int _AP_W, bool _AP_S>\nvoid divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,\n            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,\n            ap_private<_AP_W, _AP_S>* Quotient,\n            ap_private<_AP_W, _AP_S>* Remainder) {\n  assert(lhsWords >= rhsWords && \"Fractional result\");\n  enum { APINT_BITS_PER_WORD = 64 };\n  // First, compose the values into an array of 32-bit words instead of\n  // 64-bit words. This is a necessity of both the \"short division\" algorithm\n  // and the the Knuth \"classical algorithm\" which requires there to be native\n  // operations for +, -, and * on an m bit value with an m*2 bit result. We\n  // can't use 64-bit operands here because we don't have native results of\n  // 128-bits. Furthremore, casting the 64-bit values to 32-bit values won't\n  // work on large-endian machines.\n  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);\n  uint32_t n = rhsWords * 2;\n  uint32_t m = (lhsWords * 2) - n;\n\n  // Allocate space for the temporary values we need either on the stack, if\n  // it will fit, or on the heap if it won't.\n  uint32_t SPACE[128];\n  uint32_t* __U = 0;\n  uint32_t* __V = 0;\n  uint32_t* __Q = 0;\n  uint32_t* __R = 0;\n  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {\n    __U = &SPACE[0];\n    __V = &SPACE[m + n + 1];\n    __Q = &SPACE[(m + n + 1) + n];\n    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];\n  } else {\n    __U = new uint32_t[m + n + 1];\n    __V = new uint32_t[n];\n    __Q = new uint32_t[m + n];\n    if (Remainder) __R = new uint32_t[n];\n  }\n\n  // Initialize the dividend\n  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));\n  for (unsigned i = 0; i < lhsWords; ++i) {\n    uint64_t tmp = LHS.get_pVal(i);\n    __U[i * 2] = (uint32_t)(tmp & mask);\n    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);\n  }\n  __U[m + n] = 0; // this extra word is for \"spill\" in the Knuth algorithm.\n\n  // Initialize the divisor\n  memset(__V, 0, (n) * sizeof(uint32_t));\n  for (unsigned i = 0; i < rhsWords; ++i) {\n    uint64_t tmp = RHS.get_pVal(i);\n    __V[i * 2] = (uint32_t)(tmp & mask);\n    __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);\n  }\n\n  // initialize the quotient and remainder\n  memset(__Q, 0, (m + n) * sizeof(uint32_t));\n  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));\n\n  // Now, adjust m and n for the Knuth division. n is the number of words in\n  // the divisor. m is the number of words by which the dividend exceeds the\n  // divisor (i.e. m+n is the length of the dividend). These sizes must not\n  // contain any zero words or the Knuth algorithm fails.\n  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {\n    n--;\n    m++;\n  }\n  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;\n\n  // If we're left with only a single word for the divisor, Knuth doesn't work\n  // so we implement the short division algorithm here. This is much simpler\n  // and faster because we are certain that we can divide a 64-bit quantity\n  // by a 32-bit quantity at hardware speed and short division is simply a\n  // series of such operations. This is just like doing short division but we\n  // are using base 2^32 instead of base 10.\n  assert(n != 0 && \"Divide by zero?\");\n  if (n == 1) {\n    uint32_t divisor = __V[0];\n    uint32_t remainder = 0;\n    for (int i = m + n - 1; i >= 0; i--) {\n      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];\n      if (partial_dividend == 0) {\n        __Q[i] = 0;\n        remainder = 0;\n      } else if (partial_dividend < divisor) {\n        __Q[i] = 0;\n        remainder = (uint32_t)partial_dividend;\n      } else if (partial_dividend == divisor) {\n        __Q[i] = 1;\n        remainder = 0;\n      } else {\n        __Q[i] = (uint32_t)(partial_dividend / divisor);\n        remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));\n      }\n    }\n    if (__R) __R[0] = remainder;\n  } else {\n    // Now we're ready to invoke the Knuth classical divide algorithm. In this\n    // case n > 1.\n    KnuthDiv(__U, __V, __Q, __R, m, n);\n  }\n\n  // If the caller wants the quotient\n  if (Quotient) {\n    // Set up the Quotient value's memory.\n    if (Quotient->BitWidth != LHS.BitWidth) {\n      if (Quotient->isSingleWord()) Quotient->set_VAL(0);\n    } else\n      Quotient->clear();\n\n    // The quotient is in Q. Reconstitute the quotient into Quotient's low\n    // order words.\n    if (lhsWords == 1) {\n      uint64_t tmp =\n          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));\n      Quotient->set_VAL(tmp);\n    } else {\n      assert(!Quotient->isSingleWord() &&\n             \"Quotient ap_private not large enough\");\n      for (unsigned i = 0; i < lhsWords; ++i)\n        Quotient->set_pVal(\n            i, uint64_t(__Q[i * 2]) |\n                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));\n    }\n    Quotient->clearUnusedBits();\n  }\n\n  // If the caller wants the remainder\n  if (Remainder) {\n    // Set up the Remainder value's memory.\n    if (Remainder->BitWidth != RHS.BitWidth) {\n      if (Remainder->isSingleWord()) Remainder->set_VAL(0);\n    } else\n      Remainder->clear();\n\n    // The remainder is in R. Reconstitute the remainder into Remainder's low\n    // order words.\n    if (rhsWords == 1) {\n      uint64_t tmp =\n          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));\n      Remainder->set_VAL(tmp);\n    } else {\n      assert(!Remainder->isSingleWord() &&\n             \"Remainder ap_private not large enough\");\n      for (unsigned i = 0; i < rhsWords; ++i)\n        Remainder->set_pVal(\n            i, uint64_t(__R[i * 2]) |\n                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));\n    }\n    Remainder->clearUnusedBits();\n  }\n\n  // Clean up the memory we allocated.\n  if (__U != &SPACE[0]) {\n    delete[] __U;\n    delete[] __V;\n    delete[] __Q;\n    delete[] __R;\n  }\n}\n\ntemplate <int _AP_W, bool _AP_S>\nvoid divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,\n            uint64_t RHS, ap_private<_AP_W, _AP_S>* Quotient,\n            ap_private<_AP_W, _AP_S>* Remainder) {\n  uint32_t rhsWords = 1;\n  assert(lhsWords >= rhsWords && \"Fractional result\");\n  enum { APINT_BITS_PER_WORD = 64 };\n  // First, compose the values into an array of 32-bit words instead of\n  // 64-bit words. This is a necessity of both the \"short division\" algorithm\n  // and the the Knuth \"classical algorithm\" which requires there to be native\n  // operations for +, -, and * on an m bit value with an m*2 bit result. We\n  // can't use 64-bit operands here because we don't have native results of\n  // 128-bits. Furthremore, casting the 64-bit values to 32-bit values won't\n  // work on large-endian machines.\n  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);\n  uint32_t n = 2;\n  uint32_t m = (lhsWords * 2) - n;\n\n  // Allocate space for the temporary values we need either on the stack, if\n  // it will fit, or on the heap if it won't.\n  uint32_t SPACE[128];\n  uint32_t* __U = 0;\n  uint32_t* __V = 0;\n  uint32_t* __Q = 0;\n  uint32_t* __R = 0;\n  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {\n    __U = &SPACE[0];\n    __V = &SPACE[m + n + 1];\n    __Q = &SPACE[(m + n + 1) + n];\n    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];\n  } else {\n    __U = new uint32_t[m + n + 1];\n    __V = new uint32_t[n];\n    __Q = new uint32_t[m + n];\n    if (Remainder) __R = new uint32_t[n];\n  }\n\n  // Initialize the dividend\n  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));\n  for (unsigned i = 0; i < lhsWords; ++i) {\n    uint64_t tmp = LHS.get_pVal(i);\n    __U[i * 2] = tmp & mask;\n    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);\n  }\n  __U[m + n] = 0; // this extra word is for \"spill\" in the Knuth algorithm.\n\n  // Initialize the divisor\n  memset(__V, 0, (n) * sizeof(uint32_t));\n  __V[0] = RHS & mask;\n  __V[1] = (RHS) >> (sizeof(uint32_t) * 8);\n\n  // initialize the quotient and remainder\n  memset(__Q, 0, (m + n) * sizeof(uint32_t));\n  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));\n\n  // Now, adjust m and n for the Knuth division. n is the number of words in\n  // the divisor. m is the number of words by which the dividend exceeds the\n  // divisor (i.e. m+n is the length of the dividend). These sizes must not\n  // contain any zero words or the Knuth algorithm fails.\n  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {\n    n--;\n    m++;\n  }\n  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;\n\n  // If we're left with only a single word for the divisor, Knuth doesn't work\n  // so we implement the short division algorithm here. This is much simpler\n  // and faster because we are certain that we can divide a 64-bit quantity\n  // by a 32-bit quantity at hardware speed and short division is simply a\n  // series of such operations. This is just like doing short division but we\n  // are using base 2^32 instead of base 10.\n  assert(n != 0 && \"Divide by zero?\");\n  if (n == 1) {\n    uint32_t divisor = __V[0];\n    uint32_t remainder = 0;\n    for (int i = m + n - 1; i >= 0; i--) {\n      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];\n      if (partial_dividend == 0) {\n        __Q[i] = 0;\n        remainder = 0;\n      } else if (partial_dividend < divisor) {\n        __Q[i] = 0;\n        remainder = partial_dividend;\n      } else if (partial_dividend == divisor) {\n        __Q[i] = 1;\n        remainder = 0;\n      } else {\n        __Q[i] = partial_dividend / divisor;\n        remainder = partial_dividend - (__Q[i] * divisor);\n      }\n    }\n    if (__R) __R[0] = remainder;\n  } else {\n    // Now we're ready to invoke the Knuth classical divide algorithm. In this\n    // case n > 1.\n    KnuthDiv(__U, __V, __Q, __R, m, n);\n  }\n\n  // If the caller wants the quotient\n  if (Quotient) {\n    // Set up the Quotient value's memory.\n    if (Quotient->BitWidth != LHS.BitWidth) {\n      if (Quotient->isSingleWord()) Quotient->set_VAL(0);\n    } else\n      Quotient->clear();\n\n    // The quotient is in Q. Reconstitute the quotient into Quotient's low\n    // order words.\n    if (lhsWords == 1) {\n      uint64_t tmp =\n          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));\n      Quotient->set_VAL(tmp);\n    } else {\n      assert(!Quotient->isSingleWord() &&\n             \"Quotient ap_private not large enough\");\n      for (unsigned i = 0; i < lhsWords; ++i)\n        Quotient->set_pVal(\n            i, uint64_t(__Q[i * 2]) |\n                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));\n    }\n    Quotient->clearUnusedBits();\n  }\n\n  // If the caller wants the remainder\n  if (Remainder) {\n    // Set up the Remainder value's memory.\n    if (Remainder->BitWidth != 64 /* RHS.BitWidth */) {\n      if (Remainder->isSingleWord()) Remainder->set_VAL(0);\n    } else\n      Remainder->clear();\n\n    // The remainder is in __R. Reconstitute the remainder into Remainder's low\n    // order words.\n    if (rhsWords == 1) {\n      uint64_t tmp =\n          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));\n      Remainder->set_VAL(tmp);\n    } else {\n      assert(!Remainder->isSingleWord() &&\n             \"Remainder ap_private not large enough\");\n      for (unsigned i = 0; i < rhsWords; ++i)\n        Remainder->set_pVal(\n            i, uint64_t(__R[i * 2]) |\n                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));\n    }\n    Remainder->clearUnusedBits();\n  }\n\n  // Clean up the memory we allocated.\n  if (__U != &SPACE[0]) {\n    delete[] __U;\n    delete[] __V;\n    delete[] __Q;\n    delete[] __R;\n  }\n}\n\n/// @brief Logical right-shift function.\ntemplate <int _AP_W, bool _AP_S, bool _AP_C>\nINLINE ap_private<_AP_W, _AP_S, _AP_C> lshr(\n    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {\n  return LHS.lshr(shiftAmt);\n}\n\n/// Left-shift the ap_private by shiftAmt.\n/// @brief Left-shift function.\ntemplate <int _AP_W, bool _AP_S, bool _AP_C>\nINLINE ap_private<_AP_W, _AP_S, _AP_C> shl(\n    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {\n  return LHS.shl(shiftAmt);\n}\n\n} // namespace ap_private_ops\n\n#endif // LLVM_SUPPORT_MATHEXTRAS_H\n\n/// This enumeration just provides for internal constants used in this\n/// translation unit.\nenum {\n  MIN_INT_BITS = 1, ///< Minimum number of bits that can be specified\n  ///< Note that this must remain synchronized with IntegerType::MIN_INT_BITS\n  MAX_INT_BITS = (1 << 23) - 1 ///< Maximum number of bits that can be specified\n  ///< Note that this must remain synchronized with IntegerType::MAX_INT_BITS\n};\n\n//===----------------------------------------------------------------------===//\n//                              ap_private Class\n//===----------------------------------------------------------------------===//\n\n/// ap_private - This class represents arbitrary precision constant integral\n/// values.\n/// It is a functional replacement for common case unsigned integer type like\n/// \"unsigned\", \"unsigned long\" or \"uint64_t\", but also allows non-byte-width\n/// integer sizes and large integer value types such as 3-bits, 15-bits, or more\n/// than 64-bits of precision. ap_private provides a variety of arithmetic\n/// operators\n/// and methods to manipulate integer values of any bit-width. It supports both\n/// the typical integer arithmetic and comparison operations as well as bitwise\n/// manipulation.\n///\n/// The class has several invariants worth noting:\n///   * All bit, byte, and word positions are zero-based.\n///   * Once the bit width is set, it doesn't change except by the Truncate,\n///     SignExtend, or ZeroExtend operations.\n///   * All binary operators must be on ap_private instances of the same bit\n///   width.\n///     Attempting to use these operators on instances with different bit\n///     widths will yield an assertion.\n///   * The value is stored canonically as an unsigned value. For operations\n///     where it makes a difference, there are both signed and unsigned variants\n///     of the operation. For example, sdiv and udiv. However, because the bit\n///     widths must be the same, operations such as Mul and Add produce the same\n///     results regardless of whether the values are interpreted as signed or\n///     not.\n///   * In general, the class tries to follow the style of computation that LLVM\n///     uses in its IR. This simplifies its use for LLVM.\n///\n/// @brief Class for arbitrary precision integers.\n\n#if defined(_MSC_VER)\n#if _MSC_VER < 1400 && !defined(for)\n#define for if (0); else for\n#endif\ntypedef unsigned __int64 ap_ulong;\ntypedef signed __int64 ap_slong;\n#else\ntypedef unsigned long long ap_ulong;\ntypedef signed long long ap_slong;\n#endif\ntemplate <int _AP_N8, bool _AP_S>\nstruct valtype;\n\ntemplate <int _AP_N8>\nstruct valtype<_AP_N8, false> {\n  typedef uint64_t Type;\n};\n\ntemplate <int _AP_N8>\nstruct valtype<_AP_N8, true> {\n  typedef int64_t Type;\n};\n\ntemplate <>\nstruct valtype<1, false> {\n  typedef unsigned char Type;\n};\ntemplate <>\nstruct valtype<2, false> {\n  typedef unsigned short Type;\n};\ntemplate <>\nstruct valtype<3, false> {\n  typedef unsigned int Type;\n};\ntemplate <>\nstruct valtype<4, false> {\n  typedef unsigned int Type;\n};\ntemplate <>\nstruct valtype<1, true> {\n  typedef signed char Type;\n};\ntemplate <>\nstruct valtype<2, true> {\n  typedef short Type;\n};\ntemplate <>\nstruct valtype<3, true> {\n  typedef int Type;\n};\ntemplate <>\nstruct valtype<4, true> {\n  typedef int Type;\n};\n\ntemplate <bool enable>\nstruct ap_private_enable_if {};\ntemplate <>\nstruct ap_private_enable_if<true> {\n  static const bool isValid = true;\n};\n\n// When bitwidth < 64\ntemplate <int _AP_W, bool _AP_S>\nclass ap_private<_AP_W, _AP_S, true> {\n  // SFINAE pattern.  Only consider this class when _AP_W <= 64\n  const static bool valid = ap_private_enable_if<_AP_W <= 64>::isValid;\n \n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n public:\n  typedef typename valtype<(_AP_W + 7) / 8, _AP_S>::Type ValType;\n  typedef ap_private<_AP_W, _AP_S> Type;\n  template <int _AP_W2, bool _AP_S2>\n  struct RType {\n    enum {\n      mult_w = _AP_W + _AP_W2,\n      mult_s = _AP_S || _AP_S2,\n      plus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      plus_s = _AP_S || _AP_S2,\n      minus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      minus_s = true,\n      div_w = _AP_W + _AP_S2,\n      div_s = _AP_S || _AP_S2,\n      mod_w = AP_MIN(_AP_W, _AP_W2 + (!_AP_S2 && _AP_S)),\n      mod_s = _AP_S,\n      logic_w = AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)),\n      logic_s = _AP_S || _AP_S2\n    };\n    typedef ap_private<mult_w, mult_s> mult;\n    typedef ap_private<plus_w, plus_s> plus;\n    typedef ap_private<minus_w, minus_s> minus;\n    typedef ap_private<logic_w, logic_s> logic;\n    typedef ap_private<div_w, div_s> div;\n    typedef ap_private<mod_w, mod_s> mod;\n    typedef ap_private<_AP_W, _AP_S> arg1;\n    typedef bool reduce;\n  };\n  enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };\n  enum {\n    excess_bits = (_AP_W % APINT_BITS_PER_WORD)\n                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)\n                      : 0\n  };\n  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));\n  static const uint64_t not_mask = ~mask;\n  static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD - 1);\n  template <int _AP_W1>\n  struct sign_ext_mask {\n    static const uint64_t mask = ~0ULL << _AP_W1;\n  };\n  static const int width = _AP_W;\n\n  enum {\n    BitWidth = _AP_W,\n    _AP_N = 1,\n  };\n  ValType VAL; ///< Used to store the <= 64 bits integer value.\n#ifdef AP_CANARY\n  ValType CANARY;\n  void check_canary() { assert(CANARY == (ValType)0xDEADBEEFDEADBEEF); }\n  void set_canary() { CANARY = (ValType)0xDEADBEEFDEADBEEF; }\n#else\n  void check_canary() {}\n  void set_canary() {}\n#endif\n\n  INLINE ValType& get_VAL(void) { return VAL; }\n  INLINE ValType get_VAL(void) const { return VAL; }\n  INLINE ValType get_VAL(void) const volatile { return VAL; }\n  INLINE void set_VAL(uint64_t value) { VAL = (ValType)value; }\n  INLINE ValType& get_pVal(int i) { return VAL; }\n  INLINE ValType get_pVal(int i) const { return VAL; }\n  INLINE const uint64_t* get_pVal() const {\n    assert(0 && \"invalid usage\");\n    return 0;\n  }\n  INLINE ValType get_pVal(int i) const volatile { return VAL; }\n  INLINE uint64_t* get_pVal() const volatile {\n    assert(0 && \"invalid usage\");\n    return 0;\n  }\n  INLINE void set_pVal(int i, uint64_t value) { VAL = (ValType)value; }\n\n  INLINE uint32_t getBitWidth() const { return BitWidth; }\n\n  template <int _AP_W1, bool _AP_S1>\n  ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  ap_private<_AP_W, _AP_S>& operator=(\n      const volatile ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(RHS.get_VAL()); // TODO check here about ap_private<W,S,false>\n    clearUnusedBits();\n    return *this;\n  }\n\n  void operator=(const ap_private& RHS) volatile {\n    // Don't do anything for X = X\n    VAL = RHS.get_VAL(); // No need to check because no harm done by copying.\n    clearUnusedBits();\n  }\n\n  ap_private& operator=(const ap_private& RHS) {\n    // Don't do anything for X = X\n    VAL = RHS.get_VAL(); // No need to check because no harm done by copying.\n    clearUnusedBits();\n    return *this;\n  }\n\n  void operator=(const volatile ap_private& RHS) volatile {\n    // Don't do anything for X = X\n    VAL = RHS.get_VAL(); // No need to check because no harm done by copying.\n    clearUnusedBits();\n  }\n\n  ap_private& operator=(const volatile ap_private& RHS) {\n    // Don't do anything for X = X\n    VAL = RHS.get_VAL(); // No need to check because no harm done by copying.\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    *this = ap_private<_AP_W2, false>(op2);\n    return *this;\n  }\n\n#define ASSIGN_OP_FROM_INT(C_TYPE)               \\\n  INLINE ap_private& operator=(const C_TYPE v) { \\\n    set_canary();                                \\\n    this->VAL = (ValType)v;                      \\\n    clearUnusedBits();                           \\\n    check_canary();                              \\\n    return *this;                                \\\n  }\n\nASSIGN_OP_FROM_INT(bool)\nASSIGN_OP_FROM_INT(char)\nASSIGN_OP_FROM_INT(signed char)\nASSIGN_OP_FROM_INT(unsigned char)\nASSIGN_OP_FROM_INT(short)\nASSIGN_OP_FROM_INT(unsigned short)\nASSIGN_OP_FROM_INT(int)\nASSIGN_OP_FROM_INT(unsigned int)\nASSIGN_OP_FROM_INT(long)\nASSIGN_OP_FROM_INT(unsigned long)\nASSIGN_OP_FROM_INT(ap_slong)\nASSIGN_OP_FROM_INT(ap_ulong)\nASSIGN_OP_FROM_INT(half)\n//FIXME cast half to integer ?\nASSIGN_OP_FROM_INT(float)\nASSIGN_OP_FROM_INT(double)\n#undef ASSIGN_OP_FROM_INT\n\n  // XXX This is a must to prevent pointer being converted to bool.\n  INLINE ap_private& operator=(const char* s) {\n    ap_private tmp(s); // XXX direct-initialization, as ctor is explicit.\n    operator=(tmp);\n    return *this;\n  }\n\n private:\n  explicit INLINE ap_private(uint64_t* val) : VAL(val[0]) {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n  INLINE bool isSingleWord() const { return true; }\n\n public:\n  INLINE void fromString(const char* strStart, uint32_t slen, uint8_t radix) {\n    bool isNeg = strStart[0] == '-';\n    if (isNeg) {\n      strStart++;\n      slen--;\n    }\n\n    if (strStart[0] == '0' && (strStart[1] == 'b' || strStart[1] == 'B')) {\n      //if(radix == 0) radix = 2;\n      _AP_WARNING(radix != 2, \"%s seems to have base %d, but %d given.\", strStart, 2, radix);\n      strStart += 2;\n      slen -=2;\n    } else if (strStart[0] == '0' && (strStart[1] == 'o' || strStart[1] == 'O')) {\n      //if (radix == 0) radix = 8;\n      _AP_WARNING(radix != 8, \"%s seems to have base %d, but %d given.\", strStart, 8, radix);\n      strStart += 2;\n      slen -=2;\n    } else if (strStart[0] == '0' && (strStart[1] == 'x' || strStart[1] == 'X')) {\n      //if (radix == 0) radix = 16;\n      _AP_WARNING(radix != 16, \"%s seems to have base %d, but %d given.\", strStart, 16, radix);\n      strStart += 2;\n      slen -=2;\n    } else if (strStart[0] == '0' && (strStart[1] == 'd' || strStart[1] == 'D')) {\n      //if (radix == 0) radix = 10;\n      _AP_WARNING(radix != 10, \"%s seems to have base %d, but %d given.\", strStart, 10, radix);\n      strStart += 2;\n      slen -=2;\n    } else if (radix == 0) {\n      //radix = 2; // XXX default value\n    }\n\n    // Check our assumptions here\n    assert((radix == 10 || radix == 8 || radix == 16 || radix == 2) &&\n           \"Radix should be 2, 8, 10, or 16!\");\n    assert(strStart && \"String is null?\");\n\n    // Clear bits.\n    uint64_t tmpVAL = VAL = 0;\n\n    switch (radix) {\n      case 2:\n        //        sscanf(strStart,\"%b\",&VAL);\n        // tmpVAL = *strStart =='1' ? ~0ULL : 0;\n        for (; *strStart; ++strStart) {\n          assert((*strStart == '0' || *strStart == '1') &&\n                 (\"Wrong binary number\"));\n          tmpVAL <<= 1;\n          tmpVAL |= (*strStart - '0');\n        }\n        break;\n      case 8:\n#ifdef _MSC_VER\n        sscanf_s(strStart, \"%llo\", &tmpVAL, slen + 1);\n#else\n#if defined(__x86_64__) && !defined(__MINGW32__) && !defined(__WIN32__)\n        sscanf(strStart, \"%lo\", &tmpVAL);\n#else\n        sscanf(strStart, \"%llo\", &tmpVAL);\n#endif //__x86_64__\n#endif //_MSC_VER\n        break;\n      case 10:\n#ifdef _MSC_VER\n        sscanf_s(strStart, \"%llu\", &tmpVAL, slen + 1);\n#else\n#if defined(__x86_64__) && !defined(__MINGW32__) && !defined(__WIN32__)\n        sscanf(strStart, \"%lu\", &tmpVAL);\n#else\n        sscanf(strStart, \"%llu\", &tmpVAL);\n#endif //__x86_64__\n#endif //_MSC_VER\n        break;\n      case 16:\n#ifdef _MSC_VER\n        sscanf_s(strStart, \"%llx\", &tmpVAL, slen + 1);\n#else\n#if defined(__x86_64__) && !defined(__MINGW32__) && !defined(__WIN32__)\n        sscanf(strStart, \"%lx\", &tmpVAL);\n#else\n        sscanf(strStart, \"%llx\", &tmpVAL);\n#endif //__x86_64__\n#endif //_MSC_VER\n        break;\n      default:\n        assert(true && \"Unknown radix\");\n        // error\n    }\n    VAL = isNeg ? (ValType)(-tmpVAL) : (ValType)(tmpVAL);\n\n    clearUnusedBits();\n  }\n\n private:\n  INLINE ap_private(const std::string& val, uint8_t radix = 2) : VAL(0) {\n    assert(!val.empty() && \"String empty?\");\n    set_canary();\n    fromString(val.c_str(), val.size(), radix);\n    check_canary();\n  }\n\n  INLINE ap_private(const char strStart[], uint32_t slen, uint8_t radix)\n      : VAL(0) {\n    set_canary();\n    fromString(strStart, slen, radix);\n    check_canary();\n  }\n\n  INLINE ap_private(uint32_t numWords, const uint64_t bigVal[])\n      : VAL(bigVal[0]) {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n public:\n  INLINE ap_private() {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n#define CTOR(TYPE)                              \\\n  INLINE ap_private(TYPE v) : VAL((ValType)v) { \\\n    set_canary();                               \\\n    clearUnusedBits();                          \\\n    check_canary();                             \\\n  }\n  CTOR(bool)\n  CTOR(char)\n  CTOR(signed char)\n  CTOR(unsigned char)\n  CTOR(short)\n  CTOR(unsigned short)\n  CTOR(int)\n  CTOR(unsigned int)\n  CTOR(long)\n  CTOR(unsigned long)\n  CTOR(ap_slong)\n  CTOR(ap_ulong)\n  CTOR(half)\n  CTOR(float)\n  CTOR(double)\n#undef CTOR\n\n  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>\n  INLINE ap_private(const ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)\n      : VAL((ValType)that.get_VAL()) {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>\n  INLINE ap_private(const volatile ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)\n      : VAL((ValType)that.get_VAL()) {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n  explicit INLINE ap_private(const char* val) {\n    set_canary();\n    unsigned char radix = 10;\n    std::string str = ap_private_ops::parseString(val, radix); // will set radix.\n    std::string::size_type pos = str.find('.');\n    // trunc all fraction part\n    if (pos != std::string::npos) str = str.substr(pos);\n\n    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);\n    operator=(ap_private_val);\n    check_canary();\n  }\n\n  INLINE ap_private(const char* val, signed char rd) {\n    set_canary();\n    unsigned char radix = rd;\n    std::string str = ap_private_ops::parseString(val, radix); // will set radix.\n    std::string::size_type pos = str.find('.');\n    // trunc all fraction part\n    if (pos != std::string::npos) str = str.substr(pos);\n\n    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);\n    operator=(ap_private_val);\n    check_canary();\n  }\n\n  INLINE ~ap_private() { check_canary(); }\n\n  INLINE bool isNegative() const {\n    static const uint64_t sign_mask = 1ULL << (_AP_W - 1);\n    return _AP_S && (sign_mask & VAL);\n  }\n\n  INLINE bool isPositive() const { return !isNegative(); }\n\n  INLINE bool isStrictlyPositive() const { return !isNegative() && VAL != 0; }\n\n  INLINE bool isAllOnesValue() const { return (mask & VAL) == mask; }\n\n  INLINE bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const {\n    return VAL == RHS.get_VAL();\n  }\n  INLINE bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const {\n    return (uint64_t)VAL == (uint64_t)RHS.get_VAL();\n  }\n\n  INLINE bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }\n  INLINE bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }\n  INLINE bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const {\n    return VAL != RHS.get_VAL();\n  }\n  INLINE bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const {\n    return (uint64_t)VAL != (uint64_t)RHS.get_VAL();\n  }\n\n  /// postfix increment.\n  const ap_private operator++(int) {\n    ap_private orig(*this);\n    VAL++;\n    clearUnusedBits();\n    return orig;\n  }\n\n  /// prefix increment.\n  const ap_private operator++() {\n    ++VAL;\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// postfix decrement.\n  const ap_private operator--(int) {\n    ap_private orig(*this);\n    --VAL;\n    clearUnusedBits();\n    return orig;\n  }\n\n  /// prefix decrement.\n  const ap_private operator--() {\n    --VAL;\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// one's complement.\n  INLINE ap_private<_AP_W + !_AP_S, true> operator~() const {\n    ap_private<_AP_W + !_AP_S, true> Result(*this);\n    Result.flip();\n    return Result;\n  }\n\n  /// two's complement.\n  INLINE typename RType<1, false>::minus operator-() const {\n    return ap_private<1, false>(0) - (*this);\n  }\n\n  /// logic negation.\n  INLINE bool operator!() const { return !VAL; }\n\n  INLINE std::string toString(uint8_t radix, bool wantSigned) const;\n  INLINE std::string toStringUnsigned(uint8_t radix = 10) const {\n    return toString(radix, false);\n  }\n  INLINE std::string toStringSigned(uint8_t radix = 10) const {\n    return toString(radix, true);\n  }\n  INLINE void clear() { VAL = 0; }\n  INLINE ap_private& clear(uint32_t bitPosition) {\n    VAL &= ~(1ULL << (bitPosition));\n    clearUnusedBits();\n    return *this;\n  }\n\n  INLINE ap_private ashr(uint32_t shiftAmt) const {\n    if (_AP_S)\n      return ap_private((shiftAmt == BitWidth) ? 0\n                                               : ((int64_t)VAL) >> (shiftAmt));\n    else\n      return ap_private((shiftAmt == BitWidth) ? 0\n                                               : ((uint64_t)VAL) >> (shiftAmt));\n  }\n\n  INLINE ap_private lshr(uint32_t shiftAmt) const {\n    return ap_private((shiftAmt == BitWidth)\n                          ? ap_private(0)\n                          : ap_private((VAL & mask) >> (shiftAmt)));\n  }\n\n  INLINE ap_private shl(uint32_t shiftAmt) const\n// just for clang compiler\n#if defined(__clang__) && !defined(__CLANG_3_1__)\n      __attribute__((no_sanitize(\"undefined\")))\n#endif\n  {\n    if (shiftAmt > BitWidth) {\n      if (!isNegative())\n        return ap_private(0);\n      else\n        return ap_private(-1);\n    }\n    if (shiftAmt == BitWidth)\n      return ap_private(0);\n    else\n      return ap_private((VAL) << (shiftAmt));\n    // return ap_private((shiftAmt == BitWidth) ? ap_private(0ULL) :\n    // ap_private(VAL << shiftAmt));\n  }\n\n  INLINE int64_t getSExtValue() const { return VAL; }\n\n  // XXX XXX this function is used in CBE\n  INLINE uint64_t getZExtValue() const { return VAL & mask; }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {\n    set_canary();\n    *this = ref.get();\n    check_canary();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {\n    set_canary();\n    *this = ((uint64_t)(bool)ref);\n    check_canary();\n  }\n\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {\n//    set_canary();\n//    *this = ref.get();\n//    check_canary();\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_private(\n//      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n//    set_canary();\n//    *this = ((val.operator ap_private<_AP_W2, false>()));\n//    check_canary();\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_private(\n//      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n//    set_canary();\n//    *this = (uint64_t)(bool)val;\n//    check_canary();\n//  }\n\n  INLINE void write(const ap_private<_AP_W, _AP_S>& op2) volatile {\n    *this = (op2);\n  }\n\n  // Explicit conversions to C interger types\n  //-----------------------------------------------------------\n  INLINE operator ValType() const { return get_VAL(); }\n\n  INLINE int to_uchar() const { return (unsigned char)get_VAL(); }\n\n  INLINE int to_char() const { return (signed char)get_VAL(); }\n\n  INLINE int to_ushort() const { return (unsigned short)get_VAL(); }\n\n  INLINE int to_short() const { return (short)get_VAL(); }\n\n  INLINE int to_int() const {\n    //      ap_private<64 /* _AP_W */, _AP_S> res(V);\n    return (int)get_VAL();\n  }\n\n  INLINE unsigned to_uint() const { return (unsigned)get_VAL(); }\n\n  INLINE long to_long() const { return (long)get_VAL(); }\n\n  INLINE unsigned long to_ulong() const { return (unsigned long)get_VAL(); }\n\n  INLINE ap_slong to_int64() const { return (ap_slong)get_VAL(); }\n\n  INLINE ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }\n\n  INLINE double to_double() const {\n    if (isNegative())\n      return roundToDouble(true);\n    else\n      return roundToDouble(false);\n  }\n\n  INLINE unsigned length() const { return _AP_W; }\n\n  INLINE bool isMinValue() const { return VAL == 0; }\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) & RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) | RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) ^ RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) * RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) + RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    VAL = (ValType)(((uint64_t)VAL) - RHS.get_VAL());\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::logic operator&(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {\n      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) &\n                                                RHS.get_VAL());\n      return Ret;\n    } else {\n      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;\n      return Ret & RHS;\n    }\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::logic operator^(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {\n      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^\n                                                RHS.get_VAL());\n      return Ret;\n    } else {\n      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;\n      return Ret ^ RHS;\n    }\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::logic operator|(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {\n      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) |\n                                                RHS.get_VAL());\n      return Ret;\n    } else {\n      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;\n      return Ret | RHS;\n    }\n  }\n\n  INLINE ap_private And(const ap_private& RHS) const {\n    return ap_private(VAL & RHS.get_VAL());\n  }\n\n  INLINE ap_private Or(const ap_private& RHS) const {\n    return ap_private(VAL | RHS.get_VAL());\n  }\n\n  INLINE ap_private Xor(const ap_private& RHS) const {\n    return ap_private(VAL ^ RHS.get_VAL());\n  }\n#if 1\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::mult operator*(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {\n      typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) *\n                                                  RHS.get_VAL());\n      return Result;\n    } else {\n      typename RType<_AP_W1, _AP_S1>::mult Result(*this);\n      Result *= RHS;\n      return Result;\n    }\n  }\n#endif\n  INLINE ap_private Mul(const ap_private& RHS) const {\n    return ap_private(VAL * RHS.get_VAL());\n  }\n\n  INLINE ap_private Add(const ap_private& RHS) const {\n    return ap_private(VAL + RHS.get_VAL());\n  }\n\n  INLINE ap_private Sub(const ap_private& RHS) const {\n    return ap_private(VAL - RHS.get_VAL());\n  }\n\n  INLINE ap_private& operator&=(uint64_t RHS) {\n    VAL &= (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator|=(uint64_t RHS) {\n    VAL |= (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator^=(uint64_t RHS) {\n    VAL ^= (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator*=(uint64_t RHS) {\n    VAL *= (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator+=(uint64_t RHS) {\n    VAL += (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator-=(uint64_t RHS) {\n    VAL -= (ValType)RHS;\n    clearUnusedBits();\n    return *this;\n  }\n\n  INLINE bool isMinSignedValue() const {\n    static const uint64_t min_mask = ~(~0ULL << (_AP_W - 1));\n    return BitWidth == 1 ? VAL == 1\n                         : (ap_private_ops::isNegative<_AP_W>(*this) &&\n                            ((min_mask & VAL) == 0));\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::plus operator+(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::plus_w <= 64)\n      return typename RType<_AP_W1, _AP_S1>::plus(\n          RType<_AP_W1, _AP_S1>::plus_s\n              ? int64_t(((uint64_t)VAL) + RHS.get_VAL())\n              : uint64_t(((uint64_t)VAL) + RHS.get_VAL()));\n    typename RType<_AP_W1, _AP_S1>::plus Result = RHS;\n    Result += VAL;\n    return Result;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::minus operator-(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (RType<_AP_W1, _AP_S1>::minus_w <= 64)\n      return typename RType<_AP_W1, _AP_S1>::minus(\n          int64_t(((uint64_t)VAL) - RHS.get_VAL()));\n    typename RType<_AP_W1, _AP_S1>::minus Result = *this;\n    Result -= RHS;\n    return Result;\n  }\n\n  INLINE uint32_t countPopulation() const {\n    return ap_private_ops::CountPopulation_64(VAL);\n  }\n  INLINE uint32_t countLeadingZeros() const {\n    int remainder = BitWidth % 64;\n    int excessBits = (64 - remainder) % 64;\n    uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);\n    if (Count) Count -= excessBits;\n    return AESL_std::min(Count, (uint32_t)_AP_W);\n  }\n\n  /// HiBits - This function returns the high \"numBits\" bits of this ap_private.\n  INLINE ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {\n    ap_private<_AP_W, _AP_S> ret(*this);\n    ret = (ret) >> (BitWidth - numBits);\n    return ret;\n  }\n\n  /// LoBits - This function returns the low \"numBits\" bits of this ap_private.\n  INLINE ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {\n    ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));\n    ret = (ret) >> (BitWidth - numBits);\n    return ret;\n    // return ap_private(numBits, (VAL << (BitWidth - numBits))>> (BitWidth -\n    // numBits));\n  }\n\n  INLINE ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {\n    VAL |= (1ULL << (bitPosition));\n    clearUnusedBits();\n    return *this; // clearUnusedBits();\n  }\n\n  INLINE void set() {\n    VAL = (ValType)~0ULL;\n    clearUnusedBits();\n  }\n\n  template <int _AP_W3>\n  INLINE void set(const ap_private<_AP_W3, false>& val) {\n    operator=(ap_private<_AP_W3, _AP_S>(val));\n  }\n\n  INLINE void set(const ap_private& val) { operator=(val); }\n\n  INLINE void clearUnusedBits(void) volatile\n// just for clang compiler\n#if defined(__clang__) && !defined(__CLANG_3_1__)\n      __attribute__((no_sanitize(\"undefined\")))\n#endif\n  {\n    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };\n    VAL = (ValType)(\n        _AP_S\n            ? ((((int64_t)VAL) << (excess_bits)) >> (excess_bits))\n            : (excess_bits ? (((uint64_t)VAL) << (excess_bits)) >> (excess_bits)\n                           : (uint64_t)VAL));\n  }\n\n  INLINE void clearUnusedBitsToZero(void) {\n    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };\n    static uint64_t mask = ~0ULL >> (excess_bits);\n    VAL &= mask;\n  }\n\n  INLINE ap_private udiv(const ap_private& RHS) const {\n    return ap_private((uint64_t)VAL / RHS.get_VAL());\n  }\n\n  /// Signed divide this ap_private by ap_private RHS.\n  /// @brief Signed division function for ap_private.\n  INLINE ap_private sdiv(const ap_private& RHS) const {\n    if (isNegative())\n      if (RHS.isNegative())\n        return ((uint64_t)(0 - (*this))) / (uint64_t)(0 - RHS);\n      else\n        return 0 - ((uint64_t)(0 - (*this)) / (uint64_t)(RHS));\n    else if (RHS.isNegative())\n      return 0 - (this->udiv((ap_private)(0 - RHS)));\n    return this->udiv(RHS);\n  }\n\n  template <bool _AP_S2>\n  INLINE ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {\n    assert(RHS.get_VAL() != 0 && \"Divide by 0\");\n    return ap_private(((uint64_t)VAL) % ((uint64_t)RHS.get_VAL()));\n  }\n\n  /// Signed remainder operation on ap_private.\n  /// @brief Function for signed remainder operation.\n  template <bool _AP_S2>\n  INLINE ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {\n    if (isNegative()) {\n      ap_private lhs = 0 - (*this);\n      if (RHS.isNegative()) {\n        ap_private rhs = 0 - RHS;\n        return 0 - (lhs.urem(rhs));\n      } else\n        return 0 - (lhs.urem(RHS));\n    } else if (RHS.isNegative()) {\n      ap_private rhs = 0 - RHS;\n      return this->urem(rhs);\n    }\n    return this->urem(RHS);\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return (*this) == RHS;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the less-than relationship.\n  /// @returns true if *this < RHS when both are considered unsigned.\n  /// @brief Unsigned less than comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    if (_AP_W1 <= 64) {\n      uint64_t lhsZext = ((uint64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);\n      uint64_t rhsZext =\n          ((uint64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);\n      return lhsZext < rhsZext;\n    } else\n      return RHS.uge(*this);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-than relationship.\n  /// @returns true if *this < RHS when both are considered signed.\n  /// @brief Signed less than comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const\n// just for clang compiler\n#if defined(__clang__) && !defined(__CLANG_3_1__)\n      __attribute__((no_sanitize(\"undefined\")))\n#endif\n  {\n    if (_AP_W1 <= 64) {\n      int64_t lhsSext = ((int64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);\n      int64_t rhsSext =\n          ((int64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);\n      return lhsSext < rhsSext;\n    } else\n      return RHS.sge(*this);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  /// @returns true if *this <= RHS when both are considered unsigned.\n  /// @brief Unsigned less or equal comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return ult(RHS) || eq(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  /// @returns true if *this <= RHS when both are considered signed.\n  /// @brief Signed less or equal comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return slt(RHS) || eq(RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the greater-than relationship.\n  /// @returns true if *this > RHS when both are considered unsigned.\n  /// @brief Unsigned greather than comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return !ult(RHS) && !eq(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// the validity of the greater-than relationship.\n  /// @returns true if *this > RHS when both are considered signed.\n  /// @brief Signed greather than comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return !slt(RHS) && !eq(RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  /// @returns true if *this >= RHS when both are considered unsigned.\n  /// @brief Unsigned greater or equal comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return !ult(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  /// @returns true if *this >= RHS when both are considered signed.\n  /// @brief Signed greather or equal comparison\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    return !slt(RHS);\n  }\n\n  INLINE ap_private abs() const {\n    if (isNegative()) return -(*this);\n    return *this;\n  }\n\n  INLINE ap_private<_AP_W, false> get() const {\n    ap_private<_AP_W, false> ret(*this);\n    return ret;\n  }\n\n  INLINE static uint32_t getBitsNeeded(const char* str, uint32_t slen,\n                                       uint8_t radix) {\n    return _AP_W;\n  }\n\n  INLINE uint32_t getActiveBits() const {\n    uint32_t bits = _AP_W - countLeadingZeros();\n    return bits ? bits : 1;\n  }\n\n  INLINE double roundToDouble(bool isSigned = false) const {\n    return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);\n  }\n\n  /*Reverse the contents of ap_private instance. I.e. LSB becomes MSB and vise\n   * versa*/\n  INLINE ap_private& reverse() {\n    for (int i = 0; i < _AP_W / 2; ++i) {\n      bool tmp = operator[](i);\n      if (operator[](_AP_W - 1 - i))\n        set(i);\n      else\n        clear(i);\n      if (tmp)\n        set(_AP_W - 1 - i);\n      else\n        clear(_AP_W - 1 - i);\n    }\n    clearUnusedBits();\n    return *this;\n  }\n\n  /*Return true if the value of ap_private instance is zero*/\n  INLINE bool iszero() const { return isMinValue(); }\n\n  INLINE bool to_bool() const { return !iszero(); }\n\n  /* x < 0 */\n  INLINE bool sign() const {\n    if (isNegative()) return true;\n    return false;\n  }\n\n  /* x[i] = !x[i] */\n  INLINE void invert(int i) {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    flip(i);\n  }\n\n  /* x[i] */\n  INLINE bool test(int i) const {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    return operator[](i);\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_private object n places to the left\n  INLINE void lrotate(int n) {\n    assert(n >= 0 && \"Attempting to shift negative index\");\n    assert(n < _AP_W && \"Shift value larger than bit width\");\n    operator=(shl(n) | lshr(_AP_W - n));\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_private object n places to the right\n  INLINE void rrotate(int n) {\n    assert(n >= 0 && \"Attempting to shift negative index\");\n    assert(n < _AP_W && \"Shift value larger than bit width\");\n    operator=(lshr(n) | shl(_AP_W - n));\n  }\n\n  // Set the ith bit into v\n  INLINE void set(int i, bool v) {\n    assert(i >= 0 && \"Attempting to write bit with negative index\");\n    assert(i < _AP_W && \"Attempting to write bit beyond MSB\");\n    v ? set(i) : clear(i);\n  }\n\n  // Set the ith bit into v\n  INLINE void set_bit(int i, bool v) {\n    assert(i >= 0 && \"Attempting to write bit with negative index\");\n    assert(i < _AP_W && \"Attempting to write bit beyond MSB\");\n    v ? set(i) : clear(i);\n  }\n\n  // Get the value of ith bit\n  INLINE bool get_bit(int i) const {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    return (((1ULL << i) & VAL) != 0);\n  }\n\n  /// Toggle all bits.\n  INLINE ap_private& flip() {\n    VAL = (ValType)((~0ULL ^ VAL) & mask);\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// Toggles a given bit to its opposite value.\n  INLINE ap_private& flip(uint32_t bitPosition) {\n    assert(bitPosition < BitWidth && \"Out of the bit-width range!\");\n    set_bit(bitPosition, !get_bit(bitPosition));\n    return *this;\n  }\n\n  // complements every bit\n  INLINE void b_not() { flip(); }\n\n// Binary Arithmetic\n//-----------------------------------------------------------\n#define OP_BIN_AP(Sym, Rty, Fun)                           \\\n  template <int _AP_W2, bool _AP_S2>                       \\\n  INLINE typename RType<_AP_W2, _AP_S2>::Rty operator Sym( \\\n      const ap_private<_AP_W2, _AP_S2>& op) const {        \\\n    typename RType<_AP_W2, _AP_S2>::Rty lhs(*this);        \\\n    typename RType<_AP_W2, _AP_S2>::Rty rhs(op);           \\\n    return lhs.Fun(rhs);                                   \\\n  }\n\n/// Bitwise and, or, xor\n// OP_BIN_AP(&,logic, And)\n// OP_BIN_AP(|,logic, Or)\n// OP_BIN_AP(^,logic, Xor)\n#undef OP_BIN_AP\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE typename RType<_AP_W2, _AP_S2>::div operator/(\n      const ap_private<_AP_W2, _AP_S2>& op) const {\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        lhs = *this;\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        rhs = op;\n    return typename RType<_AP_W2, _AP_S2>::div(\n        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE typename RType<_AP_W2, _AP_S2>::mod operator%(\n      const ap_private<_AP_W2, _AP_S2>& op) const {\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        lhs = *this;\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        rhs = op;\n    typename RType<_AP_W2, _AP_S2>::mod res =\n        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)\n                                                  : lhs.urem(rhs));\n    return res;\n  }\n\n#define OP_ASSIGN_AP_2(Sym)                         \\\n  template <int _AP_W2, bool _AP_S2>                \\\n  INLINE ap_private<_AP_W, _AP_S>& operator Sym##=( \\\n      const ap_private<_AP_W2, _AP_S2>& op) {       \\\n    *this = operator Sym(op);                       \\\n    return *this;                                   \\\n  }\n\n  OP_ASSIGN_AP_2(/)\n  OP_ASSIGN_AP_2(%)\n#undef OP_ASSIGN_AP_2\n\n/// Bitwise assign: and, or, xor\n//-------------------------------------------------------------\n//    OP_ASSIGN_AP(&)\n//    OP_ASSIGN_AP(^)\n//    OP_ASSIGN_AP(|)\n\n#define OP_LEFT_SHIFT_CTYPE(TYPE, SIGNED)             \\\n  INLINE ap_private operator<<(const TYPE op) const { \\\n    if (op >= _AP_W) return ap_private(0);            \\\n    if (SIGNED && op < 0) return *this >> (0 - op);   \\\n    return shl(op);                                   \\\n  }\n\n  // OP_LEFT_SHIFT_CTYPE(bool, false)\n  OP_LEFT_SHIFT_CTYPE(char, CHAR_IS_SIGNED)\n  OP_LEFT_SHIFT_CTYPE(signed char, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned char, false)\n  OP_LEFT_SHIFT_CTYPE(short, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned short, false)\n  OP_LEFT_SHIFT_CTYPE(int, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned int, false)\n  OP_LEFT_SHIFT_CTYPE(long, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned long, false)\n  OP_LEFT_SHIFT_CTYPE(long long, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned long long, false)\n  OP_LEFT_SHIFT_CTYPE(half, false)\n  OP_LEFT_SHIFT_CTYPE(float, false)\n  OP_LEFT_SHIFT_CTYPE(double, false)\n\n#undef OP_LEFT_SHIFT_CTYPE\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {\n    if (_AP_S2 == false) {\n      uint32_t sh = op2.to_uint();\n      return *this << sh;\n    } else {\n      int sh = op2.to_int();\n      return *this << sh;\n    }\n  }\n\n#define OP_RIGHT_SHIFT_CTYPE(TYPE, SIGNED)            \\\n  INLINE ap_private operator>>(const TYPE op) const { \\\n    if (op >= _AP_W) {                                \\\n      if (isNegative())                               \\\n        return ap_private(-1);                        \\\n      else                                            \\\n        return ap_private(0);                         \\\n    }                                                 \\\n    if ((SIGNED) && op < 0) return *this << (0 - op); \\\n    if (_AP_S)                                        \\\n      return ashr(op);                                \\\n    else                                              \\\n      return lshr(op);                                \\\n  }\n\n  // OP_RIGHT_SHIFT_CTYPE(bool, false)\n  OP_RIGHT_SHIFT_CTYPE(char, CHAR_IS_SIGNED)\n  OP_RIGHT_SHIFT_CTYPE(signed char, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned char, false)\n  OP_RIGHT_SHIFT_CTYPE(short, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned short, false)\n  OP_RIGHT_SHIFT_CTYPE(int, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned int, false)\n  OP_RIGHT_SHIFT_CTYPE(long, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned long, false)\n  OP_RIGHT_SHIFT_CTYPE(unsigned long long, false)\n  OP_RIGHT_SHIFT_CTYPE(long long, true)\n  OP_RIGHT_SHIFT_CTYPE(half, false)\n  OP_RIGHT_SHIFT_CTYPE(float, false)\n  OP_RIGHT_SHIFT_CTYPE(double, false)\n\n#undef OP_RIGHT_SHIFT_CTYPE\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {\n    if (_AP_S2 == false) {\n      uint32_t sh = op2.to_uint();\n      return *this >> sh;\n    } else {\n      int sh = op2.to_int();\n      return *this >> sh;\n    }\n  }\n\n  /// Shift assign\n  //-----------------------------------------------------------------\n\n  //INLINE const ap_private& operator<<=(uint32_t shiftAmt) {\n  //  VAL <<= shiftAmt;\n  //  clearUnusedBits();\n  //  return *this;\n  //}\n\n#define OP_ASSIGN_AP(Sym)                                                    \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_private& operator Sym##=(int op) {                               \\\n    *this = operator Sym(op);                                                \\\n    clearUnusedBits();                                                       \\\n    return *this;                                                            \\\n  }                                                                          \\\n  INLINE ap_private& operator Sym##=(unsigned int op) {                      \\\n    *this = operator Sym(op);                                                \\\n    clearUnusedBits();                                                       \\\n    return *this;                                                            \\\n  }                                                                          \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_private& operator Sym##=(const ap_private<_AP_W2, _AP_S2>& op) { \\\n    *this = operator Sym(op);                                                \\\n    clearUnusedBits();                                                       \\\n    return *this;                                                            \\\n  }\n\n  OP_ASSIGN_AP(>>)\n  OP_ASSIGN_AP(<<)\n#undef OP_ASSIGN_AP\n\n  /// Comparisons\n  //-----------------------------------------------------------------\n  template <int _AP_W1, bool _AP_S1>\n  INLINE bool operator==(const ap_private<_AP_W1, _AP_S1>& op) const {\n    enum { _AP_MAX_W = AP_MAX(AP_MAX(_AP_W, _AP_W1), 32) };\n    ap_private<_AP_MAX_W, false> lhs(*this);\n    ap_private<_AP_MAX_W, false> rhs(op);\n    if (_AP_MAX_W <= 64) {\n      return (uint64_t)lhs.get_VAL() == (uint64_t)rhs.get_VAL();\n    } else\n      return lhs == rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this == op);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {\n    enum {\n      _AP_MAX_W = AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2))\n    };\n    ap_private<_AP_MAX_W, _AP_S> lhs(*this);\n    ap_private<_AP_MAX_W, _AP_S2> rhs(op);\n    // this will follow gcc rule for comparison\n    // between different bitwidth and signness\n    if (_AP_S == _AP_S2)\n      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);\n    else if (_AP_W < 32 && _AP_W2 < 32)\n      // different signness but both bitwidth is less than 32\n      return lhs.sgt(rhs);\n    else\n        // different signness but bigger bitwidth\n        // is greater or equal to 32\n        if (_AP_S)\n      if (_AP_W2 >= _AP_W)\n        return lhs.ugt(rhs);\n      else\n        return lhs.sgt(rhs);\n    else if (_AP_W >= _AP_W2)\n      return lhs.ugt(rhs);\n    else\n      return lhs.sgt(rhs);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this > op);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {\n    enum {\n      _AP_MAX_W = AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2))\n    };\n    ap_private<_AP_MAX_W, _AP_S> lhs(*this);\n    ap_private<_AP_MAX_W, _AP_S2> rhs(op);\n    if (_AP_S == _AP_S2)\n      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);\n    else if (_AP_W < 32 && _AP_W2 < 32)\n      return lhs.slt(rhs);\n    else if (_AP_S)\n      if (_AP_W2 >= _AP_W)\n        return lhs.ult(rhs);\n      else\n        return lhs.slt(rhs);\n    else if (_AP_W >= _AP_W2)\n      return lhs.ult(rhs);\n    else\n      return lhs.slt(rhs);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this < op);\n  }\n\n  /// Bit and Part Select\n  //--------------------------------------------------------------\n  // FIXME now _private_range_ref refs to _AP_ROOT_TYPE(struct ssdm_int).\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {\n    return _private_range_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {\n    return _private_range_ref<_AP_W, _AP_S>(\n        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  INLINE _private_bit_ref<_AP_W, _AP_S> operator[](int index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_bit_ref<_AP_W, _AP_S> operator[](\n      const ap_private<_AP_W2, _AP_S2>& index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());\n  }\n\n  INLINE const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE const _private_bit_ref<_AP_W, _AP_S> operator[](\n      const ap_private<_AP_W2, _AP_S2>& index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());\n  }\n\n  INLINE _private_bit_ref<_AP_W, _AP_S> bit(int index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());\n  }\n\n  INLINE const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE const _private_bit_ref<_AP_W, _AP_S> bit(\n      const ap_private<_AP_W2, _AP_S2>& index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());\n  }\n\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       ap_private<_AP_W2, _AP_S2> >\n//  concat(const ap_private<_AP_W2, _AP_S2>& a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       ap_private<_AP_W2, _AP_S2> >\n//  concat(ap_private<_AP_W2, _AP_S2>& a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(const ap_private<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(const ap_private<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        *this, const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this), a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       _private_range_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_range_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         _private_range_ref<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_range_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       _private_range_ref<_AP_W2, _AP_S2> >\n//  operator,(_private_range_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         _private_range_ref<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                       _private_bit_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_bit_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                         _private_bit_ref<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_bit_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                       _private_bit_ref<_AP_W2, _AP_S2> >\n//  operator,(_private_bit_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                         _private_bit_ref<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,\n//                                                                         a2);\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      _AP_W, ap_private, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n//                &a2) const {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<\n//            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      _AP_W, ap_private, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,\n//                                                                       a2);\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<_AP_W, ap_private, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n//                    &a2) const {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, 1,\n//        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n//            a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<_AP_W, ap_private, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//      operator,(\n//          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, 1,\n//        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator&(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this & a2.get();\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator|(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this | a2.get();\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator^(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this ^ a2.get();\n//  }\n\n  // Reduce operation\n  //-----------------------------------------------------------\n  INLINE bool and_reduce() const { return (VAL & mask) == mask; }\n\n  INLINE bool nand_reduce() const { return (VAL & mask) != mask; }\n\n  INLINE bool or_reduce() const { return (bool)VAL; }\n\n  INLINE bool nor_reduce() const { return VAL == 0; }\n\n  INLINE bool xor_reduce() const {\n    unsigned int i = countPopulation();\n    return (i % 2) ? true : false;\n  }\n\n  INLINE bool xnor_reduce() const {\n    unsigned int i = countPopulation();\n    return (i % 2) ? false : true;\n  }\n\n  INLINE std::string to_string(uint8_t radix = 2, bool sign = false) const {\n    return toString(radix, radix == 10 ? _AP_S : sign);\n  }\n}; // End of class ap_private <_AP_W, _AP_S, true>\n\ntemplate <int _AP_W, bool _AP_S>\nstd::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix,\n                                                     bool wantSigned) const {\n  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2) &&\n         \"Radix should be 2, 8, 10, or 16!\");\n  static const char* digits[] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n                                 \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n  std::string result;\n  if (radix != 10) {\n    // For the 2, 8 and 16 bit cases, we can just shift instead of divide\n    // because the number of bits per digit (1,3 and 4 respectively) divides\n    // equaly. We just shift until there value is zero.\n\n    // First, check for a zero value and just short circuit the logic below.\n    if (*this == (uint64_t)(0)) {\n      // Always generate a radix indicator because fixed-point\n      // formats require it.\n      switch (radix) {\n        case 2:\n          result = \"0b0\";\n          break;\n        case 8:\n          result = \"0o0\";\n          break;\n        case 16:\n          result = \"0x0\";\n          break;\n        default:\n          assert(\"invalid radix\" && 0);\n      }\n    } else {\n      ap_private<_AP_W, false, true> tmp(*this);\n      size_t insert_at = 0;\n      bool leading_zero = true;\n      if (wantSigned && isNegative()) {\n        // They want to print the signed version and it is a negative value\n        // Flip the bits and add one to turn it into the equivalent positive\n        // value and put a '-' in the result.\n        tmp.flip();\n        tmp++;\n        result = \"-\";\n        insert_at = 1;\n        leading_zero = false;\n      }\n      switch (radix) {\n        case 2:\n          result += \"0b\";\n          break;\n        case 8:\n          result += \"0o\";\n          break;\n        case 16:\n          result += \"0x\";\n          break;\n        default:\n          assert(\"invalid radix\" && 0);\n      }\n      insert_at += 2;\n\n      // Just shift tmp right for each digit width until it becomes zero\n      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));\n      uint64_t mask = radix - 1;\n      ap_private<_AP_W, false, true> zero(0);\n      unsigned bits = 0;\n      bool msb = false;\n      while (tmp.ne(zero)) {\n        unsigned digit = (unsigned)(tmp.get_VAL() & mask);\n        result.insert(insert_at, digits[digit]);\n        tmp = tmp.lshr(shift);\n        bits++;\n        msb = (digit >> (shift - 1)) == 1;\n      }\n      bits *= shift;\n      if (bits < _AP_W && leading_zero && msb)\n        result.insert(insert_at, digits[0]);\n    }\n    return result;\n  }\n\n  ap_private<_AP_W, false, true> tmp(*this);\n  ap_private<6, false, true> divisor(radix);\n  ap_private<_AP_W, _AP_S, true> zero(0);\n  size_t insert_at = 0;\n  if (wantSigned && isNegative()) {\n    // They want to print the signed version and it is a negative value\n    // Flip the bits and add one to turn it into the equivalent positive\n    // value and put a '-' in the result.\n    tmp.flip();\n    tmp++;\n    result = \"-\";\n    insert_at = 1;\n  }\n  if (tmp == ap_private<_AP_W, false, true>(0ULL))\n    result = \"0\";\n  else\n    while (tmp.ne(zero)) {\n      ap_private<_AP_W, false, true> APdigit = tmp % divisor;\n      ap_private<_AP_W, false, true> tmp2 = tmp / divisor;\n      uint32_t digit = (uint32_t)(APdigit.getZExtValue());\n      assert(digit < radix && \"divide failed\");\n      result.insert(insert_at, digits[digit]);\n      tmp = tmp2;\n    }\n  return result;\n\n} // End of ap_private<_AP_W, _AP_S, true>::toString()\n\n// bitwidth > 64\ntemplate <int _AP_W, bool _AP_S>\nclass ap_private<_AP_W, _AP_S, false> {\n  // SFINAE pattern.  Only consider this class when _AP_W > 64\n  const static bool valid = ap_private_enable_if<(_AP_W > 64)>::isValid;\n\n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n public:\n  enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };\n  static const int width = _AP_W;\n\n private:\n  /// This constructor is used only internally for speed of construction of\n  /// temporaries. It is unsafe for general use so it is not public.\n\n  /* Constructors */\n  /// Note that numWords can be smaller or larger than the corresponding bit\n  /// width but any extraneous bits will be dropped.\n  /// @param numWords the number of words in bigVal\n  /// @param bigVal a sequence of words to form the initial value of the\n  /// ap_private\n  /// @brief Construct an ap_private, initialized as bigVal[].\n  INLINE ap_private(uint32_t numWords, const uint64_t bigVal[]) {\n    set_canary();\n    assert(bigVal && \"Null pointer detected!\");\n    {\n      // Get memory, cleared to 0\n      memset(pVal, 0, _AP_N * sizeof(uint64_t));\n\n      // Calculate the number of words to copy\n      uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);\n      // Copy the words from bigVal to pVal\n      memcpy(pVal, bigVal, words * APINT_WORD_SIZE);\n      if (words >= _AP_W) clearUnusedBits();\n      // Make sure unused high bits are cleared\n    }\n    check_canary();\n  }\n\n  /// This constructor interprets Val as a string in the given radix. The\n  /// interpretation stops when the first charater that is not suitable for the\n  /// radix is encountered. Acceptable radix values are 2, 8, 10 and 16. It is\n  /// an error for the value implied by the string to require more bits than\n  /// numBits.\n  /// @param val the string to be interpreted\n  /// @param radix the radix of Val to use for the intepretation\n  /// @brief Construct an ap_private from a string representation.\n  INLINE ap_private(const std::string& val, uint8_t radix = 2) {\n    set_canary();\n    assert(!val.empty() && \"The input string is empty.\");\n    const char* c_str = val.c_str();\n    fromString(c_str, val.size(), radix);\n    check_canary();\n  }\n\n  /// This constructor interprets the slen characters starting at StrStart as\n  /// a string in the given radix. The interpretation stops when the first\n  /// character that is not suitable for the radix is encountered. Acceptable\n  /// radix values are 2, 8, 10 and 16. It is an error for the value implied by\n  /// the string to require more bits than numBits.\n  /// @param strStart the start of the string to be interpreted\n  /// @param slen the maximum number of characters to interpret\n  /// @param radix the radix to use for the conversion\n  /// @brief Construct an ap_private from a string representation.\n  /// This method does not consider whether it is negative or not.\n  INLINE ap_private(const char strStart[], uint32_t slen, uint8_t radix) {\n    set_canary();\n    fromString(strStart, slen, radix);\n    check_canary();\n  }\n\n  INLINE void report() {\n    _AP_ERROR(_AP_W > MAX_MODE(AP_INT_MAX_W) * 1024,\n              \"ap_%sint<%d>: Bitwidth exceeds the \"\n              \"default max value %d. Please use macro \"\n              \"AP_INT_MAX_W to set a larger max value.\",\n              _AP_S ? \"\" : \"u\", _AP_W, MAX_MODE(AP_INT_MAX_W) * 1024);\n  }\n  /// This union is used to store the integer value. When the\n  /// integer bit-width <= 64, it uses VAL, otherwise it uses pVal.\n\n  /// This enum is used to hold the constants we needed for ap_private.\n  // uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n  uint64_t pVal[_AP_N];  ///< Used to store the >64 bits integer value.\n\n#ifdef AP_CANARY\n  uint64_t CANARY;\n  INLINE void check_canary() { assert(CANARY == (uint64_t)0xDEADBEEFDEADBEEF); }\n  INLINE void set_canary() { CANARY = (uint64_t)0xDEADBEEFDEADBEEF; }\n#else\n  INLINE void check_canary() {}\n  INLINE void set_canary() {}\n#endif\n\n public:\n  typedef typename valtype<8, _AP_S>::Type ValType;\n  typedef ap_private<_AP_W, _AP_S> Type;\n  // FIXME remove friend type?\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  friend struct ap_fixed_base;\n  /// return type of variety of operations\n  //----------------------------------------------------------\n  template <int _AP_W2, bool _AP_S2>\n  struct RType {\n    enum {\n      mult_w = _AP_W + _AP_W2,\n      mult_s = _AP_S || _AP_S2,\n      plus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      plus_s = _AP_S || _AP_S2,\n      minus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      minus_s = true,\n      div_w = _AP_W + _AP_S2,\n      div_s = _AP_S || _AP_S2,\n      mod_w = AP_MIN(_AP_W, _AP_W2 + (!_AP_S2 && _AP_S)),\n      mod_s = _AP_S,\n      logic_w = AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)),\n      logic_s = _AP_S || _AP_S2\n    };\n    typedef ap_private<mult_w, mult_s> mult;\n    typedef ap_private<plus_w, plus_s> plus;\n    typedef ap_private<minus_w, minus_s> minus;\n    typedef ap_private<logic_w, logic_s> logic;\n    typedef ap_private<div_w, div_s> div;\n    typedef ap_private<mod_w, mod_s> mod;\n    typedef ap_private<_AP_W, _AP_S> arg1;\n    typedef bool reduce;\n  };\n\n  INLINE uint64_t& get_VAL(void) { return pVal[0]; }\n  INLINE uint64_t get_VAL(void) const { return pVal[0]; }\n  INLINE uint64_t get_VAL(void) const volatile { return pVal[0]; }\n  INLINE void set_VAL(uint64_t value) { pVal[0] = value; }\n  INLINE uint64_t& get_pVal(int index) { return pVal[index]; }\n  INLINE uint64_t* get_pVal() { return pVal; }\n  INLINE const uint64_t* get_pVal() const { return pVal; }\n  INLINE uint64_t get_pVal(int index) const { return pVal[index]; }\n  INLINE uint64_t* get_pVal() const volatile { return pVal; }\n  INLINE uint64_t get_pVal(int index) const volatile { return pVal[index]; }\n  INLINE void set_pVal(int i, uint64_t value) { pVal[i] = value; }\n\n  /// This enum is used to hold the constants we needed for ap_private.\n  enum {\n    APINT_BITS_PER_WORD = sizeof(uint64_t) * 8, ///< Bits in a word\n    APINT_WORD_SIZE = sizeof(uint64_t)          ///< Byte size of a word\n  };\n\n  enum {\n    excess_bits = (_AP_W % APINT_BITS_PER_WORD)\n                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)\n                      : 0\n  };\n  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));\n\n public:\n  // NOTE changed to explicit to be consistent with ap_private<W,S,true>\n  explicit INLINE ap_private(const char* val) {\n    set_canary();\n    unsigned char radix = 10;\n    std::string str = ap_private_ops::parseString(val, radix); // determine radix.\n    std::string::size_type pos = str.find('.');\n    if (pos != std::string::npos) str = str.substr(pos);\n    ap_private ap_private_val(str, radix);\n    operator=(ap_private_val);\n    report();\n    check_canary();\n  }\n\n  INLINE ap_private(const char* val, unsigned char rd) {\n    set_canary();\n    unsigned char radix = rd;\n    std::string str = ap_private_ops::parseString(val, radix); // determine radix.\n    std::string::size_type pos = str.find('.');\n    if (pos != std::string::npos) str = str.substr(pos);\n    ap_private ap_private_val(str, radix);\n    operator=(ap_private_val);\n    report();\n\n    report();\n    check_canary();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {\n    set_canary();\n    *this = ref.get();\n    report();\n    check_canary();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {\n    set_canary();\n    *this = ((uint64_t)(bool)ref);\n    report();\n    check_canary();\n  }\n\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {\n//    set_canary();\n//    *this = ref.get();\n//    report();\n//    check_canary();\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_private(\n//      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n//    set_canary();\n//    *this = ((val.operator ap_private<_AP_W2, false>()));\n//    report();\n//    check_canary();\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_private(\n//      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n//    set_canary();\n//    *this = (uint64_t)(bool)val;\n//    report();\n//    check_canary();\n//  }\n\n  /// Simply makes *this a copy of that.\n  /// @brief Copy Constructor.\n  INLINE ap_private(const ap_private& that) {\n      set_canary();\n      memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);\n      clearUnusedBits();\n      check_canary();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private(const ap_private<_AP_W1, _AP_S1, false>& that) {\n    set_canary();\n    operator=(that);\n    check_canary();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private(const volatile ap_private<_AP_W1, _AP_S1, false>& that) {\n    set_canary();\n    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, false>&>(that));\n    check_canary();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {\n    set_canary();\n    static const uint64_t that_sign_ext_mask =\n        (_AP_W1 == APINT_BITS_PER_WORD)\n            ? 0\n            : ~0ULL >> (_AP_W1 % APINT_BITS_PER_WORD)\n                           << (_AP_W1 % APINT_BITS_PER_WORD);\n    if (that.isNegative()) {\n      pVal[0] = that.get_VAL() | that_sign_ext_mask;\n      memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1));\n    } else {\n      pVal[0] = that.get_VAL();\n      memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1));\n    }\n    clearUnusedBits();\n    check_canary();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private(const volatile ap_private<_AP_W1, _AP_S1, true>& that) {\n    set_canary();\n    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, true>&>(that));\n    check_canary();\n  }\n\n  /// @brief Destructor.\n  // virtual ~ap_private() {}\n  INLINE ~ap_private() { check_canary(); }\n\n  /// @name Constructors\n  /// @{\n\n  /// Default constructor that creates an uninitialized ap_private.  This is\n  /// useful\n  ///  for object deserialization (pair this with the static method Read).\n  INLINE ap_private() {\n    set_canary();\n    clearUnusedBits();\n    check_canary();\n  }\n\n  INLINE ap_private(uint64_t* val, uint32_t bits = _AP_W) { assert(0); }\n  INLINE ap_private(const uint64_t* const val, uint32_t bits) { assert(0); }\n\n/// If isSigned is true then val is treated as if it were a signed value\n/// (i.e. as an int64_t) and the appropriate sign extension to the bit width\n/// will be done. Otherwise, no sign extension occurs (high order bits beyond\n/// the range of val are zero filled).\n/// @param numBits the bit width of the constructed ap_private\n/// @param val the initial value of the ap_private\n/// @param isSigned how to treat signedness of val\n/// @brief Create a new ap_private of numBits width, initialized as val.\n#define CTOR(TYPE, SIGNED)                                  \\\n  INLINE ap_private(TYPE val, bool isSigned = SIGNED) {     \\\n    set_canary();                                           \\\n    pVal[0] = (ValType)val;                                 \\\n    if (isSigned && int64_t(pVal[0]) < 0) {                 \\\n      memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); \\\n    } else {                                                \\\n      memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1));  \\\n    }                                                       \\\n    clearUnusedBits();                                      \\\n    check_canary();                                         \\\n  }\n\n  CTOR(bool, false)\n  CTOR(char, CHAR_IS_SIGNED)\n  CTOR(signed char, true)\n  CTOR(unsigned char, false)\n  CTOR(short, true)\n  CTOR(unsigned short, false)\n  CTOR(int, true)\n  CTOR(unsigned int, false)\n  CTOR(long, true)\n  CTOR(unsigned long, false)\n  CTOR(ap_slong, true)\n  CTOR(ap_ulong, false)\n  CTOR(half, false)\n  CTOR(float, false)\n  CTOR(double, false)\n#undef CTOR\n\n  /// @returns true if the number of bits <= 64, false otherwise.\n  /// @brief Determine if this ap_private just has one word to store value.\n  INLINE bool isSingleWord() const { return false; }\n\n  /// @returns the word position for the specified bit position.\n  /// @brief Determine which word a bit is in.\n  static INLINE uint32_t whichWord(uint32_t bitPosition) {\n    //    return bitPosition / APINT_BITS_PER_WORD;\n    return (bitPosition) >> 6;\n  }\n\n  /// @returns the bit position in a word for the specified bit position\n  /// in the ap_private.\n  /// @brief Determine which bit in a word a bit is in.\n  static INLINE uint32_t whichBit(uint32_t bitPosition) {\n    //    return bitPosition % APINT_BITS_PER_WORD;\n    return bitPosition & 0x3f;\n  }\n\n  /// bit at a specific bit position. This is used to mask the bit in the\n  /// corresponding word.\n  /// @returns a uint64_t with only bit at \"whichBit(bitPosition)\" set\n  /// @brief Get a single bit mask.\n  static INLINE uint64_t maskBit(uint32_t bitPosition) {\n    return 1ULL << (whichBit(bitPosition));\n  }\n\n  /// @returns the corresponding word for the specified bit position.\n  /// @brief Get the word corresponding to a bit position\n  INLINE uint64_t getWord(uint32_t bitPosition) const {\n    return pVal[whichWord(bitPosition)];\n  }\n\n  /// This method is used internally to clear the to \"N\" bits in the high order\n  /// word that are not used by the ap_private. This is needed after the most\n  /// significant word is assigned a value to ensure that those bits are\n  /// zero'd out.\n  /// @brief Clear unused high order bits\n  INLINE void clearUnusedBits(void) volatile\n// just for clang compiler\n#if defined(__clang__) && !defined(__CLANG_3_1__)\n      __attribute__((no_sanitize(\"undefined\")))\n#endif\n  {\n    pVal[_AP_N - 1] =\n        _AP_S ? ((((int64_t)pVal[_AP_N - 1]) << (excess_bits)) >> excess_bits)\n              : (excess_bits\n                     ? ((pVal[_AP_N - 1]) << (excess_bits)) >> (excess_bits)\n                     : pVal[_AP_N - 1]);\n  }\n\n  INLINE void clearUnusedBitsToZero(void) { pVal[_AP_N - 1] &= mask; }\n\n  INLINE void clearUnusedBitsToOne(void) { pVal[_AP_N - 1] |= mask; }\n\n  /// This is used by the constructors that take string arguments.\n  /// @brief Convert a char array into an ap_private\n  INLINE void fromString(const char* str, uint32_t slen, uint8_t radix) {\n    enum { numbits = _AP_W };\n    bool isNeg = str[0] == '-';\n    if (isNeg) {\n      str++;\n      slen--;\n    }\n\n    if (str[0] == '0' && (str[1] == 'b' || str[1] == 'B')) {\n      //if(radix == 0) radix = 2;\n      _AP_WARNING(radix != 2, \"%s seems to have base %d, but %d given.\", str, 2, radix);\n      str += 2;\n      slen -=2;\n    } else if (str[0] == '0' && (str[1] == 'o' || str[1] == 'O')) {\n      //if (radix == 0) radix = 8;\n      _AP_WARNING(radix != 8, \"%s seems to have base %d, but %d given.\", str, 8, radix);\n      str += 2;\n      slen -=2;\n    } else if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {\n      //if (radix == 0) radix = 16;\n      _AP_WARNING(radix != 16, \"%s seems to have base %d, but %d given.\", str, 16, radix);\n      str += 2;\n      slen -=2;\n    } else if (str[0] == '0' && (str[1] == 'd' || str[1] == 'D')) {\n      //if (radix == 0) radix = 10;\n      _AP_WARNING(radix != 10, \"%s seems to have base %d, but %d given.\", str, 10, radix);\n      str += 2;\n      slen -=2;\n    } else if (radix == 0) {\n      //radix = 2; // XXX default value\n    }\n\n    // Check our assumptions here\n    assert((radix == 10 || radix == 8 || radix == 16 || radix == 2) &&\n           \"Radix should be 2, 8, 10, or 16!\");\n    assert(str && \"String is null?\");\n\n    // skip any leading zero\n    while (*str == '0' && *(str + 1) != '\\0') {\n      str++;\n      slen--;\n    }\n    assert((slen <= numbits || radix != 2) && \"Insufficient bit width\");\n    assert(((slen - 1) * 3 <= numbits || radix != 8) &&\n           \"Insufficient bit width\");\n    assert(((slen - 1) * 4 <= numbits || radix != 16) &&\n           \"Insufficient bit width\");\n    assert((((slen - 1) * 64) / 22 <= numbits || radix != 10) &&\n           \"Insufficient bit width\");\n\n    // clear bits\n    memset(pVal, 0, _AP_N * sizeof(uint64_t));\n\n    // Figure out if we can shift instead of multiply\n    uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);\n\n    // Set up an ap_private for the digit to add outside the loop so we don't\n    // constantly construct/destruct it.\n    uint64_t bigVal[_AP_N];\n    memset(bigVal, 0, _AP_N * sizeof(uint64_t));\n    ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);\n    ap_private<_AP_W, _AP_S> apradix(radix);\n\n    // Enter digit traversal loop\n    for (unsigned i = 0; i < slen; i++) {\n      // Get a digit\n      uint32_t digit = 0;\n      char cdigit = str[i];\n      if (radix == 16) {\n#define isxdigit(c)                                            \\\n  (((c) >= '0' && (c) <= '9') || ((c) >= 'a' && (c) <= 'f') || \\\n   ((c) >= 'A' && (c) <= 'F'))\n#define isdigit(c) ((c) >= '0' && (c) <= '9')\n        if (!isxdigit(cdigit)) assert(0 && \"Invalid hex digit in string\");\n        if (isdigit(cdigit))\n          digit = cdigit - '0';\n        else if (cdigit >= 'a')\n          digit = cdigit - 'a' + 10;\n        else if (cdigit >= 'A')\n          digit = cdigit - 'A' + 10;\n        else\n          assert(0 && \"huh? we shouldn't get here\");\n      } else if (isdigit(cdigit)) {\n        digit = cdigit - '0';\n      } else if (cdigit != '\\0') {\n        assert(0 && \"Invalid character in digit string\");\n      }\n#undef isxdigit\n#undef isdigit\n      // Shift or multiply the value by the radix\n      if (shift)\n        *this <<= shift;\n      else\n        *this *= apradix;\n\n      // Add in the digit we just interpreted\n      apdigit.set_VAL(digit);\n      *this += apdigit;\n    }\n    // If its negative, put it in two's complement form\n    if (isNeg) {\n      (*this)--;\n      this->flip();\n    }\n    clearUnusedBits();\n  }\n\n  INLINE ap_private read() volatile { return *this; }\n\n  INLINE void write(const ap_private& op2) volatile { *this = (op2); }\n\n  INLINE operator ValType() const { return get_VAL(); }\n\n  INLINE int to_uchar() const { return (unsigned char)get_VAL(); }\n\n  INLINE int to_char() const { return (signed char)get_VAL(); }\n\n  INLINE int to_ushort() const { return (unsigned short)get_VAL(); }\n\n  INLINE int to_short() const { return (short)get_VAL(); }\n\n  INLINE int to_int() const { return (int)get_VAL(); }\n\n  INLINE unsigned to_uint() const { return (unsigned)get_VAL(); }\n\n  INLINE long to_long() const { return (long)get_VAL(); }\n\n  INLINE unsigned long to_ulong() const { return (unsigned long)get_VAL(); }\n\n  INLINE ap_slong to_int64() const { return (ap_slong)get_VAL(); }\n\n  INLINE ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }\n\n  INLINE double to_double() const {\n    if (isNegative())\n      return roundToDouble(true);\n    else\n      return roundToDouble(false);\n  }\n\n  INLINE unsigned length() const { return _AP_W; }\n\n  /*Reverse the contents of ap_private instance. I.e. LSB becomes MSB and vise\n   * versa*/\n  INLINE ap_private& reverse() {\n    for (int i = 0; i < _AP_W / 2; ++i) {\n      bool tmp = operator[](i);\n      if (operator[](_AP_W - 1 - i))\n        set(i);\n      else\n        clear(i);\n      if (tmp)\n        set(_AP_W - 1 - i);\n      else\n        clear(_AP_W - 1 - i);\n    }\n    clearUnusedBits();\n    return *this;\n  }\n\n  /*Return true if the value of ap_private instance is zero*/\n  INLINE bool iszero() const { return isMinValue(); }\n\n  INLINE bool to_bool() const { return !iszero(); }\n\n  /* x < 0 */\n  INLINE bool sign() const {\n    if (isNegative()) return true;\n    return false;\n  }\n\n  /* x[i] = !x[i] */\n  INLINE void invert(int i) {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    flip(i);\n  }\n\n  /* x[i] */\n  INLINE bool test(int i) const {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    return operator[](i);\n  }\n\n  // Set the ith bit into v\n  INLINE void set(int i, bool v) {\n    assert(i >= 0 && \"Attempting to write bit with negative index\");\n    assert(i < _AP_W && \"Attempting to write bit beyond MSB\");\n    v ? set(i) : clear(i);\n  }\n\n  // Set the ith bit into v\n  INLINE void set_bit(int i, bool v) {\n    assert(i >= 0 && \"Attempting to write bit with negative index\");\n    assert(i < _AP_W && \"Attempting to write bit beyond MSB\");\n    v ? set(i) : clear(i);\n  }\n\n  // FIXME different argument for different action?\n  INLINE ap_private& set(uint32_t bitPosition) {\n    pVal[whichWord(bitPosition)] |= maskBit(bitPosition);\n    clearUnusedBits();\n    return *this;\n  }\n\n  INLINE void set() {\n    for (int i = 0; i < _AP_N; ++i) pVal[i] = ~0ULL;\n    clearUnusedBits();\n  }\n\n  // Get the value of ith bit\n  INLINE bool get(int i) const {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);\n  }\n\n  // Get the value of ith bit\n  INLINE bool get_bit(int i) const {\n    assert(i >= 0 && \"Attempting to read bit with negative index\");\n    assert(i < _AP_W && \"Attempting to read bit beyond MSB\");\n    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_private object n places to the left\n  INLINE void lrotate(int n) {\n    assert(n >= 0 && \"Attempting to shift negative index\");\n    assert(n < _AP_W && \"Shift value larger than bit width\");\n    operator=(shl(n) | lshr(_AP_W - n));\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_private object n places to the right\n  INLINE void rrotate(int n) {\n    assert(n >= 0 && \"Attempting to shift negative index\");\n    assert(n < _AP_W && \"Shift value larger than bit width\");\n    operator=(lshr(n) | shl(_AP_W - n));\n  }\n\n  /// Set the given bit to 0 whose position is given as \"bitPosition\".\n  /// @brief Set a given bit to 0.\n  INLINE ap_private& clear(uint32_t bitPosition) {\n    pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// @brief Set every bit to 0.\n  INLINE void clear() { memset(pVal, 0, _AP_N * APINT_WORD_SIZE); }\n\n  /// @brief Toggle every bit to its opposite value.\n  ap_private& flip() {\n    for (int i = 0; i < _AP_N; ++i) pVal[i] ^= ~0ULL;\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// @brief Toggles a given bit to its opposite value.\n  INLINE ap_private& flip(uint32_t bitPosition) {\n    assert(bitPosition < BitWidth && \"Out of the bit-width range!\");\n    set_bit(bitPosition, !get_bit(bitPosition));\n    return *this;\n  }\n\n  // complements every bit\n  INLINE void b_not() { flip(); }\n\n  INLINE ap_private getLoBits(uint32_t numBits) const {\n    return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),\n                                _AP_W - numBits);\n  }\n\n  INLINE ap_private getHiBits(uint32_t numBits) const {\n    return ap_private_ops::lshr(*this, _AP_W - numBits);\n  }\n\n  // Binary Arithmetic\n  //-----------------------------------------------------------\n\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator&(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this & a2.get();\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator|(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this | a2.get();\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_private<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator^(\n//      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n//    return *this ^ a2.get();\n//  }\n\n/// Arithmetic assign\n//-------------------------------------------------------------\n\n#define OP_BIN_LOGIC_ASSIGN_AP(Sym)                                            \\\n  template <int _AP_W1, bool _AP_S1>                                           \\\n  INLINE ap_private& operator Sym(const ap_private<_AP_W1, _AP_S1>& RHS) {     \\\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;                      \\\n    uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1);                     \\\n    uint32_t i;                                                                \\\n    if (_AP_W != _AP_W1)                                                       \\\n      fprintf(stderr,                                                          \\\n              \"Warning! Bitsize mismach for ap_[u]int \" #Sym \" ap_[u]int.\\n\"); \\\n    for (i = 0; i < numWords; ++i) pVal[i] Sym RHS.get_pVal(i);                \\\n    if (_AP_N1 < _AP_N) {                                                      \\\n      uint64_t ext = RHS.isNegative() ? ~0ULL : 0;                             \\\n      for (; i < _AP_N; i++) pVal[i] Sym ext;                                  \\\n    }                                                                          \\\n    clearUnusedBits();                                                         \\\n    return *this;                                                              \\\n  }\n\n  OP_BIN_LOGIC_ASSIGN_AP(&=);\n  OP_BIN_LOGIC_ASSIGN_AP(|=);\n  OP_BIN_LOGIC_ASSIGN_AP(^=);\n#undef OP_BIN_LOGIC_ASSIGN_AP\n\n  /// Adds the RHS APint to this ap_private.\n  /// @returns this, after addition of RHS.\n  /// @brief Addition assignment operator.\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;\n    uint64_t RHSpVal[_AP_N1];\n    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);\n    ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,\n                        _AP_S1);\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;\n    uint64_t RHSpVal[_AP_N1];\n    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);\n    ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,\n                        _AP_S1);\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    // Get some bit facts about LHS and check for zero\n    uint32_t lhsBits = getActiveBits();\n    uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;\n    if (!lhsWords) {\n      // 0 * X ===> 0\n      return *this;\n    }\n\n    ap_private dupRHS = RHS;\n    // Get some bit facts about RHS and check for zero\n    uint32_t rhsBits = dupRHS.getActiveBits();\n    uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;\n    if (!rhsWords) {\n      // X * 0 ===> 0\n      clear();\n      return *this;\n    }\n\n    // Allocate space for the result\n    uint32_t destWords = rhsWords + lhsWords;\n    uint64_t* dest = (uint64_t*)malloc(destWords * sizeof(uint64_t));\n\n    // Perform the long multiply\n    ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords,\n                        destWords);\n\n    // Copy result back into *this\n    clear();\n    uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;\n\n    memcpy(pVal, dest, wordsToCopy * APINT_WORD_SIZE);\n\n    uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;\n    for (int i = wordsToCopy; i < _AP_N; i++) pVal[i] = ext;\n    clearUnusedBits();\n    // delete dest array and return\n    free(dest);\n    return *this;\n  }\n\n#define OP_ASSIGN_AP(Sym)                                                    \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_private& operator Sym##=(const ap_private<_AP_W2, _AP_S2>& op) { \\\n    *this = operator Sym(op);                                                \\\n    return *this;                                                            \\\n  }\n\n  OP_ASSIGN_AP(/)\n  OP_ASSIGN_AP(%)\n#undef OP_ASSIGN_AP\n\n#define OP_BIN_LOGIC_AP(Sym)                                                  \\\n  template <int _AP_W1, bool _AP_S1>                                          \\\n  INLINE typename RType<_AP_W1, _AP_S1>::logic operator Sym(                  \\\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {                          \\\n    enum {                                                                    \\\n      numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / \\\n                 APINT_BITS_PER_WORD                                          \\\n    };                                                                        \\\n    typename RType<_AP_W1, _AP_S1>::logic Result;                             \\\n    uint32_t i;                                                               \\\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;                     \\\n    uint32_t min_N = std::min((int)_AP_N, _AP_N1);                            \\\n    uint32_t max_N = std::max((int)_AP_N, _AP_N1);                            \\\n    for (i = 0; i < min_N; ++i)                                               \\\n      Result.set_pVal(i, pVal[i] Sym RHS.get_pVal(i));                        \\\n    if (numWords > i) {                                                       \\\n      uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) ||                     \\\n                      (_AP_N1 < _AP_N && RHS.isNegative()))                   \\\n                         ? ~0ULL                                              \\\n                         : 0;                                                 \\\n      if (_AP_N > _AP_N1)                                                     \\\n        for (; i < max_N; i++) Result.set_pVal(i, pVal[i] Sym ext);           \\\n      else                                                                    \\\n        for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) Sym ext);   \\\n      if (numWords > i) {                                                     \\\n        uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) ||                  \\\n                         (_AP_N1 > _AP_N && RHS.isNegative()))                \\\n                            ? ~0ULL                                           \\\n                            : 0;                                              \\\n        Result.set_pVal(i, ext Sym ext2);                                     \\\n      }                                                                       \\\n    }                                                                         \\\n    Result.clearUnusedBits();                                                 \\\n    return Result;                                                            \\\n  }\n\n  OP_BIN_LOGIC_AP(|);\n  OP_BIN_LOGIC_AP(&);\n  OP_BIN_LOGIC_AP(^);\n\n#undef OP_BIN_LOGIC_AP\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::plus operator+(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    typename RType<_AP_W1, _AP_S1>::plus Result, lhs(*this), rhs(RHS);\n    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::plus_w + 63) / 64;\n    ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),\n                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);\n    Result.clearUnusedBits();\n    return Result;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::minus operator-(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    typename RType<_AP_W1, _AP_S1>::minus Result, lhs(*this), rhs(RHS);\n    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::minus_w + 63) / 64;\n    ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),\n                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);\n    Result.clearUnusedBits();\n    return Result;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE typename RType<_AP_W1, _AP_S1>::mult operator*(\n      const ap_private<_AP_W1, _AP_S1>& RHS) const {\n    typename RType<_AP_W1, _AP_S1>::mult temp = *this;\n    temp *= RHS;\n    return temp;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE typename RType<_AP_W2, _AP_S2>::div operator/(\n      const ap_private<_AP_W2, _AP_S2>& op) const {\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        lhs = *this;\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        rhs = op;\n    return typename RType<_AP_W2, _AP_S2>::div(\n        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE typename RType<_AP_W2, _AP_S2>::mod operator%(\n      const ap_private<_AP_W2, _AP_S2>& op) const {\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        lhs = *this;\n    ap_private<AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2)),\n               (_AP_W > _AP_W2 ? _AP_S\n                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>\n        rhs = op;\n    typename RType<_AP_W2, _AP_S2>::mod res =\n        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)\n                                                  : lhs.urem(rhs));\n    return res;\n  }\n\n#define OP_LEFT_SHIFT_CTYPE(TYPE, SIGNED)             \\\n  INLINE ap_private operator<<(const TYPE op) const { \\\n    if (op >= _AP_W) return ap_private(0);            \\\n    if (SIGNED && op < 0) return *this >> (0 - op);   \\\n    return shl(op);                                   \\\n  }\n\n  OP_LEFT_SHIFT_CTYPE(int, true)\n  // OP_LEFT_SHIFT_CTYPE(bool, false)\n  OP_LEFT_SHIFT_CTYPE(signed char, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned char, false)\n  OP_LEFT_SHIFT_CTYPE(short, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned short, false)\n  OP_LEFT_SHIFT_CTYPE(unsigned int, false)\n  OP_LEFT_SHIFT_CTYPE(long, true)\n  OP_LEFT_SHIFT_CTYPE(unsigned long, false)\n  OP_LEFT_SHIFT_CTYPE(unsigned long long, false)\n  OP_LEFT_SHIFT_CTYPE(long long, true)\n  OP_LEFT_SHIFT_CTYPE(half, false)\n  OP_LEFT_SHIFT_CTYPE(float, false)\n  OP_LEFT_SHIFT_CTYPE(double, false)\n#undef OP_LEFT_SHIFT_CTYPE\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {\n    if (_AP_S2 == false) {\n      uint32_t sh = op2.to_uint();\n      return *this << sh;\n    } else {\n      int sh = op2.to_int();\n      return *this << sh;\n    }\n  }\n\n#define OP_RIGHT_SHIFT_CTYPE(TYPE, SIGNED)            \\\n  INLINE ap_private operator>>(const TYPE op) const { \\\n    if (op >= _AP_W) {                                \\\n      if (isNegative())                               \\\n        return ap_private(-1);                        \\\n      else                                            \\\n        return ap_private(0);                         \\\n    }                                                 \\\n    if ((SIGNED) && op < 0) return *this << (0 - op); \\\n    if (_AP_S)                                        \\\n      return ashr(op);                                \\\n    else                                              \\\n      return lshr(op);                                \\\n  }\n\n  // OP_RIGHT_SHIFT_CTYPE(bool, false)\n  OP_RIGHT_SHIFT_CTYPE(char, CHAR_IS_SIGNED)\n  OP_RIGHT_SHIFT_CTYPE(signed char, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned char, false)\n  OP_RIGHT_SHIFT_CTYPE(short, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned short, false)\n  OP_RIGHT_SHIFT_CTYPE(int, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned int, false)\n  OP_RIGHT_SHIFT_CTYPE(long, true)\n  OP_RIGHT_SHIFT_CTYPE(unsigned long, false)\n  OP_RIGHT_SHIFT_CTYPE(unsigned long long, false)\n  OP_RIGHT_SHIFT_CTYPE(long long, true)\n  OP_RIGHT_SHIFT_CTYPE(half, false)\n  OP_RIGHT_SHIFT_CTYPE(float, false)\n  OP_RIGHT_SHIFT_CTYPE(double, false)\n#undef OP_RIGHT_SHIFT_CTYPE\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {\n    if (_AP_S2 == false) {\n      uint32_t sh = op2.to_uint();\n      return *this >> sh;\n    } else {\n      int sh = op2.to_int();\n      return *this >> sh;\n    }\n  }\n\n  /// Shift assign\n  //------------------------------------------------------------------\n  // TODO call clearUnusedBits ?\n#define OP_ASSIGN_AP(Sym)                                                    \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_private& operator Sym##=(int op) {                               \\\n    *this = operator Sym(op);                                                \\\n    return *this;                                                            \\\n  }                                                                          \\\n  INLINE ap_private& operator Sym##=(unsigned int op) {                      \\\n    *this = operator Sym(op);                                                \\\n    return *this;                                                            \\\n  }                                                                          \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_private& operator Sym##=(const ap_private<_AP_W2, _AP_S2>& op) { \\\n    *this = operator Sym(op);                                                \\\n    return *this;                                                            \\\n  }\n  OP_ASSIGN_AP(>>)\n  OP_ASSIGN_AP(<<)\n#undef OP_ASSIGN_AP\n\n  /// Comparisons\n  //-----------------------------------------------------------------\n  INLINE bool operator==(const ap_private& RHS) const {\n    // Get some facts about the number of bits used in the two operands.\n    uint32_t n1 = getActiveBits();\n    uint32_t n2 = RHS.getActiveBits();\n\n    // If the number of bits isn't the same, they aren't equal\n    if (n1 != n2) return false;\n\n    // If the number of bits fits in a word, we only need to compare the low\n    // word.\n    if (n1 <= APINT_BITS_PER_WORD) return pVal[0] == RHS.get_pVal(0);\n\n    // Otherwise, compare everything\n    for (int i = whichWord(n1 - 1); i >= 0; --i)\n      if (pVal[i] != RHS.get_pVal(i)) return false;\n    return true;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const ap_private<_AP_W2, _AP_S2>& op) const {\n    enum {\n      _AP_MAX_W = AP_MAX(_AP_W, _AP_W2),\n    };\n    ap_private<_AP_MAX_W, false> lhs(*this);\n    ap_private<_AP_MAX_W, false> rhs(op);\n    return lhs == rhs;\n  }\n\n  INLINE bool operator==(uint64_t Val) const {\n    uint32_t n = getActiveBits();\n    if (n <= APINT_BITS_PER_WORD)\n      return pVal[0] == Val;\n    else\n      return false;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this == op);\n  }\n\n  template <bool _AP_S1>\n  INLINE bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  INLINE bool operator!=(uint64_t Val) const { return !((*this) == Val); }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this > op);\n  }\n\n  INLINE bool operator<(const ap_private& op) const {\n    return _AP_S ? slt(op) : ult(op);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {\n    enum {\n      _AP_MAX_W = AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2))\n    };\n    ap_private<_AP_MAX_W, _AP_S> lhs(*this);\n    ap_private<_AP_MAX_W, _AP_S2> rhs(op);\n    if (_AP_S == _AP_S2)\n      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);\n    else if (_AP_S)\n      if (_AP_W2 >= _AP_W)\n        return lhs.ult(rhs);\n      else\n        return lhs.slt(rhs);\n    else if (_AP_W >= _AP_W2)\n      return lhs.ult(rhs);\n    else\n      return lhs.slt(rhs);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {\n    return !(*this < op);\n  }\n\n  INLINE bool operator>(const ap_private& op) const {\n    return _AP_S ? sgt(op) : ugt(op);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {\n    enum {\n      _AP_MAX_W = AP_MAX(_AP_W + (_AP_S || _AP_S2), _AP_W2 + (_AP_S || _AP_S2))\n    };\n    ap_private<_AP_MAX_W, _AP_S> lhs(*this);\n    ap_private<_AP_MAX_W, _AP_S2> rhs(op);\n    if (_AP_S == _AP_S2)\n      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);\n    else if (_AP_S)\n      if (_AP_W2 >= _AP_W)\n        return lhs.ugt(rhs);\n      else\n        return lhs.sgt(rhs);\n    else if (_AP_W >= _AP_W2)\n      return lhs.ugt(rhs);\n    else\n      return lhs.sgt(rhs);\n  }\n\n  /// Bit and Part Select\n  //--------------------------------------------------------------\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {\n    return _private_range_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {\n    return _private_range_ref<_AP_W, _AP_S>(\n        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);\n  }\n\n  INLINE _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE _private_range_ref<_AP_W, _AP_S> range(\n      const ap_private<_AP_W2, _AP_S2>& HiIdx,\n      const ap_private<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(\n      const ap_private<_AP_W2, _AP_S2>& HiIdx,\n      const ap_private<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE _private_range_ref<_AP_W, _AP_S> range(\n      const ap_private<_AP_W2, _AP_S2>& HiIdx,\n      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return _private_range_ref<_AP_W, _AP_S>(const_cast<ap_private*>(this), Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE _private_range_ref<_AP_W, _AP_S> operator()(\n      const ap_private<_AP_W2, _AP_S2>& HiIdx,\n      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  INLINE _private_bit_ref<_AP_W, _AP_S> operator[](int index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_bit_ref<_AP_W, _AP_S> operator[](\n      const ap_private<_AP_W2, _AP_S2>& index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE const _private_bit_ref<_AP_W, _AP_S> operator[](\n      const ap_private<_AP_W2, _AP_S2>& index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());\n  }\n\n  INLINE const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);\n  }\n\n  INLINE _private_bit_ref<_AP_W, _AP_S> bit(int index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {\n    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());\n  }\n\n  INLINE const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE const _private_bit_ref<_AP_W, _AP_S> bit(\n      const ap_private<_AP_W2, _AP_S2>& index) const {\n    return _private_bit_ref<_AP_W, _AP_S>(\n        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());\n  }\n\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       ap_private<_AP_W2, _AP_S2> >\n//  concat(ap_private<_AP_W2, _AP_S2>& a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       ap_private<_AP_W2, _AP_S2> >\n//  concat(const ap_private<_AP_W2, _AP_S2>& a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this), a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(const ap_private<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        *this, const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >\n//  operator,(const ap_private<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_private<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       _private_range_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_range_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         _private_range_ref<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_range_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                       _private_range_ref<_AP_W2, _AP_S2> >\n//  operator,(_private_range_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,\n//                         _private_range_ref<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                       _private_bit_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_bit_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                         _private_bit_ref<_AP_W2, _AP_S2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_bit_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                       _private_bit_ref<_AP_W2, _AP_S2> >\n//  operator,(_private_bit_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,\n//                         _private_bit_ref<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n//    return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,\n//                                                                         a2);\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      _AP_W, ap_private, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n//                &a2) const {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<\n//            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      _AP_W, ap_private, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,\n//                                                                       a2);\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<_AP_W, ap_private, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n//                    &a2) const {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, 1,\n//        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        const_cast<ap_private<_AP_W, _AP_S>&>(*this),\n//        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n//            a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<_AP_W, ap_private, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//      operator,(\n//          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n//    return ap_concat_ref<\n//        _AP_W, ap_private, 1,\n//        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);\n//  }\n\n  INLINE ap_private<_AP_W, false> get() const {\n    ap_private<_AP_W, false> ret(*this);\n    return ret;\n  }\n\n  template <int _AP_W3>\n  INLINE void set(const ap_private<_AP_W3, false>& val) {\n    operator=(ap_private<_AP_W3, _AP_S>(val));\n  }\n\n  ///\n  /// @name Value Tests\n  ///\n  /// This tests the high bit of this ap_private to determine if it is set.\n  /// @returns true if this ap_private is negative, false otherwise\n  /// @brief Determine sign of this ap_private.\n  INLINE bool isNegative() const {\n    // just for get rid of warnings\n    enum { shift = (_AP_W - APINT_BITS_PER_WORD * (_AP_N - 1) - 1) };\n    static const uint64_t mask = 1ULL << (shift);\n    return _AP_S && (pVal[_AP_N - 1] & mask);\n  }\n\n  /// This tests the high bit of the ap_private to determine if it is unset.\n  /// @brief Determine if this ap_private Value is positive (not negative).\n  INLINE bool isPositive() const { return !isNegative(); }\n\n  /// This tests if the value of this ap_private is strictly positive (> 0).\n  /// @returns true if this ap_private is Positive and not zero.\n  /// @brief Determine if this ap_private Value is strictly positive.\n  INLINE bool isStrictlyPositive() const {\n    return isPositive() && (*this) != 0;\n  }\n\n  /// This checks to see if the value has all bits of the ap_private are set or\n  /// not.\n  /// @brief Determine if all bits are set\n  INLINE bool isAllOnesValue() const { return countPopulation() == _AP_W; }\n\n  /// This checks to see if the value of this ap_private is the maximum unsigned\n  /// value for the ap_private's bit width.\n  /// @brief Determine if this is the largest unsigned value.\n  INLINE bool isMaxValue() const { return countPopulation() == _AP_W; }\n\n  /// This checks to see if the value of this ap_private is the maximum signed\n  /// value for the ap_private's bit width.\n  /// @brief Determine if this is the largest signed value.\n  INLINE bool isMaxSignedValue() const {\n    return !isNegative() && countPopulation() == _AP_W - 1;\n  }\n\n  /// This checks to see if the value of this ap_private is the minimum unsigned\n  /// value for the ap_private's bit width.\n  /// @brief Determine if this is the smallest unsigned value.\n  INLINE bool isMinValue() const { return countPopulation() == 0; }\n\n  /// This checks to see if the value of this ap_private is the minimum signed\n  /// value for the ap_private's bit width.\n  /// @brief Determine if this is the smallest signed value.\n  INLINE bool isMinSignedValue() const {\n    return isNegative() && countPopulation() == 1;\n  }\n\n  /// This function returns a pointer to the internal storage of the ap_private.\n  /// This is useful for writing out the ap_private in binary form without any\n  /// conversions.\n  INLINE const uint64_t* getRawData() const { return &pVal[0]; }\n\n  // Square Root - this method computes and returns the square root of \"this\".\n  // Three mechanisms are used for computation. For small values (<= 5 bits),\n  // a table lookup is done. This gets some performance for common cases. For\n  // values using less than 52 bits, the value is converted to double and then\n  // the libc sqrt function is called. The result is rounded and then converted\n  // back to a uint64_t which is then used to construct the result. Finally,\n  // the Babylonian method for computing square roots is used.\n  INLINE ap_private sqrt() const {\n    // Determine the magnitude of the value.\n    uint32_t magnitude = getActiveBits();\n\n    // Use a fast table for some small values. This also gets rid of some\n    // rounding errors in libc sqrt for small values.\n    if (magnitude <= 5) {\n      static const uint8_t results[32] = {\n          /*     0 */ 0,\n          /*  1- 2 */ 1, 1,\n          /*  3- 6 */ 2, 2, 2, 2,\n          /*  7-12 */ 3, 3, 3, 3, 3, 3,\n          /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,\n          /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n          /*    31 */ 6};\n      return ap_private<_AP_W, _AP_S>(/*BitWidth,*/ results[get_VAL()]);\n    }\n\n    // If the magnitude of the value fits in less than 52 bits (the precision of\n    // an IEEE double precision floating point value), then we can use the\n    // libc sqrt function which will probably use a hardware sqrt computation.\n    // This should be faster than the algorithm below.\n    if (magnitude < 52) {\n#ifdef _MSC_VER\n      // Amazingly, VC++ doesn't have round().\n      return ap_private<_AP_W, _AP_S>(/*BitWidth,*/\n                                      uint64_t(::sqrt(double(get_VAL()))) +\n                                      0.5);\n#else\n      return ap_private<_AP_W, _AP_S>(/*BitWidth,*/\n                                      uint64_t(\n                                          ::round(::sqrt(double(get_VAL())))));\n#endif\n    }\n\n    // Okay, all the short cuts are exhausted. We must compute it. The following\n    // is a classical Babylonian method for computing the square root. This code\n    // was adapted to APINt from a wikipedia article on such computations.\n    // See http://www.wikipedia.org/ and go to the page named\n    // Calculate_an_integer_square_root.\n    uint32_t nbits = BitWidth, i = 4;\n    ap_private<_AP_W, _AP_S> testy(16);\n    ap_private<_AP_W, _AP_S> x_old(/*BitWidth,*/ 1);\n    ap_private<_AP_W, _AP_S> x_new(0);\n    ap_private<_AP_W, _AP_S> two(/*BitWidth,*/ 2);\n\n    // Select a good starting value using binary logarithms.\n    for (;; i += 2, testy = testy.shl(2))\n      if (i >= nbits || this->ule(testy)) {\n        x_old = x_old.shl(i / 2);\n        break;\n      }\n\n    // Use the Babylonian method to arrive at the integer square root:\n    for (;;) {\n      x_new = (this->udiv(x_old) + x_old).udiv(two);\n      if (x_old.ule(x_new)) break;\n      x_old = x_new;\n    }\n\n    // Make sure we return the closest approximation\n    // NOTE: The rounding calculation below is correct. It will produce an\n    // off-by-one discrepancy with results from pari/gp. That discrepancy has\n    // been\n    // determined to be a rounding issue with pari/gp as it begins to use a\n    // floating point representation after 192 bits. There are no discrepancies\n    // between this algorithm and pari/gp for bit widths < 192 bits.\n    ap_private<_AP_W, _AP_S> square(x_old * x_old);\n    ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old + 1));\n    if (this->ult(square))\n      return x_old;\n    else if (this->ule(nextSquare)) {\n      ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));\n      ap_private<_AP_W, _AP_S> offset(*this - square);\n      if (offset.ult(midpoint))\n        return x_old;\n      else\n        return x_old + 1;\n    } else\n      assert(0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\");\n    return x_old + 1;\n  }\n\n  ///\n  /// @Assignment Operators\n  ///\n  /// @returns *this after assignment of RHS.\n  /// @brief Copy assignment operator.\n  INLINE ap_private& operator=(const ap_private& RHS) {\n    if (this != &RHS) memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE ap_private& operator=(const volatile ap_private& RHS) {\n    if (this != &RHS)\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);\n    clearUnusedBits();\n    return *this;\n  }\n  INLINE void operator=(const ap_private& RHS) volatile {\n    if (this != &RHS)\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);\n    clearUnusedBits();\n  }\n  INLINE void operator=(const volatile ap_private& RHS) volatile {\n    if (this != &RHS)\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);\n    clearUnusedBits();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {\n    if (_AP_S1)\n      cpSextOrTrunc(RHS);\n    else\n      cpZextOrTrunc(RHS);\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {\n    if (_AP_S1)\n      cpSextOrTrunc(RHS);\n    else\n      cpZextOrTrunc(RHS);\n    clearUnusedBits();\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    *this = ap_private<_AP_W2, false>(op2);\n    return *this;\n  }\n\n#if 0\n    template<int _AP_W1, bool _AP_S1>\n    INLINE ap_private& operator=(const ap_private<_AP_W1, _AP_S1, true>& RHS) {\n        static const uint64_t that_sign_ext_mask = (_AP_W1==APINT_BITS_PER_WORD)?0:~0ULL>>(_AP_W1%APINT_BITS_PER_WORD)<<(_AP_W1%APINT_BITS_PER_WORD);\n        if (RHS.isNegative()) {\n            pVal[0] = RHS.get_VAL() | that_sign_ext_mask;\n            memset(pVal+1,~0, APINT_WORD_SIZE*(_AP_N-1));\n        } else {\n            pVal[0] = RHS.get_VAL();\n            memset(pVal+1, 0, APINT_WORD_SIZE*(_AP_N-1));\n        }\n        clearUnusedBits();\n        return *this;\n    }\n\n    template<int _AP_W1, bool _AP_S1>\n    INLINE ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1, true>& RHS) {\n        static const uint64_t that_sign_ext_mask = (_AP_W1==APINT_BITS_PER_WORD)?0:~0ULL>>(_AP_W1%APINT_BITS_PER_WORD)<<(_AP_W1%APINT_BITS_PER_WORD);\n        if (RHS.isNegative()) {\n            pVal[0] = RHS.get_VAL() | that_sign_ext_mask;\n            memset(pVal+1,~0, APINT_WORD_SIZE*(_AP_N-1));\n        } else {\n            pVal[0] = RHS.get_VAL();\n            memset(pVal+1, 0, APINT_WORD_SIZE*(_AP_N-1));\n        }\n        clearUnusedBits();\n        return *this;\n    }\n#endif\n\n/// from all c types.\n#define ASSIGN_OP_FROM_INT(C_TYPE, _AP_W2, _AP_S2) \\\n  INLINE ap_private& operator=(const C_TYPE rhs) { \\\n    ap_private<(_AP_W2), (_AP_S2)> tmp = rhs;      \\\n    operator=(tmp);                                \\\n    return *this;                                  \\\n  }\n\n  ASSIGN_OP_FROM_INT(bool, 1, false)\n  ASSIGN_OP_FROM_INT(char, 8, CHAR_IS_SIGNED)\n  ASSIGN_OP_FROM_INT(signed char, 8, true)\n  ASSIGN_OP_FROM_INT(unsigned char, 8, false)\n  ASSIGN_OP_FROM_INT(short, sizeof(short) * 8, true)\n  ASSIGN_OP_FROM_INT(unsigned short, sizeof(unsigned short) * 8, false)\n  ASSIGN_OP_FROM_INT(int, sizeof(int) * 8, true)\n  ASSIGN_OP_FROM_INT(unsigned int, sizeof(unsigned int) * 8, false)\n  ASSIGN_OP_FROM_INT(long, sizeof(long) * 8, true)\n  ASSIGN_OP_FROM_INT(unsigned long, sizeof(unsigned long) * 8, false)\n  ASSIGN_OP_FROM_INT(ap_slong, sizeof(ap_slong) * 8, true)\n  ASSIGN_OP_FROM_INT(ap_ulong, sizeof(ap_ulong) * 8, false)\n#undef ASSIGN_OP_FROM_INT\n\n  /// from c string.\n  // XXX this is a must, to prevent pointer being converted to bool.\n  INLINE ap_private& operator=(const char* s) {\n    ap_private tmp(s); // XXX direct initialization, as ctor is explicit.\n    operator=(tmp);\n    return *this;\n  }\n\n  ///\n  /// @name Unary Operators\n  ///\n  /// @returns a new ap_private value representing *this incremented by one\n  /// @brief Postfix increment operator.\n  INLINE const ap_private operator++(int) {\n    ap_private API(*this);\n    ++(*this);\n    return API;\n  }\n\n  /// @returns *this incremented by one\n  /// @brief Prefix increment operator.\n  INLINE ap_private& operator++() {\n    ap_private_ops::add_1(pVal, pVal, _AP_N, 1);\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// @returns a new ap_private representing *this decremented by one.\n  /// @brief Postfix decrement operator.\n  INLINE const ap_private operator--(int) {\n    ap_private API(*this);\n    --(*this);\n    return API;\n  }\n\n  /// @returns *this decremented by one.\n  /// @brief Prefix decrement operator.\n  INLINE ap_private& operator--() {\n    ap_private_ops::sub_1(pVal, _AP_N, 1);\n    clearUnusedBits();\n    return *this;\n  }\n\n  /// Performs a bitwise complement operation on this ap_private.\n  /// @returns an ap_private that is the bitwise complement of *this\n  /// @brief Unary bitwise complement operator.\n  INLINE ap_private<_AP_W + !_AP_S, true> operator~() const {\n    ap_private<_AP_W + !_AP_S, true> Result(*this);\n    Result.flip();\n    return Result;\n  }\n\n  /// Negates *this using two's complement logic.\n  /// @returns An ap_private value representing the negation of *this.\n  /// @brief Unary negation operator\n  INLINE typename RType<1, false>::minus operator-() const {\n    return ap_private<1, false>(0) - (*this);\n  }\n\n  /// Performs logical negation operation on this ap_private.\n  /// @returns true if *this is zero, false otherwise.\n  /// @brief Logical negation operator.\n  INLINE bool operator!() const {\n    for (int i = 0; i < _AP_N; ++i)\n      if (pVal[i]) return false;\n    return true;\n  }\n\n  template <bool _AP_S1>\n  INLINE ap_private<_AP_W, _AP_S || _AP_S1> And(\n      const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return this->operator&(RHS);\n  }\n  template <bool _AP_S1>\n  INLINE ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return this->operator|(RHS);\n  }\n  template <bool _AP_S1>\n  INLINE ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return this->operator^(RHS);\n  }\n\n  INLINE ap_private Mul(const ap_private& RHS) const {\n    ap_private Result(*this);\n    Result *= RHS;\n    return Result;\n  }\n\n  INLINE ap_private Add(const ap_private& RHS) const {\n    ap_private Result(0);\n    ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,\n                        _AP_N, _AP_S, _AP_S);\n    Result.clearUnusedBits();\n    return Result;\n  }\n\n  INLINE ap_private Sub(const ap_private& RHS) const {\n    ap_private Result(0);\n    ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,\n                        _AP_N, _AP_S, _AP_S);\n    Result.clearUnusedBits();\n    return Result;\n  }\n\n  /// Arithmetic right-shift this ap_private by shiftAmt.\n  /// @brief Arithmetic right-shift function.\n  INLINE ap_private ashr(uint32_t shiftAmt) const {\n    assert(shiftAmt <= BitWidth && \"Invalid shift amount, too big\");\n    // Handle a degenerate case\n    if (shiftAmt == 0) return ap_private(*this);\n\n    // If all the bits were shifted out, the result is, technically, undefined.\n    // We return -1 if it was negative, 0 otherwise. We check this early to\n    // avoid\n    // issues in the algorithm below.\n    if (shiftAmt == BitWidth) {\n      if (isNegative())\n        return ap_private(-1);\n      else\n        return ap_private(0);\n    }\n\n    // Create some space for the result.\n    ap_private Retval(0);\n    uint64_t* val = Retval.get_pVal();\n\n    // Compute some values needed by the following shift algorithms\n    uint32_t wordShift =\n        shiftAmt % APINT_BITS_PER_WORD;               // bits to shift per word\n    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD; // word offset for shift\n    uint32_t breakWord = _AP_N - 1 - offset;          // last word affected\n    uint32_t bitsInWord = whichBit(BitWidth); // how many bits in last word?\n    if (bitsInWord == 0) bitsInWord = APINT_BITS_PER_WORD;\n\n    // If we are shifting whole words, just move whole words\n    if (wordShift == 0) {\n      // Move the words containing significant bits\n      for (uint32_t i = 0; i <= breakWord; ++i)\n        val[i] = pVal[i + offset]; // move whole word\n\n      // Adjust the top significant word for sign bit fill, if negative\n      if (isNegative())\n        if (bitsInWord < APINT_BITS_PER_WORD)\n          val[breakWord] |= ~0ULL << (bitsInWord); // set high bits\n    } else {\n      // Shift the low order words\n      for (uint32_t i = 0; i < breakWord; ++i) {\n        // This combines the shifted corresponding word with the low bits from\n        // the next word (shifted into this word's high bits).\n        val[i] = ((pVal[i + offset]) >> (wordShift));\n        val[i] |= ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));\n      }\n\n      // Shift the break word. In this case there are no bits from the next word\n      // to include in this word.\n      val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);\n\n      // Deal with sign extenstion in the break word, and possibly the word\n      // before\n      // it.\n      if (isNegative()) {\n        if (wordShift > bitsInWord) {\n          if (breakWord > 0)\n            val[breakWord - 1] |=\n                ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));\n          val[breakWord] |= ~0ULL;\n        } else\n          val[breakWord] |= (~0ULL << (bitsInWord - wordShift));\n      }\n    }\n\n    // Remaining words are 0 or -1, just assign them.\n    uint64_t fillValue = (isNegative() ? ~0ULL : 0);\n    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = fillValue;\n    Retval.clearUnusedBits();\n    return Retval;\n  }\n\n  /// Logical right-shift this ap_private by shiftAmt.\n  /// @brief Logical right-shift function.\n  INLINE ap_private lshr(uint32_t shiftAmt) const {\n    // If all the bits were shifted out, the result is 0. This avoids issues\n    // with shifting by the size of the integer type, which produces undefined\n    // results. We define these \"undefined results\" to always be 0.\n    if (shiftAmt == BitWidth) return ap_private(0);\n\n    // If none of the bits are shifted out, the result is *this. This avoids\n    // issues with shifting byt he size of the integer type, which produces\n    // undefined results in the code below. This is also an optimization.\n    if (shiftAmt == 0) return ap_private(*this);\n\n    // Create some space for the result.\n    ap_private Retval(0);\n    uint64_t* val = Retval.get_pVal();\n\n    // If we are shifting less than a word, compute the shift with a simple\n    // carry\n    if (shiftAmt < APINT_BITS_PER_WORD) {\n      uint64_t carry = 0;\n      for (int i = _AP_N - 1; i >= 0; --i) {\n        val[i] = ((pVal[i]) >> (shiftAmt)) | carry;\n        carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);\n      }\n      Retval.clearUnusedBits();\n      return Retval;\n    }\n\n    // Compute some values needed by the remaining shift algorithms\n    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;\n    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;\n\n    // If we are shifting whole words, just move whole words\n    if (wordShift == 0) {\n      for (uint32_t i = 0; i < _AP_N - offset; ++i) val[i] = pVal[i + offset];\n      for (uint32_t i = _AP_N - offset; i < _AP_N; i++) val[i] = 0;\n      Retval.clearUnusedBits();\n      return Retval;\n    }\n\n    // Shift the low order words\n    uint32_t breakWord = _AP_N - offset - 1;\n    for (uint32_t i = 0; i < breakWord; ++i)\n      val[i] = ((pVal[i + offset]) >> (wordShift)) |\n               ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));\n    // Shift the break word.\n    val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);\n\n    // Remaining words are 0\n    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = 0;\n    Retval.clearUnusedBits();\n    return Retval;\n  }\n\n  /// Left-shift this ap_private by shiftAmt.\n  /// @brief Left-shift function.\n  INLINE ap_private shl(uint32_t shiftAmt) const {\n    assert(shiftAmt <= BitWidth && \"Invalid shift amount, too big\");\n    // If all the bits were shifted out, the result is 0. This avoids issues\n    // with shifting by the size of the integer type, which produces undefined\n    // results. We define these \"undefined results\" to always be 0.\n    if (shiftAmt == BitWidth) return ap_private(0);\n\n    // If none of the bits are shifted out, the result is *this. This avoids a\n    // lshr by the words size in the loop below which can produce incorrect\n    // results. It also avoids the expensive computation below for a common\n    // case.\n    if (shiftAmt == 0) return ap_private(*this);\n\n    // Create some space for the result.\n    ap_private Retval(0);\n    uint64_t* val = Retval.get_pVal();\n    // If we are shifting less than a word, do it the easy way\n    if (shiftAmt < APINT_BITS_PER_WORD) {\n      uint64_t carry = 0;\n      for (int i = 0; i < _AP_N; i++) {\n        val[i] = ((pVal[i]) << (shiftAmt)) | carry;\n        carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);\n      }\n      Retval.clearUnusedBits();\n      return Retval;\n    }\n\n    // Compute some values needed by the remaining shift algorithms\n    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;\n    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;\n\n    // If we are shifting whole words, just move whole words\n    if (wordShift == 0) {\n      for (uint32_t i = 0; i < offset; i++) val[i] = 0;\n      for (int i = offset; i < _AP_N; i++) val[i] = pVal[i - offset];\n      Retval.clearUnusedBits();\n      return Retval;\n    }\n\n    // Copy whole words from this to Result.\n    uint32_t i = _AP_N - 1;\n    for (; i > offset; --i)\n      val[i] = (pVal[i - offset]) << (wordShift) |\n               (pVal[i - offset - 1]) >> (APINT_BITS_PER_WORD - wordShift);\n    val[offset] = (pVal[0]) << (wordShift);\n    for (i = 0; i < offset; ++i) val[i] = 0;\n    Retval.clearUnusedBits();\n    return Retval;\n  }\n\n  INLINE ap_private rotl(uint32_t rotateAmt) const {\n    if (rotateAmt == 0) return ap_private(*this);\n    // Don't get too fancy, just use existing shift/or facilities\n    ap_private hi(*this);\n    ap_private lo(*this);\n    hi.shl(rotateAmt);\n    lo.lshr(BitWidth - rotateAmt);\n    return hi | lo;\n  }\n\n  INLINE ap_private rotr(uint32_t rotateAmt) const {\n    if (rotateAmt == 0) return ap_private(*this);\n    // Don't get too fancy, just use existing shift/or facilities\n    ap_private hi(*this);\n    ap_private lo(*this);\n    lo.lshr(rotateAmt);\n    hi.shl(BitWidth - rotateAmt);\n    return hi | lo;\n  }\n\n  /// Perform an unsigned divide operation on this ap_private by RHS. Both this\n  /// and\n  /// RHS are treated as unsigned quantities for purposes of this division.\n  /// @returns a new ap_private value containing the division result\n  /// @brief Unsigned division operation.\n  INLINE ap_private udiv(const ap_private& RHS) const {\n    // Get some facts about the LHS and RHS number of bits and words\n    uint32_t rhsBits = RHS.getActiveBits();\n    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);\n    assert(rhsWords && \"Divided by zero???\");\n    uint32_t lhsBits = this->getActiveBits();\n    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);\n\n    // Deal with some degenerate cases\n    if (!lhsWords)\n      // 0 / X ===> 0\n      return ap_private(0);\n    else if (lhsWords < rhsWords || this->ult(RHS)) {\n      // X / Y ===> 0, iff X < Y\n      return ap_private(0);\n    } else if (*this == RHS) {\n      // X / X ===> 1\n      return ap_private(1);\n    } else if (lhsWords == 1 && rhsWords == 1) {\n      // All high words are zero, just use native divide\n      return ap_private(this->pVal[0] / RHS.get_pVal(0));\n    }\n\n    // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n    ap_private Quotient(0); // to hold result.\n    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient,\n                           (ap_private*)0);\n    return Quotient;\n  }\n\n  /// Signed divide this ap_private by ap_private RHS.\n  /// @brief Signed division function for ap_private.\n  INLINE ap_private sdiv(const ap_private& RHS) const {\n    if (isNegative())\n      if (RHS.isNegative())\n        return (-(*this)).udiv(-RHS);\n      else\n        return -((-(*this)).udiv(RHS));\n    else if (RHS.isNegative())\n      return -(this->udiv((ap_private)(-RHS)));\n    return this->udiv(RHS);\n  }\n\n  /// Perform an unsigned remainder operation on this ap_private with RHS being\n  /// the\n  /// divisor. Both this and RHS are treated as unsigned quantities for purposes\n  /// of this operation. Note that this is a true remainder operation and not\n  /// a modulo operation because the sign follows the sign of the dividend\n  /// which is *this.\n  /// @returns a new ap_private value containing the remainder result\n  /// @brief Unsigned remainder operation.\n  INLINE ap_private urem(const ap_private& RHS) const {\n    // Get some facts about the LHS\n    uint32_t lhsBits = getActiveBits();\n    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);\n\n    // Get some facts about the RHS\n    uint32_t rhsBits = RHS.getActiveBits();\n    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);\n    assert(rhsWords && \"Performing remainder operation by zero ???\");\n\n    // Check the degenerate cases\n    if (lhsWords == 0) {\n      // 0 % Y ===> 0\n      return ap_private(0);\n    } else if (lhsWords < rhsWords || this->ult(RHS)) {\n      // X % Y ===> X, iff X < Y\n      return *this;\n    } else if (*this == RHS) {\n      // X % X == 0;\n      return ap_private(0);\n    } else if (lhsWords == 1) {\n      // All high words are zero, just use native remainder\n      return ap_private(pVal[0] % RHS.get_pVal(0));\n    }\n\n    // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n    ap_private Remainder(0);\n    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0),\n                           &Remainder);\n    return Remainder;\n  }\n\n  INLINE ap_private urem(uint64_t RHS) const {\n    // Get some facts about the LHS\n    uint32_t lhsBits = getActiveBits();\n    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);\n    // Get some facts about the RHS\n    uint32_t rhsWords = 1; //! rhsBits ? 0 : (ap_private<_AP_W,\n                           //! _AP_S>::whichWord(rhsBits - 1) + 1);\n    assert(rhsWords && \"Performing remainder operation by zero ???\");\n    // Check the degenerate cases\n    if (lhsWords == 0) {\n      // 0 % Y ===> 0\n      return ap_private(0);\n    } else if (lhsWords < rhsWords || this->ult(RHS)) {\n      // X % Y ===> X, iff X < Y\n      return *this;\n    } else if (*this == RHS) {\n      // X % X == 0;\n      return ap_private(0);\n    } else if (lhsWords == 1) {\n      // All high words are zero, just use native remainder\n      return ap_private(pVal[0] % RHS);\n    }\n\n    // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n    ap_private Remainder(0);\n    divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);\n    return Remainder;\n  }\n\n  /// Signed remainder operation on ap_private.\n  /// @brief Function for signed remainder operation.\n  INLINE ap_private srem(const ap_private& RHS) const {\n    if (isNegative()) {\n      ap_private lhs = -(*this);\n      if (RHS.isNegative()) {\n        ap_private rhs = -RHS;\n        return -(lhs.urem(rhs));\n      } else\n        return -(lhs.urem(RHS));\n    } else if (RHS.isNegative()) {\n      ap_private rhs = -RHS;\n      return this->urem(rhs);\n    }\n    return this->urem(RHS);\n  }\n\n  /// Signed remainder operation on ap_private.\n  /// @brief Function for signed remainder operation.\n  INLINE ap_private srem(int64_t RHS) const {\n    if (isNegative())\n      if (RHS < 0)\n        return -((-(*this)).urem(-RHS));\n      else\n        return -((-(*this)).urem(RHS));\n    else if (RHS < 0)\n      return this->urem(-RHS);\n    return this->urem(RHS);\n  }\n\n  /// Compares this ap_private with RHS for the validity of the equality\n  /// relationship.\n  /// @returns true if *this == Val\n  /// @brief Equality comparison.\n  template <bool _AP_S1>\n  INLINE bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return (*this) == RHS;\n  }\n\n  /// Compares this ap_private with RHS for the validity of the inequality\n  /// relationship.\n  /// @returns true if *this != Val\n  /// @brief Inequality comparison\n  template <bool _AP_S1>\n  INLINE bool ne(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the less-than relationship.\n  /// @returns true if *this < RHS when both are considered unsigned.\n  /// @brief Unsigned less than comparison\n  template <bool _AP_S1>\n  INLINE bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    // Get active bit length of both operands\n    uint32_t n1 = getActiveBits();\n    uint32_t n2 = RHS.getActiveBits();\n\n    // If magnitude of LHS is less than RHS, return true.\n    if (n1 < n2) return true;\n\n    // If magnitude of RHS is greather than LHS, return false.\n    if (n2 < n1) return false;\n\n    // If they bot fit in a word, just compare the low order word\n    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)\n      return pVal[0] < RHS.get_pVal(0);\n\n    // Otherwise, compare all words\n    uint32_t topWord = whichWord(AESL_std::max(n1, n2) - 1);\n    for (int i = topWord; i >= 0; --i) {\n      if (pVal[i] > RHS.get_pVal(i)) return false;\n      if (pVal[i] < RHS.get_pVal(i)) return true;\n    }\n    return false;\n  }\n\n  INLINE bool ult(uint64_t RHS) const {\n    // Get active bit length of both operands\n    uint32_t n1 = getActiveBits();\n    uint32_t n2 =\n        64 - ap_private_ops::CountLeadingZeros_64(RHS); // RHS.getActiveBits();\n\n    // If magnitude of LHS is less than RHS, return true.\n    if (n1 < n2) return true;\n\n    // If magnitude of RHS is greather than LHS, return false.\n    if (n2 < n1) return false;\n\n    // If they bot fit in a word, just compare the low order word\n    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)\n      return pVal[0] < RHS;\n    assert(0);\n  }\n\n  template <bool _AP_S1>\n  INLINE bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    ap_private lhs(*this);\n    ap_private<_AP_W, _AP_S1> rhs(RHS);\n    bool lhsNeg = isNegative();\n    bool rhsNeg = rhs.isNegative();\n    if (lhsNeg) {\n      // Sign bit is set so perform two's complement to make it positive\n      lhs.flip();\n      lhs++;\n    }\n    if (rhsNeg) {\n      // Sign bit is set so perform two's complement to make it positive\n      rhs.flip();\n      rhs++;\n    }\n\n    // Now we have unsigned values to compare so do the comparison if necessary\n    // based on the negativeness of the values.\n    if (lhsNeg)\n      if (rhsNeg)\n        return lhs.ugt(rhs);\n      else\n        return true;\n    else if (rhsNeg)\n      return false;\n    else\n      return lhs.ult(rhs);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  /// @returns true if *this <= RHS when both are considered unsigned.\n  /// @brief Unsigned less or equal comparison\n  template <bool _AP_S1>\n  INLINE bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return ult(RHS) || eq(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  /// @returns true if *this <= RHS when both are considered signed.\n  /// @brief Signed less or equal comparison\n  template <bool _AP_S1>\n  INLINE bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return slt(RHS) || eq(RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the greater-than relationship.\n  /// @returns true if *this > RHS when both are considered unsigned.\n  /// @brief Unsigned greather than comparison\n  template <bool _AP_S1>\n  INLINE bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return !ult(RHS) && !eq(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// the validity of the greater-than relationship.\n  /// @returns true if *this > RHS when both are considered signed.\n  /// @brief Signed greather than comparison\n  template <bool _AP_S1>\n  INLINE bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return !slt(RHS) && !eq(RHS);\n  }\n\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  /// @returns true if *this >= RHS when both are considered unsigned.\n  /// @brief Unsigned greater or equal comparison\n  template <bool _AP_S1>\n  INLINE bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {\n    return !ult(RHS);\n  }\n\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  /// @returns true if *this >= RHS when both are considered signed.\n  /// @brief Signed greather or equal comparison\n  template <bool _AP_S1>\n  INLINE bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {\n    return !slt(RHS);\n  }\n\n  // Sign extend to a new width.\n  template <int _AP_W1, bool _AP_S1>\n  INLINE void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {\n    assert(_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\");\n    assert(_AP_W1 <= MAX_INT_BITS && \"Too many bits\");\n    // If the sign bit isn't set, this is the same as zext.\n    if (!that.isNegative()) {\n      cpZext(that);\n      return;\n    }\n\n    // The sign bit is set. First, get some facts\n    enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD };\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;\n    // Mask the high order word appropriately\n    if (_AP_N1 == _AP_N) {\n      enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };\n      // The extension is contained to the wordsBefore-1th word.\n      static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);\n      pVal[_AP_N - 1] |= mask;\n      return;\n    }\n\n    enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };\n    // The extension is contained to the wordsBefore-1th word.\n    static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;\n    int i;\n    for (i = 0; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);\n    pVal[i - 1] |= mask;\n    for (; i < _AP_N - 1; i++) pVal[i] = ~0ULL;\n    pVal[i] = ~0ULL;\n    clearUnusedBits();\n    return;\n  }\n\n  //  Zero extend to a new width.\n  template <int _AP_W1, bool _AP_S1>\n  INLINE void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {\n    assert(_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\");\n    assert(_AP_W1 <= MAX_INT_BITS && \"Too many bits\");\n    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;\n    int i = 0;\n    for (; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);\n    for (; i < _AP_N; ++i) pVal[i] = 0;\n    clearUnusedBits();\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {\n    if (BitWidth > _AP_W1)\n      cpZext(that);\n    else {\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);\n      clearUnusedBits();\n    }\n  }\n\n  template <int _AP_W1, bool _AP_S1>\n  INLINE void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {\n    if (BitWidth > _AP_W1)\n      cpSext(that);\n    else {\n      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);\n      clearUnusedBits();\n    }\n  }\n\n  /// @}\n  /// @name Value Characterization Functions\n  /// @{\n\n  /// @returns the total number of bits.\n  INLINE uint32_t getBitWidth() const { return BitWidth; }\n\n  /// Here one word's bitwidth equals to that of uint64_t.\n  /// @returns the number of words to hold the integer value of this ap_private.\n  /// @brief Get the number of words.\n  INLINE uint32_t getNumWords() const {\n    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;\n  }\n\n  /// This function returns the number of active bits which is defined as the\n  /// bit width minus the number of leading zeros. This is used in several\n  /// computations to see how \"wide\" the value is.\n  /// @brief Compute the number of active bits in the value\n  INLINE uint32_t getActiveBits() const {\n    uint32_t bits = BitWidth - countLeadingZeros();\n    return bits ? bits : 1;\n  }\n\n  /// This method attempts to return the value of this ap_private as a zero\n  /// extended\n  /// uint64_t. The bitwidth must be <= 64 or the value must fit within a\n  /// uint64_t. Otherwise an assertion will result.\n  /// @brief Get zero extended value\n  INLINE uint64_t getZExtValue() const {\n    assert(getActiveBits() <= 64 && \"Too many bits for uint64_t\");\n    return *pVal;\n  }\n\n  /// This method attempts to return the value of this ap_private as a sign\n  /// extended\n  /// int64_t. The bit width must be <= 64 or the value must fit within an\n  /// int64_t. Otherwise an assertion will result.\n  /// @brief Get sign extended value\n  INLINE int64_t getSExtValue() const {\n    assert(getActiveBits() <= 64 && \"Too many bits for int64_t\");\n    return int64_t(pVal[0]);\n  }\n\n  /// This method determines how many bits are required to hold the ap_private\n  /// equivalent of the string given by \\p str of length \\p slen.\n  /// @brief Get bits required for string value.\n  INLINE static uint32_t getBitsNeeded(const char* str, uint32_t slen,\n                                       uint8_t radix) {\n    assert(str != 0 && \"Invalid value string\");\n    assert(slen > 0 && \"Invalid string length\");\n\n    // Each computation below needs to know if its negative\n    uint32_t isNegative = str[0] == '-';\n    if (isNegative) {\n      slen--;\n      str++;\n    }\n    // For radixes of power-of-two values, the bits required is accurately and\n    // easily computed\n    if (radix == 2) return slen + isNegative;\n    if (radix == 8) return slen * 3 + isNegative;\n    if (radix == 16) return slen * 4 + isNegative;\n\n    // Otherwise it must be radix == 10, the hard case\n    assert(radix == 10 && \"Invalid radix\");\n\n    // Convert to the actual binary value.\n    // ap_private<_AP_W, _AP_S> tmp(sufficient, str, slen, radix);\n\n    // Compute how many bits are required.\n    // return isNegative + tmp.logBase2() + 1;\n    return isNegative + slen * 4;\n  }\n\n  /// countLeadingZeros - This function is an ap_private version of the\n  /// countLeadingZeros_{32,64} functions in MathExtras.h. It counts the number\n  /// of zeros from the most significant bit to the first one bit.\n  /// @returns BitWidth if the value is zero.\n  /// @returns the number of zeros from the most significant bit to the first\n  /// one bits.\n  INLINE uint32_t countLeadingZeros() const {\n    enum {\n      msw_bits = (BitWidth % APINT_BITS_PER_WORD)\n                     ? (BitWidth % APINT_BITS_PER_WORD)\n                     : APINT_BITS_PER_WORD,\n      excessBits = APINT_BITS_PER_WORD - msw_bits\n    };\n    uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N - 1]);\n    if (Count >= excessBits) Count -= excessBits;\n    if (!pVal[_AP_N - 1]) {\n      for (int i = _AP_N - 1; i; --i) {\n        if (!pVal[i - 1])\n          Count += APINT_BITS_PER_WORD;\n        else {\n          Count += ap_private_ops::CountLeadingZeros_64(pVal[i - 1]);\n          break;\n        }\n      }\n    }\n    return Count;\n  }\n\n  /// countLeadingOnes - This function counts the number of contiguous 1 bits\n  /// in the high order bits. The count stops when the first 0 bit is reached.\n  /// @returns 0 if the high order bit is not set\n  /// @returns the number of 1 bits from the most significant to the least\n  /// @brief Count the number of leading one bits.\n  INLINE uint32_t countLeadingOnes() const {\n    if (isSingleWord())\n      return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);\n\n    uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;\n    uint32_t shift =\n        (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);\n    int i = _AP_N - 1;\n    uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);\n    if (Count == highWordBits) {\n      for (i--; i >= 0; --i) {\n        if (get_pVal(i) == ~0ULL)\n          Count += APINT_BITS_PER_WORD;\n        else {\n          Count += countLeadingOnes_64(get_pVal(i), 0);\n          break;\n        }\n      }\n    }\n    return Count;\n  }\n\n  /// countTrailingZeros - This function is an ap_private version of the\n  /// countTrailingZoers_{32,64} functions in MathExtras.h. It counts\n  /// the number of zeros from the least significant bit to the first set bit.\n  /// @returns BitWidth if the value is zero.\n  /// @returns the number of zeros from the least significant bit to the first\n  /// one bit.\n  /// @brief Count the number of trailing zero bits.\n  INLINE uint32_t countTrailingZeros() const {\n    uint32_t Count = 0;\n    uint32_t i = 0;\n    for (; i < _AP_N && get_pVal(i) == 0; ++i) Count += APINT_BITS_PER_WORD;\n    if (i < _AP_N) Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));\n    return AESL_std::min(Count, BitWidth);\n  }\n  /// countPopulation - This function is an ap_private version of the\n  /// countPopulation_{32,64} functions in MathExtras.h. It counts the number\n  /// of 1 bits in the ap_private value.\n  /// @returns 0 if the value is zero.\n  /// @returns the number of set bits.\n  /// @brief Count the number of bits set.\n  INLINE uint32_t countPopulation() const {\n    uint32_t Count = 0;\n    for (int i = 0; i < _AP_N - 1; ++i)\n      Count += ap_private_ops::CountPopulation_64(pVal[i]);\n    Count += ap_private_ops::CountPopulation_64(pVal[_AP_N - 1] & mask);\n    return Count;\n  }\n\n  /// @}\n  /// @name Conversion Functions\n  /// @\n\n  /// This is used internally to convert an ap_private to a string.\n  /// @brief Converts an ap_private to a std::string\n  INLINE std::string toString(uint8_t radix, bool wantSigned) const;\n\n  /// Considers the ap_private to be unsigned and converts it into a string in\n  /// the\n  /// radix given. The radix can be 2, 8, 10 or 16.\n  /// @returns a character interpretation of the ap_private\n  /// @brief Convert unsigned ap_private to string representation.\n  INLINE std::string toStringUnsigned(uint8_t radix = 10) const {\n    return toString(radix, false);\n  }\n\n  /// Considers the ap_private to be unsigned and converts it into a string in\n  /// the\n  /// radix given. The radix can be 2, 8, 10 or 16.\n  /// @returns a character interpretation of the ap_private\n  /// @brief Convert unsigned ap_private to string representation.\n  INLINE std::string toStringSigned(uint8_t radix = 10) const {\n    return toString(radix, true);\n  }\n\n  /// @brief Converts this ap_private to a double value.\n  INLINE double roundToDouble(bool isSigned) const {\n    // Handle the simple case where the value is contained in one uint64_t.\n    if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {\n      uint64_t val = pVal[0];\n      if (isSigned) {\n        int64_t sext = ((int64_t(val)) << (64 - BitWidth)) >> (64 - BitWidth);\n        return double(sext);\n      } else\n        return double(val);\n    }\n\n    // Determine if the value is negative.\n    bool isNeg = isSigned ? (*this)[BitWidth - 1] : false;\n\n    // Construct the absolute value if we're negative.\n    ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));\n\n    // Figure out how many bits we're using.\n    uint32_t n = Tmp.getActiveBits();\n\n    // The exponent (without bias normalization) is just the number of bits\n    // we are using. Note that the sign bit is gone since we constructed the\n    // absolute value.\n    uint64_t exp = n;\n\n    // Return infinity for exponent overflow\n    if (exp > 1023) {\n      if (!isSigned || !isNeg)\n        return std::numeric_limits<double>::infinity();\n      else\n        return -std::numeric_limits<double>::infinity();\n    }\n    exp += 1023; // Increment for 1023 bias\n\n    // Number of bits in mantissa is 52. To obtain the mantissa value, we must\n    // extract the high 52 bits from the correct words in pVal.\n    uint64_t mantissa;\n    unsigned hiWord = whichWord(n - 1);\n    if (hiWord == 0) {\n      mantissa = Tmp.get_pVal(0);\n      if (n > 52)\n        (mantissa) >>= (n - 52); // shift down, we want the top 52 bits.\n    } else {\n      assert(hiWord > 0 && \"High word is negative?\");\n      uint64_t hibits = (Tmp.get_pVal(hiWord))\n                        << (52 - n % APINT_BITS_PER_WORD);\n      uint64_t lobits =\n          (Tmp.get_pVal(hiWord - 1)) >> (11 + n % APINT_BITS_PER_WORD);\n      mantissa = hibits | lobits;\n    }\n\n    // The leading bit of mantissa is implicit, so get rid of it.\n    uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;\n    union {\n      double __D;\n      uint64_t __I;\n    } __T;\n    __T.__I = sign | ((exp) << 52) | mantissa;\n    return __T.__D;\n  }\n\n  /// @brief Converts this unsigned ap_private to a double value.\n  INLINE double roundToDouble() const { return roundToDouble(false); }\n\n  /// @brief Converts this signed ap_private to a double value.\n  INLINE double signedRoundToDouble() const { return roundToDouble(true); }\n\n  /// The conversion does not do a translation from integer to double, it just\n  /// re-interprets the bits as a double. Note that it is valid to do this on\n  /// any bit width. Exactly 64 bits will be translated.\n  /// @brief Converts ap_private bits to a double\n  INLINE double bitsToDouble() const {\n    union {\n      uint64_t __I;\n      double __D;\n    } __T;\n    __T.__I = pVal[0];\n    return __T.__D;\n  }\n\n  /// The conversion does not do a translation from integer to float, it just\n  /// re-interprets the bits as a float. Note that it is valid to do this on\n  /// any bit width. Exactly 32 bits will be translated.\n  /// @brief Converts ap_private bits to a double\n  INLINE float bitsToFloat() const {\n    union {\n      uint32_t __I;\n      float __F;\n    } __T;\n    __T.__I = uint32_t(pVal[0]);\n    return __T.__F;\n  }\n\n  /// The conversion does not do a translation from double to integer, it just\n  /// re-interprets the bits of the double. Note that it is valid to do this on\n  /// any bit width but bits from V may get truncated.\n  /// @brief Converts a double to ap_private bits.\n  INLINE ap_private& doubleToBits(double __V) {\n    union {\n      uint64_t __I;\n      double __D;\n    } __T;\n    __T.__D = __V;\n    pVal[0] = __T.__I;\n    return *this;\n  }\n\n  /// The conversion does not do a translation from float to integer, it just\n  /// re-interprets the bits of the float. Note that it is valid to do this on\n  /// any bit width but bits from V may get truncated.\n  /// @brief Converts a float to ap_private bits.\n  INLINE ap_private& floatToBits(float __V) {\n    union {\n      uint32_t __I;\n      float __F;\n    } __T;\n    __T.__F = __V;\n    pVal[0] = __T.__I;\n  }\n\n  // Reduce operation\n  //-----------------------------------------------------------\n  INLINE bool and_reduce() const { return isMaxValue(); }\n\n  INLINE bool nand_reduce() const { return isMinValue(); }\n\n  INLINE bool or_reduce() const { return (bool)countPopulation(); }\n\n  INLINE bool nor_reduce() const { return countPopulation() == 0; }\n\n  INLINE bool xor_reduce() const {\n    unsigned int i = countPopulation();\n    return (i % 2) ? true : false;\n  }\n\n  INLINE bool xnor_reduce() const {\n    unsigned int i = countPopulation();\n    return (i % 2) ? false : true;\n  }\n  INLINE std::string to_string(uint8_t radix = 16, bool sign = false) const {\n    return toString(radix, radix == 10 ? _AP_S : sign);\n  }\n}; // End of class ap_private <_AP_W, _AP_S, false>\n\nnamespace ap_private_ops {\n\nenum { APINT_BITS_PER_WORD = 64 };\ntemplate <int _AP_W, bool _AP_S>\nINLINE bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {\n  return V2 == V1;\n}\n\ntemplate <int _AP_W, bool _AP_S>\nINLINE bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {\n  return V2 != V1;\n}\n\ntemplate <int _AP_W, bool _AP_S, int index>\nINLINE bool get(const ap_private<_AP_W, _AP_S>& a) {\n  static const uint64_t mask = 1ULL << (index & 0x3f);\n  return ((mask & a.get_pVal((index) >> 6)) != 0);\n}\n\ntemplate <int _AP_W, bool _AP_S, int msb_index, int lsb_index>\nINLINE void set(ap_private<_AP_W, _AP_S>& a,\n                const ap_private<AP_MAX(msb_index, 1), true>& mark1 = 0,\n                const ap_private<AP_MAX(lsb_index, 1), true>& mark2 = 0) {\n  enum {\n    APINT_BITS_PER_WORD = 64,\n    lsb_word = lsb_index / APINT_BITS_PER_WORD,\n    msb_word = msb_index / APINT_BITS_PER_WORD,\n    msb = msb_index % APINT_BITS_PER_WORD,\n    lsb = lsb_index % APINT_BITS_PER_WORD\n  };\n  if (msb_word == lsb_word) {\n    const uint64_t mask = ~0ULL >>\n                          (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>\n                          (APINT_BITS_PER_WORD - msb - 1);\n    // a.set_pVal(msb_word, a.get_pVal(msb_word)  | mask);\n    a.get_pVal(msb_word) |= mask;\n  } else {\n    const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);\n    const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>\n                              (APINT_BITS_PER_WORD - msb - 1);\n    // a.set_pVal(lsb_word, a.get_pVal(lsb_word) | lsb_mask);\n    a.get_pVal(lsb_word) |= lsb_mask;\n    for (int i = lsb_word + 1; i < msb_word; i++) {\n      a.set_pVal(i, ~0ULL);\n      // a.get_pVal(i)=0;\n    }\n    // a.set_pVal(msb_word, a.get_pVal(msb_word) | msb_mask);\n\n    a.get_pVal(msb_word) |= msb_mask;\n  }\n  a.clearUnusedBits();\n}\n\ntemplate <int _AP_W, bool _AP_S, int msb_index, int lsb_index>\nINLINE void clear(ap_private<_AP_W, _AP_S>& a,\n                  const ap_private<AP_MAX(msb_index, 1), true>& mark1 = 0,\n                  const ap_private<AP_MAX(lsb_index, 1), true>& mark2 = 0) {\n  enum {\n    APINT_BITS_PER_WORD = 64,\n    lsb_word = lsb_index / APINT_BITS_PER_WORD,\n    msb_word = msb_index / APINT_BITS_PER_WORD,\n    msb = msb_index % APINT_BITS_PER_WORD,\n    lsb = lsb_index % APINT_BITS_PER_WORD\n  };\n  if (msb_word == lsb_word) {\n    const uint64_t mask =\n        ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>\n          (APINT_BITS_PER_WORD - msb - 1));\n    // a.set_pVal(msb_word, a.get_pVal(msb_word) & mask);\n    a.get_pVal(msb_word) &= mask;\n  } else {\n    const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));\n    const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>\n                                (APINT_BITS_PER_WORD - msb - 1));\n    // a.set_pVal(lsb_word, a.get_pVal(lsb_word) & lsb_mask);\n    a.get_pVal(lsb_word) &= lsb_mask;\n    for (int i = lsb_word + 1; i < msb_word; i++) {\n      // a.set_pVal(i, 0);\n      a.get_pVal(i) = 0;\n    }\n    // a.set_pVal(msb_word, a.get_pVal(msb_word) & msb_mask);\n    a.get_pVal(msb_word) &= msb_mask;\n  }\n  a.clearUnusedBits();\n}\n\ntemplate <int _AP_W, bool _AP_S, int index>\nINLINE void set(ap_private<_AP_W, _AP_S>& a,\n                const ap_private<AP_MAX(index, 1), true>& mark = 0) {\n  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };\n  static const uint64_t mask = 1ULL << (index % APINT_BITS_PER_WORD);\n  // a.set_pVal(word, a.get_pVal(word) | mask);\n  a.get_pVal(word) |= mask;\n  a.clearUnusedBits();\n}\n\ntemplate <int _AP_W, bool _AP_S, int index>\nINLINE void clear(ap_private<_AP_W, _AP_S>& a,\n                  const ap_private<AP_MAX(index, 1), true>& mark = 0) {\n  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };\n  static const uint64_t mask = ~(1ULL << (index % APINT_BITS_PER_WORD));\n  // a.set_pVal(word, a.get_pVal(word) & mask);\n  a.get_pVal(word) &= mask;\n  a.clearUnusedBits();\n}\n\n} // End of ap_private_ops namespace\n\ntemplate <int _AP_W, bool _AP_S>\nINLINE std::string ap_private<_AP_W, _AP_S, false>::toString(\n    uint8_t radix, bool wantSigned) const {\n  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2) &&\n         \"Radix should be 2, 8, 10, or 16!\");\n  static const char* digits[] = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n                                 \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"};\n  std::string result;\n\n  if (radix != 10) {\n    // For the 2, 8 and 16 bit cases, we can just shift instead of divide\n    // because the number of bits per digit (1,3 and 4 respectively) divides\n    // equaly. We just shift until there value is zero.\n\n    // First, check for a zero value and just short circuit the logic below.\n    if (*this == (uint64_t)(0))\n      result = \"0\";\n    else {\n      ap_private<_AP_W, false> tmp(*this);\n      size_t insert_at = 0;\n      bool leading_zero = true;\n      if (wantSigned && isNegative()) {\n        // They want to print the signed version and it is a negative value\n        // Flip the bits and add one to turn it into the equivalent positive\n        // value and put a '-' in the result.\n        tmp.flip();\n        tmp++;\n        tmp.clearUnusedBitsToZero();\n        result = \"-\";\n        insert_at = 1;\n        leading_zero = false;\n      }\n      switch (radix) {\n        case 2:\n          result += \"0b\";\n          break;\n        case 8:\n          result += \"0o\";\n          break;\n        case 16:\n          result += \"0x\";\n          break;\n        default:\n          assert(\"invalid radix\" && 0);\n      }\n      insert_at += 2;\n      // Just shift tmp right for each digit width until it becomes zero\n      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));\n      uint64_t mask = radix - 1;\n      ap_private<_AP_W, false> zero(0);\n      unsigned bits = 0;\n      while (tmp.ne(zero)) {\n        uint64_t digit = tmp.get_VAL() & mask;\n        result.insert(insert_at, digits[digit]);\n        tmp = tmp.lshr(shift);\n        ++bits;\n      }\n      bits *= shift;\n      if (bits < _AP_W && leading_zero) result.insert(insert_at, digits[0]);\n    }\n    return result;\n  }\n\n  ap_private<_AP_W, false> tmp(*this);\n  ap_private<_AP_W, false> divisor(radix);\n  ap_private<_AP_W, false> zero(0);\n  size_t insert_at = 0;\n  if (wantSigned && isNegative()) {\n    // They want to print the signed version and it is a negative value\n    // Flip the bits and add one to turn it into the equivalent positive\n    // value and put a '-' in the result.\n    tmp.flip();\n    tmp++;\n    tmp.clearUnusedBitsToZero();\n    result = \"-\";\n    insert_at = 1;\n  }\n  if (tmp == ap_private<_AP_W, false>(0))\n    result = \"0\";\n  else\n    while (tmp.ne(zero)) {\n      ap_private<_AP_W, false> APdigit(0);\n      ap_private<_AP_W, false> tmp2(0);\n      ap_private_ops::divide(tmp, tmp.getNumWords(), divisor,\n                             divisor.getNumWords(), &tmp2, &APdigit);\n      uint64_t digit = APdigit.getZExtValue();\n      assert(digit < radix && \"divide failed\");\n      result.insert(insert_at, digits[digit]);\n      tmp = tmp2;\n    }\n\n  return result;\n} // End of ap_private<_AP_W, _AP_S, false>::toString()\n\ntemplate <int _AP_W, bool _AP_S>\nstd::ostream &operator<<(std::ostream &os, const ap_private<_AP_W, _AP_S> &x) {\n  std::ios_base::fmtflags ff = std::cout.flags();\n  if (ff & std::cout.hex) {\n    os << x.toString(16, false); // don't print sign\n  } else if (ff & std::cout.oct) {\n    os << x.toString(8, false); // don't print sign\n  } else {\n    os << x.toString(10, _AP_S);\n  }\n  return os;\n}\n\n// ------------------------------------------------------------ //\n//           XXX moved here from ap_int_sim.h  XXX              //\n// ------------------------------------------------------------ //\n\n/// Concatination reference.\n/// Proxy class which allows concatination to be used as rvalue(for reading) and\n/// lvalue(for writing)\n// ----------------------------------------------------------------\n// template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>\n// struct ap_concat_ref {\n//#ifdef _MSC_VER\n//#pragma warning(disable : 4521 4522)\n//#endif\n//  enum {\n//    _AP_WR = _AP_W1 + _AP_W2,\n//  };\n//  _AP_T1& mbv1;\n//  _AP_T2& mbv2;\n//\n//  INLINE ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>&\n//  ref)\n//      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}\n//\n//  INLINE ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_concat_ref& operator=(const ap_private<_AP_W3, _AP_S3>& val) {\n//    ap_private<_AP_W1 + _AP_W2, false> vval(val);\n//    int W_ref1 = mbv1.length();\n//    int W_ref2 = mbv2.length();\n//    ap_private<_AP_W1, false> mask1(-1);\n//    mask1 >>= _AP_W1 - W_ref1;\n//    ap_private<_AP_W2, false> mask2(-1);\n//    mask2 >>= _AP_W2 - W_ref2;\n//    mbv1.set(ap_private<_AP_W1, false>((vval >> W_ref2) & mask1));\n//    mbv2.set(ap_private<_AP_W2, false>(vval & mask2));\n//    return *this;\n//  }\n//\n//  INLINE ap_concat_ref& operator=(unsigned long long val) {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n//\n//  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>\n//  INLINE ap_concat_ref& operator=(\n//      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n//\n//  INLINE ap_concat_ref& operator=(\n//      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_concat_ref& operator=(const _private_bit_ref<_AP_W3, _AP_S3>&\n//  val) {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_concat_ref& operator=(const _private_range_ref<_AP_W3, _AP_S3>&\n//  val) {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n//\n//  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n//            ap_o_mode _AP_O3, int _AP_N3>\n//  INLINE ap_concat_ref& operator=(\n//      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val)\n//      {\n//    return operator=((const ap_private<_AP_W3, false>)(val));\n//  }\n//\n//  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n//            ap_o_mode _AP_O3, int _AP_N3>\n//  INLINE ap_concat_ref& operator=(\n//      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&\n//          val) {\n//    return operator=(val.to_ap_private());\n//  }\n//\n//  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n//            ap_o_mode _AP_O3, int _AP_N3>\n//  INLINE ap_concat_ref& operator=(\n//      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {\n//    return operator=((unsigned long long)(bool)(val));\n//  }\n//\n//  INLINE operator ap_private<_AP_WR, false>() const { return get(); }\n//\n//  INLINE operator unsigned long long() const { return get().to_uint64(); }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n//                       _private_range_ref<_AP_W3, _AP_S3> >\n//  operator,(const _private_range_ref<_AP_W3, _AP_S3> &a2) {\n//    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n//                         _private_range_ref<_AP_W3, _AP_S3> >(\n//        *this, const_cast<_private_range_ref<_AP_W3, _AP_S3>&>(a2));\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE\n//      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3>\n//      >\n//      operator,(ap_private<_AP_W3, _AP_S3> &a2) {\n//    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n//                         ap_private<_AP_W3, _AP_S3> >(*this, a2);\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE\n//      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3>\n//      >\n//      operator,(const ap_private<_AP_W3, _AP_S3> &a2) {\n//    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n//                         ap_private<_AP_W3, _AP_S3> >(\n//        *this, const_cast<ap_private<_AP_W3, _AP_S3>&>(a2));\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, 1, _private_bit_ref<_AP_W3,\n//  _AP_S3> >\n//  operator,(const _private_bit_ref<_AP_W3, _AP_S3> &a2) {\n//    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, _private_bit_ref<_AP_W3,\n//    _AP_S3> >(\n//        *this, const_cast<_private_bit_ref<_AP_W3, _AP_S3>&>(a2));\n//  }\n//\n//  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>\n//  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,\n//                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >\n//  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {\n//    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,\n//                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(\n//        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4,\n//        _AP_T4>&>(a2));\n//  }\n//\n//  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n//            ap_o_mode _AP_O3, int _AP_N3>\n//  INLINE ap_concat_ref<\n//      _AP_WR, ap_concat_ref, _AP_W3,\n//      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >\n//  operator,(\n//      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2)\n//      {\n//    return ap_concat_ref<\n//        _AP_WR, ap_concat_ref, _AP_W3,\n//        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(\n//        *this,\n//        const_cast<\n//            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3,\n//            _AP_N3>&>(a2));\n//  }\n//\n//  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n//            ap_o_mode _AP_O3, int _AP_N3>\n//  INLINE\n//      ap_concat_ref<_AP_WR, ap_concat_ref, 1,\n//                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>\n//                    >\n//      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3,\n//      _AP_N3>\n//                    &a2) {\n//    return ap_concat_ref<\n//        _AP_WR, ap_concat_ref, 1,\n//        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(\n//        *this,\n//        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3,\n//        _AP_N3>&>(\n//            a2));\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_private<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator&(\n//      const ap_private<_AP_W3, _AP_S3>& a2) {\n//    return get() & a2;\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_private<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator|(\n//      const ap_private<_AP_W3, _AP_S3>& a2) {\n//    return get() | a2;\n//  }\n//\n//  template <int _AP_W3, bool _AP_S3>\n//  INLINE ap_private<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator^(\n//      const ap_private<_AP_W3, _AP_S3>& a2) {\n//    return ap_private<AP_MAX(_AP_WR, _AP_W3), _AP_S3>(get() ^ a2);\n//  }\n//\n//  INLINE const ap_private<_AP_WR, false> get() const {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal =\n//        ap_private<_AP_W1 + _AP_W2, false>(mbv1.get());\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal2 =\n//        ap_private<_AP_W1 + _AP_W2, false>(mbv2.get());\n//    int W_ref2 = mbv2.length();\n//    tmpVal <<= W_ref2;\n//    tmpVal |= tmpVal2;\n//    return tmpVal;\n//  }\n//\n//  INLINE const ap_private<_AP_WR, false> get() {\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal =\n//        ap_private<_AP_W1 + _AP_W2, false>(mbv1.get());\n//    ap_private<_AP_W1 + _AP_W2, false> tmpVal2 =\n//        ap_private<_AP_W1 + _AP_W2, false>(mbv2.get());\n//    int W_ref2 = mbv2.length();\n//    tmpVal <<= W_ref2;\n//    tmpVal |= tmpVal2;\n//    return tmpVal;\n//  }\n//\n//  template <int _AP_W3>\n//  INLINE void set(const ap_private<_AP_W3, false>& val) {\n//    ap_private<_AP_W1 + _AP_W2, false> vval(val);\n//    int W_ref1 = mbv1.length();\n//    int W_ref2 = mbv2.length();\n//    ap_private<_AP_W1, false> mask1(-1);\n//    mask1 >>= _AP_W1 - W_ref1;\n//    ap_private<_AP_W2, false> mask2(-1);\n//    mask2 >>= _AP_W2 - W_ref2;\n//    mbv1.set(ap_private<_AP_W1, false>((vval >> W_ref2) & mask1));\n//    mbv2.set(ap_private<_AP_W2, false>(vval & mask2));\n//  }\n//\n//  INLINE int length() const { return mbv1.length() + mbv2.length(); }\n//\n//  INLINE std::string to_string(uint8_t radix = 2) const {\n//    return get().to_string(radix);\n//  }\n//}; // struct ap_concat_ref.\n\n/// Range(slice) reference\n/// Proxy class, which allows part selection to be used as rvalue(for reading)\n/// and lvalue(for writing)\n//------------------------------------------------------------\ntemplate <int _AP_W, bool _AP_S>\nstruct _private_range_ref {\n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n  ap_private<_AP_W, _AP_S>& d_bv;\n  int l_index;\n  int h_index;\n\n public:\n  /// copy ctor.\n  INLINE _private_range_ref(const _private_range_ref<_AP_W, _AP_S>& ref)\n      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}\n\n  /// direct ctor.\n  INLINE _private_range_ref(ap_private<_AP_W, _AP_S>* bv, int h, int l)\n      : d_bv(*bv), l_index(l), h_index(h) {\n    _AP_WARNING(h < 0 || l < 0,\n                \"Higher bound (%d) and lower bound (%d) cannot be \"\n                \"negative.\",\n                h, l);\n    _AP_WARNING(h >= _AP_W || l >= _AP_W,\n                \"Higher bound (%d) or lower bound (%d) out of range (%d).\", h, l,\n                _AP_W);\n  }\n\n  /// compound or assignment.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator|=(\n      const _private_range_ref<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index) != (ref.h_index - ref.l_index),\n                \"Bitsize mismach for ap_private<>.range() &= \"\n                \"ap_private<>.range().\");\n    this->d_bv |= ref.d_bv;\n    return *this;\n  }\n\n  /// compound or assignment with root type.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator|=(\n      const _AP_ROOT_TYPE<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index + 1) != _AP_W2,\n                \"Bitsize mismach for ap_private<>.range() |= _AP_ROOT_TYPE<>.\");\n    this->d_bv |= ref.V;\n    return *this;\n  }\n\n  /// compound and assignment.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator&=(\n      const _private_range_ref<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index) != (ref.h_index - ref.l_index),\n                \"Bitsize mismach for ap_private<>.range() &= \"\n                \"ap_private<>.range().\");\n    this->d_bv &= ref.d_bv;\n    return *this;\n  };\n\n  /// compound and assignment with root type.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator&=(\n      const _AP_ROOT_TYPE<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index + 1) != _AP_W2,\n                \"Bitsize mismach for ap_private<>.range() &= _AP_ROOT_TYPE<>.\");\n    this->d_bv &= ref.V;\n    return *this;\n  }\n\n  /// compound xor assignment.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator^=(\n      const _private_range_ref<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index) != (ref.h_index - ref.l_index),\n                \"Bitsize mismach for ap_private<>.range() ^= \"\n                \"ap_private<>.range().\");\n    this->d_bv ^= ref.d_bv;\n    return *this;\n  };\n\n  /// compound xor assignment with root type.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref<_AP_W, _AP_S>& operator^=(\n      const _AP_ROOT_TYPE<_AP_W2, _AP_S2>& ref) {\n    _AP_WARNING((h_index - l_index + 1) != _AP_W2,\n                \"Bitsize mismach for ap_private<>.range() ^= _AP_ROOT_TYPE<>.\");\n    this->d_bv ^= ref.V;\n    return *this;\n  }\n\n  /// @name convertors.\n  //  @{\n  INLINE operator ap_private<_AP_W, false>() const {\n    ap_private<_AP_W, false> val(0);\n    if (h_index >= l_index) {\n      if (_AP_W > 64) {\n        val = d_bv;\n        ap_private<_AP_W, false> mask(-1);\n        mask >>= _AP_W - (h_index - l_index + 1);\n        val >>= l_index;\n        val &= mask;\n      } else {\n        const static uint64_t mask = (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));\n        val = (d_bv >> l_index) & (mask >> (_AP_W - (h_index - l_index + 1)));\n      }\n    } else {\n      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)\n        if ((d_bv)[j]) val.set(i);\n    }\n    return val;\n  }\n\n  INLINE operator unsigned long long() const { return to_uint64(); }\n  //  @}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref& operator=(const ap_private<_AP_W2, _AP_S2>& val) {\n    ap_private<_AP_W, false> vval = ap_private<_AP_W, false>(val);\n    if (l_index > h_index) {\n      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)\n        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);\n    } else {\n      if (_AP_W > 64) {\n        ap_private<_AP_W, false> mask(-1);\n        if (l_index > 0) {\n          mask <<= l_index;\n          vval <<= l_index;\n        }\n        if (h_index < _AP_W - 1) {\n          ap_private<_AP_W, false> mask2(-1);\n          mask2 >>= _AP_W - h_index - 1;\n          mask &= mask2;\n          vval &= mask2;\n        }\n        mask.flip();\n        d_bv &= mask;\n        d_bv |= vval;\n      } else {\n        unsigned shift = 64 - _AP_W;\n        uint64_t mask = ~0ULL >> (shift);\n        if (l_index > 0) {\n          vval = mask & vval << l_index;\n          mask = mask & mask << l_index;\n        }\n        if (h_index < _AP_W - 1) {\n          uint64_t mask2 = mask;\n          mask2 >>= (_AP_W - h_index - 1);\n          mask &= mask2;\n          vval &= mask2;\n        }\n        mask = ~mask;\n        d_bv &= mask;\n        d_bv |= vval;\n      }\n    }\n    return *this;\n  } // operator=(const ap_private<>&)\n\n  INLINE _private_range_ref& operator=(unsigned long long val) {\n    const ap_private<_AP_W, _AP_S> vval = val;\n    return operator=(vval);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref& operator=(\n      const _private_bit_ref<_AP_W2, _AP_S2>& val) {\n    return operator=((unsigned long long)(bool)val);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE _private_range_ref& operator=(\n      const _private_range_ref<_AP_W2, _AP_S2>& val) {\n    const ap_private<_AP_W, false> tmpVal(val);\n    return operator=(tmpVal);\n  }\n\n//  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>\n//  INLINE _private_range_ref& operator=(\n//      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {\n//    const ap_private<_AP_W, false> tmpVal(val);\n//    return operator=(tmpVal);\n//  }\n\n  // TODO from ap_int_base, ap_bit_ref and ap_range_ref.\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE _private_range_ref& operator=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=(val.to_ap_int_base().V);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE _private_range_ref& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=(val.operator ap_int_base<_AP_W2, false>().V);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE _private_range_ref& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=((unsigned long long)(bool)val);\n  }\n\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, _private_range_ref, _AP_W2,\n//                       _private_range_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_range_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, _private_range_ref, _AP_W2,\n//                         _private_range_ref<_AP_W2, _AP_S2> >(\n//        *this, const_cast<_private_range_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, _private_range_ref, _AP_W2,\n//                       ap_private<_AP_W2, _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, _private_range_ref, _AP_W2,\n//                         ap_private<_AP_W2, _AP_S2> >(*this, a2);\n//  }\n//\n//  INLINE\n//  ap_concat_ref<_AP_W, _private_range_ref, _AP_W, ap_private<_AP_W, _AP_S> >\n//  operator,(ap_private<_AP_W, _AP_S>& a2) {\n//    return ap_concat_ref<_AP_W, _private_range_ref, _AP_W,\n//                         ap_private<_AP_W, _AP_S> >(*this, a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<_AP_W, _private_range_ref, 1,\n//                       _private_bit_ref<_AP_W2, _AP_S2> >\n//  operator,(const _private_bit_ref<_AP_W2, _AP_S2> &a2) {\n//    return ap_concat_ref<_AP_W, _private_range_ref, 1,\n//                         _private_bit_ref<_AP_W2, _AP_S2> >(\n//        *this, const_cast<_private_bit_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<_AP_W, _private_range_ref, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n//    return ap_concat_ref<_AP_W, _private_range_ref, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n//        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      _AP_W, _private_range_ref, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(\n//      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n//    return ap_concat_ref<\n//        _AP_W, _private_range_ref, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        *this,\n//        const_cast<\n//            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<_AP_W, _private_range_ref, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n//                    &a2) {\n//    return ap_concat_ref<\n//        _AP_W, _private_range_ref, 1,\n//        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        *this,\n//        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n//            a2));\n//  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs == rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs != rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs > rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs >= rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs < rhs;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_private<_AP_W, false> lhs = get();\n    ap_private<_AP_W2, false> rhs = op2.get();\n    return lhs <= rhs;\n  }\n\n  template <int _AP_W2>\n  INLINE void set(const ap_private<_AP_W2, false>& val) {\n    ap_private<_AP_W, _AP_S> vval = val;\n    if (l_index > h_index) {\n      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)\n        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);\n    } else {\n      if (_AP_W > 64) {\n        ap_private<_AP_W, _AP_S> mask(-1);\n        if (l_index > 0) {\n          ap_private<_AP_W, false> mask1(-1);\n          mask1 >>= _AP_W - l_index;\n          mask1.flip();\n          mask = mask1;\n          // vval&=mask1;\n          vval <<= l_index;\n        }\n        if (h_index < _AP_W - 1) {\n          ap_private<_AP_W, false> mask2(-1);\n          mask2 <<= h_index + 1;\n          mask2.flip();\n          mask &= mask2;\n          vval &= mask2;\n        }\n        mask.flip();\n        d_bv &= mask;\n        d_bv |= vval;\n      } else {\n        uint64_t mask = ~0ULL >> (64 - _AP_W);\n        if (l_index > 0) {\n          uint64_t mask1 = mask;\n          mask1 = mask & (mask1 >> (_AP_W - l_index));\n          vval = mask & (vval << l_index);\n          mask = ~mask1 & mask;\n          // vval&=mask1;\n        }\n        if (h_index < _AP_W - 1) {\n          uint64_t mask2 = ~0ULL >> (64 - _AP_W);\n          mask2 = mask & (mask2 << (h_index + 1));\n          mask &= ~mask2;\n          vval &= ~mask2;\n        }\n        d_bv &= (~mask & (~0ULL >> (64 - _AP_W)));\n        d_bv |= vval;\n      }\n    }\n  }\n\n  INLINE ap_private<_AP_W, false> get() const {\n    ap_private<_AP_W, false> val(0);\n    if (h_index < l_index) {\n      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)\n        if ((d_bv)[j]) val.set(i);\n    } else {\n      val = d_bv;\n      val >>= l_index;\n      if (h_index < _AP_W - 1) {\n        if (_AP_W <= 64) {\n          const static uint64_t mask =\n              (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));\n          val &= (mask >> (_AP_W - (h_index - l_index + 1)));\n        } else {\n          ap_private<_AP_W, false> mask(-1);\n          mask >>= _AP_W - (h_index - l_index + 1);\n          val &= mask;\n        }\n      }\n    }\n    return val;\n  }\n\n  INLINE ap_private<_AP_W, false> get() {\n    ap_private<_AP_W, false> val(0);\n    if (h_index < l_index) {\n      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)\n        if ((d_bv)[j]) val.set(i);\n    } else {\n      val = d_bv;\n      val >>= l_index;\n      if (h_index < _AP_W - 1) {\n        if (_AP_W <= 64) {\n          static const uint64_t mask = ~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0);\n          return val &= ((mask) >> (_AP_W - (h_index - l_index + 1)));\n        } else {\n          ap_private<_AP_W, false> mask(-1);\n          mask >>= _AP_W - (h_index - l_index + 1);\n          val &= mask;\n        }\n      }\n    }\n    return val;\n  }\n\n  INLINE int length() const {\n    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;\n  }\n\n  INLINE int to_int() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_int();\n  }\n\n  INLINE unsigned int to_uint() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_uint();\n  }\n\n  INLINE long to_long() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_long();\n  }\n\n  INLINE unsigned long to_ulong() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_ulong();\n  }\n\n  INLINE ap_slong to_int64() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_int64();\n  }\n\n  INLINE ap_ulong to_uint64() const {\n    ap_private<_AP_W, false> val = get();\n    return val.to_uint64();\n  }\n\n  INLINE std::string to_string(uint8_t radix = 2) const {\n    return get().to_string(radix);\n  }\n\n  INLINE bool and_reduce() {\n    bool ret = true;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) ret &= d_bv[i];\n    return ret;\n  }\n\n  INLINE bool or_reduce() {\n    bool ret = false;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) ret |= d_bv[i];\n    return ret;\n  }\n\n  INLINE bool xor_reduce() {\n    bool ret = false;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) ret ^= d_bv[i];\n    return ret;\n  }\n}; // struct _private_range_ref.\n\n/// Bit reference\n/// Proxy class, which allows bit selection to be used as rvalue(for reading)\n/// and lvalue(for writing)\n//--------------------------------------------------------------\ntemplate <int _AP_W, bool _AP_S>\nstruct _private_bit_ref {\n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n  ap_private<_AP_W, _AP_S>& d_bv;\n  int d_index;\n\n public:\n  // copy ctor.\n  INLINE _private_bit_ref(const _private_bit_ref<_AP_W, _AP_S>& ref)\n      : d_bv(ref.d_bv), d_index(ref.d_index) {}\n\n  // director ctor.\n  INLINE _private_bit_ref(ap_private<_AP_W, _AP_S>& bv, int index = 0)\n      : d_bv(bv), d_index(index) {\n    _AP_WARNING(d_index < 0, \"Index of bit vector  (%d) cannot be negative.\\n\",\n                d_index);\n    _AP_WARNING(d_index >= _AP_W,\n                \"Index of bit vector (%d) out of range (%d).\\n\", d_index, _AP_W);\n  }\n\n  INLINE operator bool() const { return d_bv.get_bit(d_index); }\n\n  INLINE bool to_bool() const { return operator bool(); }\n\n  template <typename T>\n  INLINE _private_bit_ref& operator=(const T& val) {\n    if (!!val)\n      d_bv.set(d_index);\n    else\n      d_bv.clear(d_index);\n    return *this;\n  }\n\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<1, _private_bit_ref, _AP_W2, ap_private<_AP_W2,\n//  _AP_S2> >\n//  operator,(ap_private<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, _AP_W2, ap_private<_AP_W2,\n//    _AP_S2> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this), a2);\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<1, _private_bit_ref, _AP_W2,\n//  _private_range_ref<_AP_W2,\n//  _AP_S2> >\n//  operator,(const _private_range_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, _AP_W2,\n//    _private_range_ref<_AP_W2,\n//    _AP_S2> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_range_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, bool _AP_S2>\n//  INLINE ap_concat_ref<1, _private_bit_ref, 1, _private_bit_ref<_AP_W2,\n//  _AP_S2> > operator,(\n//      const _private_bit_ref<_AP_W2, _AP_S2> &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, 1,\n//    _private_bit_ref<_AP_W2, _AP_S2> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_bit_ref<_AP_W2, _AP_S2>&>(a2));\n//  }\n//\n//  INLINE ap_concat_ref<1, _private_bit_ref, 1, _private_bit_ref>\n//  operator,(\n//      const _private_bit_ref &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, 1, _private_bit_ref>(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<_private_bit_ref&>(a2));\n//  }\n//\n//  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n//  INLINE ap_concat_ref<1, _private_bit_ref, _AP_W2 + _AP_W3,\n//                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n//  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, _AP_W2 + _AP_W3,\n//                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE ap_concat_ref<\n//      1, _private_bit_ref, _AP_W2,\n//      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n//  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,\n//  _AP_N2>\n//                &a2) const {\n//    return ap_concat_ref<\n//        1, _private_bit_ref, _AP_W2,\n//        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<\n//            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,\n//            _AP_N2>&>(a2));\n//  }\n//\n//  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n//            ap_o_mode _AP_O2, int _AP_N2>\n//  INLINE\n//      ap_concat_ref<1, _private_bit_ref, 1,\n//                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,\n//                    _AP_N2> >\n//      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,\n//      _AP_N2>\n//                    &a2) const {\n//    return ap_concat_ref<1, _private_bit_ref, 1, af_bit_ref<_AP_W2,\n//    _AP_I2, _AP_S2,\n//                                                      _AP_Q2, _AP_O2,\n//                                                      _AP_N2> >(\n//        const_cast<_private_bit_ref<_AP_W, _AP_S>&>(*this),\n//        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,\n//        _AP_N2>&>(\n//            a2));\n//  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {\n    return get() == op.get();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {\n    return get() != op.get();\n  }\n\n  INLINE bool get() const { return operator bool(); }\n\n  //  template <int _AP_W3>\n  //  INLINE void set(const ap_private<_AP_W3, false>& val) {\n  //    operator=(val);\n  //  }\n\n  //  INLINE bool operator~() const {\n  //    bool bit = (d_bv)[d_index];\n  //    return bit ? false : true;\n  //  }\n\n  INLINE int length() const { return 1; }\n\n  //  INLINE std::string to_string() const {\n  //    bool val = get();\n  //    return val ? \"1\" : \"0\";\n  //  }\n\n}; // struct _private_bit_ref.\n\n// char a[100];\n// char* ptr = a;\n// ap_int<2> n = 3;\n// char* ptr2 = ptr + n*2;\n// avoid ambiguous errors\n#define OP_BIN_MIX_PTR(BIN_OP)                                           \\\n  template <typename PTR_TYPE, int _AP_W, bool _AP_S>                    \\\n  INLINE PTR_TYPE* operator BIN_OP(PTR_TYPE* i_op,                       \\\n                                   const ap_private<_AP_W, _AP_S>& op) { \\\n    typename ap_private<_AP_W, _AP_S>::ValType op2 = op;                 \\\n    return i_op BIN_OP op2;                                              \\\n  }                                                                      \\\n  template <typename PTR_TYPE, int _AP_W, bool _AP_S>                    \\\n  INLINE PTR_TYPE* operator BIN_OP(const ap_private<_AP_W, _AP_S>& op,   \\\n                                   PTR_TYPE* i_op) {                     \\\n    typename ap_private<_AP_W, _AP_S>::ValType op2 = op;                 \\\n    return op2 BIN_OP i_op;                                              \\\n  }\n\nOP_BIN_MIX_PTR(+)\nOP_BIN_MIX_PTR(-)\n#undef OP_BIN_MIX_PTR\n\n// float OP ap_int\n// when ap_int<wa>'s width > 64, then trunc ap_int<w> to ap_int<64>\n#define OP_BIN_MIX_FLOAT(BIN_OP, C_TYPE)                              \\\n  template <int _AP_W, bool _AP_S>                                    \\\n  INLINE C_TYPE operator BIN_OP(C_TYPE i_op,                          \\\n                                const ap_private<_AP_W, _AP_S>& op) { \\\n    typename ap_private<_AP_W, _AP_S>::ValType op2 = op;              \\\n    return i_op BIN_OP op2;                                           \\\n  }                                                                   \\\n  template <int _AP_W, bool _AP_S>                                    \\\n  INLINE C_TYPE operator BIN_OP(const ap_private<_AP_W, _AP_S>& op,   \\\n                                C_TYPE i_op) {                        \\\n    typename ap_private<_AP_W, _AP_S>::ValType op2 = op;              \\\n    return op2 BIN_OP i_op;                                           \\\n  }\n\n#define OPS_MIX_FLOAT(C_TYPE) \\\n  OP_BIN_MIX_FLOAT(*, C_TYPE) \\\n  OP_BIN_MIX_FLOAT(/, C_TYPE) \\\n  OP_BIN_MIX_FLOAT(+, C_TYPE) \\\n  OP_BIN_MIX_FLOAT(-, C_TYPE)\n\nOPS_MIX_FLOAT(float)\nOPS_MIX_FLOAT(double)\n#undef OP_BIN_MIX_FLOAT\n#undef OPS_MIX_FLOAT\n\n/// Operators mixing Integers with AP_Int\n// ----------------------------------------------------------------\n\n// partially specialize template argument _AP_C in order that:\n// for _AP_W > 64, we will explicitly convert operand with native data type\n// into corresponding ap_private\n// for _AP_W <= 64, we will implicitly convert operand with ap_private into\n// (unsigned) long long\n#define OP_BIN_MIX_INT(BIN_OP, C_TYPE, _AP_WI, _AP_SI, RTYPE)                  \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  INLINE                                                                       \\\n      typename ap_private<_AP_WI, _AP_SI>::template RType<_AP_W, _AP_S>::RTYPE \\\n      operator BIN_OP(C_TYPE i_op, const ap_private<_AP_W, _AP_S>& op) {       \\\n    return ap_private<_AP_WI, _AP_SI>(i_op).operator BIN_OP(op);               \\\n  }                                                                            \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  INLINE                                                                       \\\n      typename ap_private<_AP_W, _AP_S>::template RType<_AP_WI, _AP_SI>::RTYPE \\\n      operator BIN_OP(const ap_private<_AP_W, _AP_S>& op, C_TYPE i_op) {       \\\n    return op.operator BIN_OP(ap_private<_AP_WI, _AP_SI>(i_op));               \\\n  }\n\n#define OP_REL_MIX_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)                     \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE bool operator REL_OP(const ap_private<_AP_W, _AP_S>& op,          \\\n                              C_TYPE op2) {                                \\\n    return op.operator REL_OP(ap_private<_AP_W2, _AP_S2>(op2));            \\\n  }                                                                        \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE bool operator REL_OP(C_TYPE op2,                                  \\\n                              const ap_private<_AP_W, _AP_S, false>& op) { \\\n    return ap_private<_AP_W2, _AP_S2>(op2).operator REL_OP(op);            \\\n  }\n\n#define OP_ASSIGN_MIX_INT(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2)       \\\n  template <int _AP_W, bool _AP_S>                                 \\\n  INLINE ap_private<_AP_W, _AP_S>& operator ASSIGN_OP(             \\\n      ap_private<_AP_W, _AP_S>& op, C_TYPE op2) {                  \\\n    return op.operator ASSIGN_OP(ap_private<_AP_W2, _AP_S2>(op2)); \\\n  }\n\n#define OP_BIN_SHIFT_INT(BIN_OP, C_TYPE, _AP_WI, _AP_SI, RTYPE)                \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  C_TYPE operator BIN_OP(C_TYPE i_op,                                          \\\n                         const ap_private<_AP_W, _AP_S, false>& op) {          \\\n    return i_op BIN_OP(op.get_VAL());                                          \\\n  }                                                                            \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  INLINE                                                                       \\\n      typename ap_private<_AP_W, _AP_S>::template RType<_AP_WI, _AP_SI>::RTYPE \\\n      operator BIN_OP(const ap_private<_AP_W, _AP_S>& op, C_TYPE i_op) {       \\\n    return op.operator BIN_OP(i_op);                                           \\\n  }\n\n#define OP_ASSIGN_RSHIFT_INT(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2) \\\n  template <int _AP_W, bool _AP_S>                              \\\n  INLINE ap_private<_AP_W, _AP_S>& operator ASSIGN_OP(          \\\n      ap_private<_AP_W, _AP_S>& op, C_TYPE op2) {               \\\n    op = op.operator>>(op2);                                    \\\n    return op;                                                  \\\n  }\n\n#define OP_ASSIGN_LSHIFT_INT(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2) \\\n  template <int _AP_W, bool _AP_S>                              \\\n  INLINE ap_private<_AP_W, _AP_S>& operator ASSIGN_OP(          \\\n      ap_private<_AP_W, _AP_S>& op, C_TYPE op2) {               \\\n    op = op.operator<<(op2);                                    \\\n    return op;                                                  \\\n  }\n\n#define OPS_MIX_INT(C_TYPE, _AP_W2, _AP_S2)              \\\n  OP_BIN_MIX_INT(*, C_TYPE, (_AP_W2), (_AP_S2), mult)    \\\n  OP_BIN_MIX_INT(+, C_TYPE, (_AP_W2), (_AP_S2), plus)    \\\n  OP_BIN_MIX_INT(-, C_TYPE, (_AP_W2), (_AP_S2), minus)   \\\n  OP_BIN_MIX_INT(/, C_TYPE, (_AP_W2), (_AP_S2), div)     \\\n  OP_BIN_MIX_INT(%, C_TYPE, (_AP_W2), (_AP_S2), mod)     \\\n  OP_BIN_MIX_INT(&, C_TYPE, (_AP_W2), (_AP_S2), logic)   \\\n  OP_BIN_MIX_INT(|, C_TYPE, (_AP_W2), (_AP_S2), logic)   \\\n  OP_BIN_MIX_INT (^, C_TYPE, (_AP_W2), (_AP_S2), logic)  \\\n  OP_BIN_SHIFT_INT(>>, C_TYPE, (_AP_W2), (_AP_S2), arg1) \\\n  OP_BIN_SHIFT_INT(<<, C_TYPE, (_AP_W2), (_AP_S2), arg1) \\\n                                                         \\\n  OP_ASSIGN_MIX_INT(+=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(-=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(*=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(/=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(%=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(&=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(|=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_MIX_INT(^=, C_TYPE, (_AP_W2), (_AP_S2))      \\\n  OP_ASSIGN_RSHIFT_INT(>>=, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  OP_ASSIGN_LSHIFT_INT(<<=, C_TYPE, (_AP_W2), (_AP_S2))  \\\n                                                         \\\n  OP_REL_MIX_INT(>, C_TYPE, (_AP_W2), (_AP_S2))          \\\n  OP_REL_MIX_INT(<, C_TYPE, (_AP_W2), (_AP_S2))          \\\n  OP_REL_MIX_INT(>=, C_TYPE, (_AP_W2), (_AP_S2))         \\\n  OP_REL_MIX_INT(<=, C_TYPE, (_AP_W2), (_AP_S2))         \\\n  OP_REL_MIX_INT(==, C_TYPE, (_AP_W2), (_AP_S2))         \\\n  OP_REL_MIX_INT(!=, C_TYPE, (_AP_W2), (_AP_S2))\n\nOPS_MIX_INT(bool, 1, false)\nOPS_MIX_INT(char, 8, CHAR_IS_SIGNED)\nOPS_MIX_INT(signed char, 8, true)\nOPS_MIX_INT(unsigned char, 8, false)\nOPS_MIX_INT(short, sizeof(short) * 8, true)\nOPS_MIX_INT(unsigned short, sizeof(unsigned short) * 8, false)\nOPS_MIX_INT(int, sizeof(int) * 8, true)\nOPS_MIX_INT(unsigned int, sizeof(unsigned int) * 8, false)\nOPS_MIX_INT(long, sizeof(long) * 8, true)\nOPS_MIX_INT(unsigned long, sizeof(unsigned long) * 8, false)\nOPS_MIX_INT(ap_slong, sizeof(ap_slong) * 8, true)\nOPS_MIX_INT(ap_ulong, sizeof(ap_ulong) * 8, false)\n\n#undef OP_BIN_MIX_INT\n#undef OP_BIN_SHIFT_INT\n#undef OP_ASSIGN_MIX_INT\n#undef OP_ASSIGN_RSHIFT_INT\n#undef OP_ASSIGN_LSHIFT_INT\n#undef OP_REL_MIX_INT\n#undef OPS_MIX_INT\n\n#define OP_BIN_MIX_RANGE(BIN_OP, RTYPE)                                     \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>               \\\n  INLINE typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2,        \\\n                                                             _AP_S2>::RTYPE \\\n  operator BIN_OP(const _private_range_ref<_AP_W1, _AP_S1>& op1,            \\\n                  const ap_private<_AP_W2, _AP_S2>& op2) {                  \\\n    return ap_private<_AP_W1, false>(op1).operator BIN_OP(op2);             \\\n  }                                                                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>               \\\n  INLINE typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2,        \\\n                                                             _AP_S2>::RTYPE \\\n  operator BIN_OP(const ap_private<_AP_W1, _AP_S1>& op1,                    \\\n                  const _private_range_ref<_AP_W2, _AP_S2>& op2) {          \\\n    return op1.operator BIN_OP(ap_private<_AP_W2, false>(op2));             \\\n  }\n\n#define OP_ASSIGN_MIX_RANGE(ASSIGN_OP)                             \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>      \\\n  INLINE ap_private<_AP_W1, _AP_S1>& operator ASSIGN_OP(           \\\n      ap_private<_AP_W1, _AP_S1>& op1,                             \\\n      const _private_range_ref<_AP_W2, _AP_S2>& op2) {             \\\n    return op1.operator ASSIGN_OP(ap_private<_AP_W2, false>(op2)); \\\n  }                                                                \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>      \\\n  INLINE _private_range_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP(   \\\n      _private_range_ref<_AP_W1, _AP_S1>& op1,                     \\\n      ap_private<_AP_W2, _AP_S2>& op2) {                           \\\n    ap_private<_AP_W1, false> tmp(op1);                            \\\n    tmp.operator ASSIGN_OP(op2);                                   \\\n    op1 = tmp;                                                     \\\n    return op1;                                                    \\\n  }\n\n#define OP_REL_MIX_RANGE(REL_OP)                                               \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                  \\\n  INLINE bool operator REL_OP(const _private_range_ref<_AP_W1, _AP_S1>& op1,   \\\n                              const ap_private<_AP_W2, _AP_S2>& op2) {         \\\n    return ap_private<_AP_W1, false>(op1).operator REL_OP(op2);                \\\n  }                                                                            \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                  \\\n  INLINE bool operator REL_OP(const ap_private<_AP_W1, _AP_S1>& op1,           \\\n                              const _private_range_ref<_AP_W2, _AP_S2>& op2) { \\\n    return op1.operator REL_OP(op2.operator ap_private<_AP_W2, false>());      \\\n  }\n\nOP_BIN_MIX_RANGE(+, plus)\nOP_BIN_MIX_RANGE(-, minus)\nOP_BIN_MIX_RANGE(*, mult)\nOP_BIN_MIX_RANGE(/, div)\nOP_BIN_MIX_RANGE(%, mod)\nOP_BIN_MIX_RANGE(&, logic)\nOP_BIN_MIX_RANGE(|, logic)\nOP_BIN_MIX_RANGE(^, logic)\nOP_BIN_MIX_RANGE(>>, arg1)\nOP_BIN_MIX_RANGE(<<, arg1)\n#undef OP_BIN_MIX_RANGE\n\nOP_ASSIGN_MIX_RANGE(+=)\nOP_ASSIGN_MIX_RANGE(-=)\nOP_ASSIGN_MIX_RANGE(*=)\nOP_ASSIGN_MIX_RANGE(/=)\nOP_ASSIGN_MIX_RANGE(%=)\nOP_ASSIGN_MIX_RANGE(&=)\nOP_ASSIGN_MIX_RANGE(|=)\nOP_ASSIGN_MIX_RANGE(^=)\nOP_ASSIGN_MIX_RANGE(>>=)\nOP_ASSIGN_MIX_RANGE(<<=)\n#undef OP_ASSIGN_MIX_RANGE\n\nOP_REL_MIX_RANGE(>)\nOP_REL_MIX_RANGE(<)\nOP_REL_MIX_RANGE(>=)\nOP_REL_MIX_RANGE(<=)\nOP_REL_MIX_RANGE(==)\nOP_REL_MIX_RANGE(!=)\n#undef OP_REL_MIX_RANGE\n\n#define OP_BIN_MIX_BIT(BIN_OP, RTYPE)                                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                 \\\n  INLINE typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::RTYPE \\\n  operator BIN_OP(const _private_bit_ref<_AP_W1, _AP_S1>& op1,                \\\n                  const ap_private<_AP_W2, _AP_S2>& op2) {                    \\\n    return ap_private<1, false>(op1).operator BIN_OP(op2);                    \\\n  }                                                                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                 \\\n  INLINE typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::RTYPE \\\n  operator BIN_OP(const ap_private<_AP_W1, _AP_S1>& op1,                      \\\n                  const _private_bit_ref<_AP_W2, _AP_S2>& op2) {              \\\n    return op1.operator BIN_OP(ap_private<1, false>(op2));                    \\\n  }\n\n#define OP_ASSIGN_MIX_BIT(ASSIGN_OP)                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>  \\\n  INLINE ap_private<_AP_W1, _AP_S1>& operator ASSIGN_OP(       \\\n      ap_private<_AP_W1, _AP_S1>& op1,                         \\\n      _private_bit_ref<_AP_W2, _AP_S2>& op2) {                 \\\n    return op1.operator ASSIGN_OP(ap_private<1, false>(op2));  \\\n  }                                                            \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>  \\\n  INLINE _private_bit_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP( \\\n      _private_bit_ref<_AP_W1, _AP_S1>& op1,                   \\\n      ap_private<_AP_W2, _AP_S2>& op2) {                       \\\n    ap_private<1, false> tmp(op1);                             \\\n    tmp.operator ASSIGN_OP(op2);                               \\\n    op1 = tmp;                                                 \\\n    return op1;                                                \\\n  }\n\n#define OP_REL_MIX_BIT(REL_OP)                                               \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                \\\n  INLINE bool operator REL_OP(const _private_bit_ref<_AP_W1, _AP_S1>& op1,   \\\n                              const ap_private<_AP_W2, _AP_S2>& op2) {       \\\n    return ap_private<_AP_W1, false>(op1).operator REL_OP(op2);              \\\n  }                                                                          \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                \\\n  INLINE bool operator REL_OP(const ap_private<_AP_W1, _AP_S1>& op1,         \\\n                              const _private_bit_ref<_AP_W2, _AP_S2>& op2) { \\\n    return op1.operator REL_OP(ap_private<1, false>(op2));                   \\\n  }\n\nOP_ASSIGN_MIX_BIT(+=)\nOP_ASSIGN_MIX_BIT(-=)\nOP_ASSIGN_MIX_BIT(*=)\nOP_ASSIGN_MIX_BIT(/=)\nOP_ASSIGN_MIX_BIT(%=)\nOP_ASSIGN_MIX_BIT(&=)\nOP_ASSIGN_MIX_BIT(|=)\nOP_ASSIGN_MIX_BIT(^=)\nOP_ASSIGN_MIX_BIT(>>=)\nOP_ASSIGN_MIX_BIT(<<=)\n#undef OP_ASSIGN_MIX_BIT\n\nOP_BIN_MIX_BIT(+, plus)\nOP_BIN_MIX_BIT(-, minus)\nOP_BIN_MIX_BIT(*, mult)\nOP_BIN_MIX_BIT(/, div)\nOP_BIN_MIX_BIT(%, mod)\nOP_BIN_MIX_BIT(&, logic)\nOP_BIN_MIX_BIT(|, logic)\nOP_BIN_MIX_BIT(^, logic)\nOP_BIN_MIX_BIT(>>, arg1)\nOP_BIN_MIX_BIT(<<, arg1)\n#undef OP_BIN_MIX_BIT\n\nOP_REL_MIX_BIT(>)\nOP_REL_MIX_BIT(<)\nOP_REL_MIX_BIT(<=)\nOP_REL_MIX_BIT(>=)\nOP_REL_MIX_BIT(==)\nOP_REL_MIX_BIT(!=)\n#undef OP_REL_MIX_BIT\n\n#define REF_REL_OP_MIX_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)                  \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE bool operator REL_OP(const _private_range_ref<_AP_W, _AP_S>& op,   \\\n                              C_TYPE op2) {                                 \\\n    return (ap_private<_AP_W, false>(op))                                   \\\n        .                                                                   \\\n        operator REL_OP(ap_private<_AP_W2, _AP_S2>(op2));                   \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE bool operator REL_OP(C_TYPE op2,                                   \\\n                              const _private_range_ref<_AP_W, _AP_S>& op) { \\\n    return ap_private<_AP_W2, _AP_S2>(op2).operator REL_OP(                 \\\n        ap_private<_AP_W, false>(op));                                      \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE bool operator REL_OP(const _private_bit_ref<_AP_W, _AP_S>& op,     \\\n                              C_TYPE op2) {                                 \\\n    return (bool(op))REL_OP op2;                                            \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE bool operator REL_OP(C_TYPE op2,                                   \\\n                              const _private_bit_ref<_AP_W, _AP_S>& op) {   \\\n    return op2 REL_OP(bool(op));                                            \\\n  }\n\n#define REF_REL_MIX_INT(C_TYPE, _AP_W2, _AP_S2)      \\\n  REF_REL_OP_MIX_INT(>, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_REL_OP_MIX_INT(<, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_REL_OP_MIX_INT(>=, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_REL_OP_MIX_INT(<=, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_REL_OP_MIX_INT(==, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_REL_OP_MIX_INT(!=, C_TYPE, (_AP_W2), (_AP_S2))\n\nREF_REL_MIX_INT(bool, 1, false)\nREF_REL_MIX_INT(char, 8, CHAR_IS_SIGNED)\nREF_REL_MIX_INT(signed char, 8, true)\nREF_REL_MIX_INT(unsigned char, 8, false)\nREF_REL_MIX_INT(short, sizeof(short) * 8, true)\nREF_REL_MIX_INT(unsigned short, sizeof(unsigned short) * 8, false)\nREF_REL_MIX_INT(int, sizeof(int) * 8, true)\nREF_REL_MIX_INT(unsigned int, sizeof(unsigned int) * 8, false)\nREF_REL_MIX_INT(long, sizeof(long) * 8, true)\nREF_REL_MIX_INT(unsigned long, sizeof(unsigned long) * 8, false)\nREF_REL_MIX_INT(ap_slong, sizeof(ap_slong) * 8, true)\nREF_REL_MIX_INT(ap_ulong, sizeof(ap_ulong) * 8, false)\n#undef REF_REL_OP_MIX_INT\n#undef REF_REL_MIX_INT\n\n#define REF_BIN_OP_MIX_INT(BIN_OP, RTYPE, C_TYPE, _AP_W2, _AP_S2)              \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  INLINE                                                                       \\\n      typename ap_private<_AP_W, false>::template RType<_AP_W2, _AP_S2>::RTYPE \\\n      operator BIN_OP(const _private_range_ref<_AP_W, _AP_S>& op,              \\\n                      C_TYPE op2) {                                            \\\n    return (ap_private<_AP_W, false>(op))                                      \\\n        .                                                                      \\\n        operator BIN_OP(ap_private<_AP_W2, _AP_S2>(op2));                      \\\n  }                                                                            \\\n  template <int _AP_W, bool _AP_S>                                             \\\n  INLINE                                                                       \\\n      typename ap_private<_AP_W2, _AP_S2>::template RType<_AP_W, false>::RTYPE \\\n      operator BIN_OP(C_TYPE op2,                                              \\\n                      const _private_range_ref<_AP_W, _AP_S>& op) {            \\\n    return ap_private<_AP_W2, _AP_S2>(op2).operator BIN_OP(                    \\\n        ap_private<_AP_W, false>(op));                                         \\\n  }\n\n#define REF_BIN_MIX_INT(C_TYPE, _AP_W2, _AP_S2)            \\\n  REF_BIN_OP_MIX_INT(+, plus, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_MIX_INT(-, minus, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_MIX_INT(*, mult, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_MIX_INT(/, div, C_TYPE, (_AP_W2), (_AP_S2))   \\\n  REF_BIN_OP_MIX_INT(%, mod, C_TYPE, (_AP_W2), (_AP_S2))   \\\n  REF_BIN_OP_MIX_INT(&, logic, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_MIX_INT(|, logic, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_MIX_INT(^, logic, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_MIX_INT(>>, arg1, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_MIX_INT(<<, arg1, C_TYPE, (_AP_W2), (_AP_S2))\n\nREF_BIN_MIX_INT(bool, 1, false)\nREF_BIN_MIX_INT(char, 8, CHAR_IS_SIGNED)\nREF_BIN_MIX_INT(signed char, 8, true)\nREF_BIN_MIX_INT(unsigned char, 8, false)\nREF_BIN_MIX_INT(short, sizeof(short) * 8, true)\nREF_BIN_MIX_INT(unsigned short, sizeof(unsigned short) * 8, false)\nREF_BIN_MIX_INT(int, sizeof(int) * 8, true)\nREF_BIN_MIX_INT(unsigned int, sizeof(unsigned int) * 8, false)\nREF_BIN_MIX_INT(long, sizeof(long) * 8, true)\nREF_BIN_MIX_INT(unsigned long, sizeof(unsigned long) * 8, false)\nREF_BIN_MIX_INT(ap_slong, sizeof(ap_slong) * 8, true)\nREF_BIN_MIX_INT(ap_ulong, sizeof(ap_ulong) * 8, false)\n#undef REF_BIN_OP_MIX_INT\n#undef REF_BIN_MIX_INT\n\n#define REF_BIN_OP(BIN_OP, RTYPE)                                             \\\n  template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2>                   \\\n  INLINE                                                                      \\\n      typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::RTYPE \\\n      operator BIN_OP(const _private_range_ref<_AP_W, _AP_S>& lhs,            \\\n                      const _private_range_ref<_AP_W2, _AP_S2>& rhs) {        \\\n    return ap_private<_AP_W, false>(lhs).operator BIN_OP(                     \\\n        ap_private<_AP_W2, false>(rhs));                                      \\\n  }\n\nREF_BIN_OP(+, plus)\nREF_BIN_OP(-, minus)\nREF_BIN_OP(*, mult)\nREF_BIN_OP(/, div)\nREF_BIN_OP(%, mod)\nREF_BIN_OP(&, logic)\nREF_BIN_OP(|, logic)\nREF_BIN_OP(^, logic)\nREF_BIN_OP(>>, arg1)\nREF_BIN_OP(<<, arg1)\n#undef REF_BIN_OP\n\n//************************************************************************\n//  Implement\n//      ap_private<M+N> = ap_concat_ref<M> OP ap_concat_ref<N>\n//  for operators  +, -, *, /, %, >>, <<, &, |, ^\n//  Without these operators the operands are converted to int64 and\n//  larger results lose informations (higher order bits).\n//\n//                       operand OP\n//                      /          |\n//              left-concat        right-concat\n//                /     |           /         |\n//         <LW1,LT1>  <LW2,LT2>   <RW1,RT1>   <RW2,RT2>\n//\n//      _AP_LW1, _AP_LT1 (width and type of left-concat's left side)\n//      _AP_LW2, _AP_LT2 (width and type of left-concat's right side)\n//  Similarly for RHS of operand OP: _AP_RW1, AP_RW2, _AP_RT1, _AP_RT2\n//\n//  In Verilog 2001 result of concatenation is always unsigned even\n//  when both sides are signed.\n//************************************************************************\n\n#endif // ifndef __AP_PRIVATE_H__\n",
    "ap_fixed.h": "/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_FIXED_H__\n#define __AP_FIXED_H__\n\n#include \"ap_common.h\"\n#include \"ap_fixed_base.h\"\n#include \"ap_fixed_ref.h\"\n\n//---------------------------------------------------------------\n\n/// Signed Arbitrary Precision Fixed-Point Type.\n// default for _AP_Q, _AP_O and _AP_N set in ap_decl.h\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\nstruct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {\n  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;\n  // Constructor\n  /// default ctor\n  INLINE ap_fixed() : Base() {}\n\n  /// copy ctor from ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,\n                                      _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,\n                                               _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  //// from ap_fixed\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_fixed(\n  //    const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_fixed(\n  //    const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}\n\n  //// from ap_ufixed.\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_fixed(\n  //    const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>(op)) {\n  //}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_fixed(\n  //    const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>(op)) {\n  //}\n\n  /// copy ctor from ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n#ifdef __SYNTHESIS__\n#if ((__clang_major__ != 3) || (__clang_minor__ != 1))\n  /// ctor from raw val\n  INLINE ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {\n    Base::V = V;\n  }\n#endif\n#endif\n\n  //// from ap_int.\n  //template <int _AP_W2>\n  //INLINE ap_fixed(const ap_int<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, true>(op)) {}\n\n  //template <int _AP_W2>\n  //INLINE ap_fixed(const volatile ap_int<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, true>(op)) {}\n\n  //// from ap_uint.\n  //template <int _AP_W2>\n  //INLINE ap_fixed(const ap_uint<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, false>(op)) {}\n\n  //template <int _AP_W2>\n  //INLINE ap_fixed(const volatile ap_uint<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, false>(op)) {}\n\n  // from ap_bit_ref.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  // from ap_range_ref.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  // from ap_concat_ref.\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)\n      : Base(op) {}\n\n  // from af_bit_ref.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  // from af_range_ref.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_fixed(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n// from c types.\n#define CTOR(TYPE) \\\n  INLINE ap_fixed(TYPE v) : Base(v) {}\n\n  CTOR(bool)\n  CTOR(char)\n  CTOR(signed char)\n  CTOR(unsigned char)\n  CTOR(short)\n  CTOR(unsigned short)\n  CTOR(int)\n  CTOR(unsigned int)\n  CTOR(long)\n  CTOR(unsigned long)\n  CTOR(ap_slong)\n  CTOR(ap_ulong)\n  CTOR(half)\n  CTOR(float)\n  CTOR(double)\n#undef CTOR\n\n  INLINE ap_fixed(const char* s) : Base(s) {}\n\n  INLINE ap_fixed(const char* s, signed char rd) : Base(s, rd) {}\n\n  // Assignment\n  // The assignment operator is technically inherited; however, it is always\n  // hidden by an explicitly or implicitly defined assignment operator for the\n  // derived class.\n  /* XXX ctor will be used when right is not of proper type. */\n  INLINE ap_fixed& operator=(\n      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {\n    Base::V = op.V;\n    return *this;\n  }\n\n  INLINE void operator=(\n      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {\n    Base::V = op.V;\n  }\n\n  INLINE ap_fixed& operator=(\n      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {\n    Base::V = op.V;\n    return *this;\n  }\n\n  INLINE void operator=(\n      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {\n    Base::V = op.V;\n  }\n}; // struct ap_fixed.\n\n//-------------------------------------------------------------------\n\n// Unsigned Arbitrary Precision Fixed-Point Type.\n// default for _AP_Q, _AP_O and _AP_N set in ap_decl.h\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\nstruct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {\n  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;\n  // Constructor\n  /// default ctor\n  INLINE ap_ufixed() : Base() {}\n\n  /// copy ctor from ap_fixed_base\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,\n                                       _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  /// copy ctor from ap_fixed_base\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,\n                                                _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_ufixed(\n  //    const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_ufixed(\n  //    const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_ufixed(\n  //    const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>(op)) {\n  //}\n\n  //template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,\n  //          int _AP_N2>\n  //INLINE ap_ufixed(\n  //    const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)\n  //    : Base(ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>(op)) {\n  //}\n\n  /// copy ctor from ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n#ifdef __SYNTHESIS__\n#if ((__clang_major__ != 3) || (__clang_minor__ != 1))\n  /// ctor from  raw val\n  INLINE ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {\n    Base::V = V;\n  }\n#endif\n#endif\n\n  //template <int _AP_W2>\n  //INLINE ap_ufixed(const ap_int<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, true>(op)) {}\n\n  //template <int _AP_W2>\n  //INLINE ap_ufixed(const volatile ap_int<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, true>(op)) {}\n\n  //template <int _AP_W2>\n  //INLINE ap_ufixed(const ap_uint<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, false>(op)) {}\n\n  //template <int _AP_W2>\n  //INLINE ap_ufixed(const volatile ap_uint<_AP_W2>& op)\n  //    : Base(ap_int_base<_AP_W2, false>(op)) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_ufixed(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_ufixed(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)\n      : Base(op) {}\n\n#define CTOR(TYPE) \\\n  INLINE ap_ufixed(TYPE v) : Base(v) {}\n\n  CTOR(bool)\n  CTOR(char)\n  CTOR(signed char)\n  CTOR(unsigned char)\n  CTOR(short)\n  CTOR(unsigned short)\n  CTOR(int)\n  CTOR(unsigned int)\n  CTOR(long)\n  CTOR(unsigned long)\n  CTOR(ap_slong)\n  CTOR(ap_ulong)\n  CTOR(half)\n  CTOR(float)\n  CTOR(double)\n#undef CTOR\n\n  INLINE ap_ufixed(const char* s) : Base(s) {}\n\n  INLINE ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}\n\n  // Assignment\n  INLINE ap_ufixed& operator=(\n      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {\n    Base::V = op.V;\n    return *this;\n  }\n\n  INLINE void operator=(\n      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {\n    Base::V = op.V;\n  }\n\n  INLINE ap_ufixed& operator=(\n      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {\n    Base::V = op.V;\n    return *this;\n  }\n\n  INLINE void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,\n                                                 _AP_N>& op) volatile {\n    Base::V = op.V;\n  }\n}; // struct ap_ufixed\n\n\n#if !defined(__SYNTHESIS__) && (defined(SYSTEMC_H) || defined(SYSTEMC_INCLUDED))\n// XXX sc_trace overload for ap_fixed is already included in\n// \"ap_sysc/ap_sc_extras.h\", so do not define in synthesis.\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\nINLINE void sc_trace(sc_core::sc_trace_file* tf,\n                     const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op,\n                     const std::string& name) {\n  tf->trace(sc_dt::sc_lv<_AP_W>(op.to_string(2).c_str()), name);\n}\n\ntemplate <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>\nINLINE void sc_trace(sc_core::sc_trace_file* tf,\n                     const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op,\n                     const std::string& name) {\n  tf->trace(sc_dt::sc_lv<_AP_W>(op.to_string(2).c_str()), name);\n}\n#endif // System C sim\n\n// Specialization of std containers, so that std::complex<ap_fixed> can have its\n// image part automatically zero-initialized when only real part is provided.\n#include \"ap_fixed_special.h\"\n\n#endif // ifndef __AP_FIXED_H__ else\n\n// -*- cpp -*-\n",
    "ap_common.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n */\n\n#ifndef __AP_COMMON_H__\n#define __AP_COMMON_H__\n\n// ----------------------------------------------------------------------\n\n#include \"ap_decl.h\"\n\n// Macro functions\n#define AP_MAX(a, b) ((a) > (b) ? (a) : (b))\n#define AP_MIN(a, b) ((a) < (b) ? (a) : (b))\n#define AP_ABS(a) ((a) >= 0 ? (a) : -(a))\n\n#ifndef AP_ASSERT\n#ifndef __SYNTHESIS__\n#include \"assert.h\"\n#define AP_ASSERT(cond, msg) assert((cond) && (msg))\n#else\n#define AP_ASSERT(cond, msg)\n#endif // ifndef __SYNTHESIS__\n#endif // ifndef AP_ASSERT\n\n#ifndef __SYNTHESIS__\n// for fprintf messages.\n#include \"stdio.h\"\n// for exit on error.\n#include \"stdlib.h\"\n#endif\n\n// same disable condition as assert.\n#if !defined(__SYNTHESIS__) && !defined(NDEBUG)\n\n#define _AP_DEBUG(cond, ...)                  \\\n  do {                                        \\\n    if ((cond)) {                             \\\n      fprintf(stderr, \"DEBUG: \" __VA_ARGS__); \\\n      fprintf(stderr, \"\\n\");                  \\\n    }                                         \\\n  } while (0)\n#define _AP_WARNING(cond, ...)                  \\\n  do {                                          \\\n    if ((cond)) {                               \\\n      fprintf(stderr, \"WARNING: \" __VA_ARGS__); \\\n      fprintf(stderr, \"\\n\");                    \\\n    }                                           \\\n  } while (0)\n#define _AP_ERROR(cond, ...)                  \\\n  do {                                        \\\n    if ((cond)) {                             \\\n      fprintf(stderr, \"ERROR: \" __VA_ARGS__); \\\n      fprintf(stderr, \"\\n\");                  \\\n      abort();                                \\\n    }                                         \\\n  } while (0)\n\n#else // if !defined(__SYNTHESIS__) && !defined(NDEBUG)\n\n#define __AP_VOID_CAST static_cast<void>\n#define _AP_DEBUG(cond, ...) (__AP_VOID_CAST(0))\n#define _AP_WARNING(cond, ...) (__AP_VOID_CAST(0))\n#define _AP_ERROR(cond, ...) (__AP_VOID_CAST(0))\n\n#endif // if !defined(__SYNTHESIS__) && !defined(NDEBUG) else\n\n// ----------------------------------------------------------------------\n\n// Attribute only for synthesis\n#ifdef __SYNTHESIS__\n#define INLINE inline __attribute__((always_inline))\n//#define INLINE inline __attribute__((noinline))\n#else\n#define INLINE inline\n#endif\n\n#define AP_WEAK\n// __attribute__((weak))\n\n#ifndef AP_INT_MAX_W\n#define AP_INT_MAX_W 1024\n#endif\n\n#define BIT_WIDTH_UPPER_LIMIT (1 << 15)\n#if AP_INT_MAX_W > BIT_WIDTH_UPPER_LIMIT\n#error \"Bitwidth exceeds 32768 (1 << 15), the maximum allowed value\"\n#endif\n\n#define MAX_MODE(BITS) ((BITS + 1023) / 1024)\n\n// ----------------------------------------------------------------------\n\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\n// for overload operator<<\n#include \"iostream\"\n#endif\n#endif // ifndef AP_AUTOCC\n\n#ifndef __SYNTHESIS__\n// for string format.\n#include \"sstream\"\n// for string.\n#include \"string\"\n#endif\n\n// for detecting if char is signed.\nenum { CHAR_IS_SIGNED = (char)-1 < 0 };\n\n// TODO we have similar traits in x_hls_utils.h, should consider unify.\nnamespace _ap_type {\ntemplate <typename _Tp>\nstruct is_signed {\n  static const bool value = _Tp(-1) < _Tp(1);\n};\n\ntemplate <typename _Tp>\nstruct is_integral {\n  static const bool value = false;\n};\n#define DEF_IS_INTEGRAL(CTYPE)      \\\n  template <>                       \\\n  struct is_integral<CTYPE> {       \\\n    static const bool value = true; \\\n  };\nDEF_IS_INTEGRAL(bool)\nDEF_IS_INTEGRAL(char)\nDEF_IS_INTEGRAL(signed char)\nDEF_IS_INTEGRAL(unsigned char)\nDEF_IS_INTEGRAL(short)\nDEF_IS_INTEGRAL(unsigned short)\nDEF_IS_INTEGRAL(int)\nDEF_IS_INTEGRAL(unsigned int)\nDEF_IS_INTEGRAL(long)\nDEF_IS_INTEGRAL(unsigned long)\nDEF_IS_INTEGRAL(ap_slong)\nDEF_IS_INTEGRAL(ap_ulong)\n#undef DEF_IS_INTEGRAL\n\ntemplate <bool, typename _Tp = void>\nstruct enable_if {};\n// partial specialization for true\ntemplate <typename _Tp>\nstruct enable_if<true, _Tp> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_const {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_const<_Tp const> {\n  typedef _Tp type;\n};\n} // namespace _ap_type\n\n// ----------------------------------------------------------------------\n\n// Define ssdm_int and _ssdm_op.\n#ifdef __SYNTHESIS__\n\n#if ((__clang_major__ == 3) && (__clang_minor__ == 1))\n\n/* HECTOR is a tool for formal system-level to RTL equivalence checking.\n * https://www.research.ibm.com/haifa/conferences/hvc2008/present/CarlPixleyHVC08.pdf\n * we used to used Hector.h here instead of following ssdm_int definition,\n * but now it is deleted.\n */\ntemplate <int _AP_N, bool _AP_S>\nstruct ssdm_int;\n\n#define AP_INT_BASE(_AP_N, mode)                                   \\\n  template <>                                                      \\\n  struct ssdm_int<_AP_N + 1024 * mode, true> {                     \\\n    int V __attribute__((bitwidth(_AP_N + 1024 * mode)));          \\\n    INLINE ssdm_int<_AP_N + 1024 * mode, true>(){};                \\\n  };                                                               \\\n  template <>                                                      \\\n  struct ssdm_int<_AP_N + 1024 * mode, false> {                    \\\n    unsigned int V __attribute__((bitwidth(_AP_N + 1024 * mode))); \\\n    INLINE ssdm_int<_AP_N + 1024 * mode, false>(){};               \\\n  };\n\n#if MAX_MODE(AP_INT_MAX_W) >= 1\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 0)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 2\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 1)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 3\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 2)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 4\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 3)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 5\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 4)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 6\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 5)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 7\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 6)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 8\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 7)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 9\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 8)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 10\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 9)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 11\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 10)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 12\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 11)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 13\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 12)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 14\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 13)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 15\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 14)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 16\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 15)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 17\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 16)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 18\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 17)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 19\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 18)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 20\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 19)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 21\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 20)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 22\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 21)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 23\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 22)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 24\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 23)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 25\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 24)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 26\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 25)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 27\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 26)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 28\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 27)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 29\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 28)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 30\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 29)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 31\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 30)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#if MAX_MODE(AP_INT_MAX_W) >= 32\n#define HANDLE_BAT(TYPE, _AP_N) AP_INT_BASE(_AP_N, 31)\n#define APINT_DEFINE_INT64\n#include \"etc/autopilot_dt.def\"\n#undef APINT_DEFINE_INT64\n#undef HANDLE_BAT\n#endif\n\n#undef MAX_MODE\n#undef AP_INT_BASE\n\n#else // HLS clang of higher version than 3.1\n\ntemplate <int _AP_N, bool _AP_S>\nstruct ssdm_int;\n\ntemplate <int _AP_N>\nstruct ssdm_int<_AP_N, true> {\n  int V __attribute__((bitwidth(_AP_N)));\n  INLINE ssdm_int<_AP_N, true>(){};\n};\n\ntemplate <int _AP_N>\nstruct ssdm_int<_AP_N, false> {\n  unsigned V __attribute__((bitwidth(_AP_N)));\n  INLINE ssdm_int<_AP_N, false>(){};\n};\n\n#endif // clang 3.1 test\n\n// FIXME typeof is an compiler extension.\n// FIXME use ({}) to return value is GCC extension.\n\n#define _ssdm_op_concat(Ret, X, Y)                               \\\n  ({                                                             \\\n    typeof(Ret) __Result__ = 0;                                  \\\n    typeof(X) __X2__ = X;                                        \\\n    typeof(Y) __Y2__ = Y;                                        \\\n    __builtin_bit_concat((void*)(&__Result__), (void*)(&__X2__), \\\n                         (void*)(&__Y2__));                      \\\n    __Result__;                                                  \\\n  })\n\n#define _ssdm_op_get_bit(Val, Bit)                                   \\\n  ({                                                                 \\\n    typeof(Val) __Val2__ = Val;                                      \\\n    bool __Result__ = __builtin_bit_select((void*)(&__Val2__), Bit); \\\n    __Result__;                                                      \\\n  })\n\n#define _ssdm_op_set_bit(Val, Bit, Repl)                               \\\n  ({                                                                   \\\n    typename _ap_type::remove_const<typeof(Val)>::type __Result__ = 0; \\\n    typeof(Val) __Val2__ = Val;                                        \\\n    typeof(Repl) __Repl2__ = !!Repl;                                   \\\n    __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__),   \\\n                           (void*)(&__Repl2__), Bit, Bit);             \\\n    __Result__;                                                        \\\n  })\n\n#define _ssdm_op_get_range(Val, Lo, Hi)                                     \\\n  ({                                                                        \\\n    typename _ap_type::remove_const<typeof(Val)>::type __Result__ = 0;      \\\n    typeof(Val) __Val2__ = Val;                                             \\\n    __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), Lo, \\\n                              Hi);                                          \\\n    __Result__;                                                             \\\n  })\n\n#define _ssdm_op_set_range(Val, Lo, Hi, Repl)                          \\\n  ({                                                                   \\\n    typename _ap_type::remove_const<typeof(Val)>::type __Result__ = 0; \\\n    typeof(Val) __Val2__ = Val;                                        \\\n    typeof(Repl) __Repl2__ = Repl;                                     \\\n    __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__),   \\\n                           (void*)(&__Repl2__), Lo, Hi);               \\\n    __Result__;                                                        \\\n  })\n\n#include \"etc/autopilot_ssdm_bits.h\"\n\nextern \"C\" void _ssdm_string2bits(...);\n\n#endif // ifdef __SYNTHESIS__\n\n#ifndef NON_C99STRING\n#define _AP_C99 true\n#else\n#define _AP_C99 false\n#endif\n\nstatic inline unsigned char guess_radix(const char* s) {\n  unsigned char rd = 10; ///< default radix\n  const char* p = s;\n  // skip neg sign if it exists\n  if (p[0] == '-' || p[0] == '+') ++p;\n  // guess based on following two bits.\n  if (p[0] == '0') {\n    if (p[1] == 'b' || p[1] == 'B') {\n      rd = 2;\n    } else if (p[1] == 'o' || p[1] == 'O') {\n      rd = 8;\n    } else if (p[1] == 'x' || p[1] == 'X') {\n      rd = 16;\n    } else if (p[1] == 'd' || p[1] == 'D') {\n      rd = 10;\n    }\n  }\n  return rd;\n}\n\n// ----------------------------------------------------------------------\n\n// Forward declaration of all AP types.\n// Before ap_private definition.\n#ifdef __SYNTHESIS__\n#define _HLS_HALF_DEFINED_\ntypedef __fp16 half;\n#else\nclass half;\n#endif\n\n// FIXME previously, ap_int_syn.h includes hls_half.h, which includes cmath.h\n// even during synthesis. Some test cases are spoiled...\n#ifdef __cplusplus\n#ifndef __SYNTHESIS__\n#include \"cmath\"\n#endif\n#endif\n\n// ----------------------------------------------------------------------\n\n// Basic integral struct upon which ap_int and ap_fixed are defined.\n#ifdef __SYNTHESIS__\n// Use ssdm_int, a compiler dependent, attribute constrained integeral type as\n// basic data type.\n#define _AP_ROOT_TYPE ssdm_int\n// Basic ops.\n#define _AP_ROOT_op_concat(Ret, X, Y) _ssdm_op_concat(Ret, X, Y)\n#define _AP_ROOT_op_get_bit(Val, Bit) _ssdm_op_get_bit(Val, Bit)\n#define _AP_ROOT_op_set_bit(Val, Bit, Repl) _ssdm_op_set_bit(Val, Bit, Repl)\n#define _AP_ROOT_op_get_range(Val, Lo, Hi) _ssdm_op_get_range(Val, Lo, Hi)\n#define _AP_ROOT_op_set_range(Val, Lo, Hi, Repl) \\\n  _ssdm_op_set_range(Val, Lo, Hi, Repl)\n#define _AP_ROOT_op_reduce(Op, Val) _ssdm_op_reduce(Op, Val)\n#else // ifdef __SYNTHESIS__\n// Use ap_private for compiler-independent basic data type\ntemplate <int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64>\nclass ap_private;\n/// model ssdm_int in standard C++ for simulation.\ntemplate <int _AP_W, bool _AP_S>\nstruct ssdm_int_sim {\n  /// integral type with template-specified width and signedness.\n  ap_private<_AP_W, _AP_S> V;\n  ssdm_int_sim() {}\n};\n#define _AP_ROOT_TYPE ssdm_int_sim\n// private's ref uses _AP_ROOT_TYPE.\n#include \"etc/ap_private.h\"\n// XXX The C-sim model cannot use GCC-extension\n// Basic ops. Ret and Val are ap_private.\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3>\ninline _Tp1 _AP_ROOT_op_concat(const _Tp1& Ret, const _Tp2& X, const _Tp3& Y) {\n  _Tp1 r = (X).operator,(Y);\n  return r;\n}\n#define _AP_ROOT_op_get_bit(Val, Bit) (Val).get_bit((Bit))\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3>\ninline _Tp1& _AP_ROOT_op_set_bit(_Tp1& Val, const _Tp2& Bit, const _Tp3& Repl) {\n  (Val).set_bit((Bit), (Repl));\n  return Val;\n}\n// notice the order of high and low index is different in ssdm call and\n// ap_private.range()...\n#define _AP_ROOT_op_get_range(Val, Lo, Hi) (Val).range((Hi), (Lo))\ntemplate <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\ninline _Tp1& _AP_ROOT_op_set_range(_Tp1& Val, const _Tp2& Lo, const _Tp3& Hi,\n                                   const _Tp4& Repl) {\n  (Val).range((Hi), (Lo)) = Repl;\n  return (Val);\n}\n#define _AP_ROOT_op_and_reduce(Val) (Val).and_reduce()\n#define _AP_ROOT_op_nand_reduce(Val) (Val).nand_reduce()\n#define _AP_ROOT_op_or_reduce(Val) (Val).or_reduce()\n#define _AP_ROOT_op_xor_reduce(Val) (Val).xor_reduce()\n// ## is the concatenation in preprocessor:\n#define _AP_ROOT_op_reduce(Op, Val) _AP_ROOT_op_##Op##_reduce(Val)\n#endif // ifdef __SYNTHESIS__ else\n\n// ----------------------------------------------------------------------\n\n// Constants for half, single, double pricision floating points\n#define HALF_MAN 10\n#define FLOAT_MAN 23\n#define DOUBLE_MAN 52\n\n#define HALF_EXP 5\n#define FLOAT_EXP 8\n#define DOUBLE_EXP 11\n\n#define BIAS(e) ((1L << (e - 1L)) - 1L)\n#define HALF_BIAS BIAS(HALF_EXP)\n#define FLOAT_BIAS BIAS(FLOAT_EXP)\n#define DOUBLE_BIAS BIAS(DOUBLE_EXP)\n\n#define APFX_IEEE_DOUBLE_E_MAX DOUBLE_BIAS\n#define APFX_IEEE_DOUBLE_E_MIN (-DOUBLE_BIAS + 1)\n\nINLINE ap_ulong doubleToRawBits(double pf) {\n  union {\n    ap_ulong __L;\n    double __D;\n  } LD;\n  LD.__D = pf;\n  return LD.__L;\n}\n\nINLINE unsigned int floatToRawBits(float pf) {\n  union {\n    unsigned int __L;\n    float __D;\n  } LD;\n  LD.__D = pf;\n  return LD.__L;\n}\n\nINLINE unsigned short halfToRawBits(half pf) {\n#ifdef __SYNTHESIS__\n  union {\n    unsigned short __L;\n    half __D;\n  } LD;\n  LD.__D = pf;\n  return LD.__L;\n#else\n  return pf.get_bits();\n#endif\n}\n\n// usigned long long is at least 64-bit\nINLINE double rawBitsToDouble(ap_ulong pi) {\n  union {\n    ap_ulong __L;\n    double __D;\n  } LD;\n  LD.__L = pi;\n  return LD.__D;\n}\n\n// long is at least 32-bit\nINLINE float rawBitsToFloat(unsigned long pi) {\n  union {\n    unsigned int __L;\n    float __D;\n  } LD;\n  LD.__L = pi;\n  return LD.__D;\n}\n\n// short is at least 16-bit\nINLINE half rawBitsToHalf(unsigned short pi) {\n#ifdef __SYNTHESIS__\n  union {\n    unsigned short __L;\n    half __D;\n  } LD;\n  LD.__L = pi;\n  return LD.__D;\n#else\n  // sim model of half has a non-trivial constructor\n  half __D;\n  __D.set_bits(pi);\n  return __D;\n#endif\n}\n\n#endif // ifndef __AP_COMMON_H__ else\n\n// -*- cpp -*-\n// vim: fdm=marker:foldmarker=#if,#endif:nofoldenable\n\n\n",
    "floating_point_v7_0_bitacc_cmodel.h": "//----------------------------------------------------------------------------\n//   ____  ____\n//  /   /\\/   /\n// /___/  \\  /   Vendor: Xilinx\n// \\   \\   \\/    Version: 6.0\n//  \\   \\        Filename: $RCSfile: floating_point_v7_0_bitacc_cmodel.h,v $\n//  /   /        Date Last Modified: $Date: 2011/06/15 13:06:43 $\n// /___/   /\\    Date Created: 2011\n//\n// Device  : All\n// Library : floating_point_v7_0\n// Purpose : Header file for bit accurate model of Floating Point Operator\n// Revision: $Revision: 1.6.6.2 $\n//\n//------------------------------------------------------------------------------\n//  (c) Copyright 2011-2012 Xilinx, Inc. All rights reserved.\n//\n//  This file contains confidential and proprietary information\n//  of Xilinx, Inc. and is protected under U.S. and\n//  international copyright and other intellectual property\n//  laws.\n//\n//  DISCLAIMER\n//  This disclaimer is not a license and does not grant any\n//  rights to the materials distributed herewith. Except as\n//  otherwise provided in a valid license issued to you by\n//  Xilinx, and to the maximum extent permitted by applicable\n//  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n//  (2) Xilinx shall not be liable (whether in contract or tort,\n//  including negligence, or under any other theory of\n//  liability) for any loss or damage of any kind or nature\n//  related to, arising under or in connection with these\n//  materials, including for any direct, or any indirect,\n//  special, incidental, or consequential loss or damage\n//  (including loss of data, profits, goodwill, or any type of\n//  loss or damage suffered as a result of any action brought\n//  by a third party) even if such damage or loss was\n//  reasonably foreseeable or Xilinx had been advised of the\n//  possibility of the same.\n//\n//  CRITICAL APPLICATIONS\n//  Xilinx products are not designed or intended to be fail-\n//  safe, or for use in any application requiring fail-safe\n//  performance, such as life-support or safety devices or\n//  systems, Class III medical devices, nuclear facilities,\n//  applications related to the deployment of airbags, or any\n//  other applications that could lead to death, personal\n//  injury, or severe property or environmental damage\n//  (individually and collectively, \"Critical\n//  Applications\"). Customer assumes the sole risk and\n//  liability of any use of Xilinx products in Critical\n//  Applications, subject only to applicable laws and\n//  regulations governing limitations on product liability.\n//\n//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n//  PART OF THIS FILE AT ALL TIMES.\n//------------------------------------------------------------------------------\n\n#ifndef __xip_fpo_bitacc_cmodel_h\n#define __xip_fpo_bitacc_cmodel_h\n\n#ifdef NT\n#define __XIP_FPO_DLLIMPORT __declspec(dllimport)\n#define __XIP_FPO_DLLEXPORT __declspec(dllexport)\n#else\n#define __XIP_FPO_DLLIMPORT\n#define __XIP_FPO_DLLEXPORT\n#endif\n\n// Only define __XIP_FPO_BUILD_DLL when building the C model DLL; do not define it when using the C model\n#ifdef __XIP_FPO_BUILD_DLL\n#define __XIP_FPO_DLL __XIP_FPO_DLLEXPORT\n#else\n#define __XIP_FPO_DLL __XIP_FPO_DLLIMPORT\n#endif\n\n/* Extra define for functions with variable numbers of arguments */\n#define __XIP_FPO_SENTINEL_ATTR\n#if defined (__GNUC__)\n# if __GNUC__ >= 4\n#  undef __XIP_FPO_SENTINEL_ATTR\n#  define __XIP_FPO_SENTINEL_ATTR __attribute__ ((sentinel))\n# endif\n#endif\n\n/* Define Floating Point Operator core version number */\n#define XIP_FPO_VERSION_MAJOR 6\n#define XIP_FPO_VERSION_MINOR 2\n#define XIP_FPO_REVISION      0\n/* Version string does not include revision if revision is 0 (revision >0 reserved for future use) */\n#define XIP_FPO_VERSION_STRING \"6.2\"\n\n/* Use C99 exact width integer types for 64-bit integers and *_uj and *_sj functions */\n// For Windows platforms, stdint.h and inttypes.h are not present in Visual Studio 2005/2008\n// Therefore we define the required types ourselves\n// For Linux platforms, we need to continue using stdint.h (and not re-define intmax_t, uintmax_t)\n// because SysGen already uses this header.\n#ifdef NT\ntypedef   signed char      xint8;\ntypedef   signed short     xint16;\ntypedef   signed int       xint32;\ntypedef   signed long long xint64;\ntypedef unsigned char      xuint8;\ntypedef unsigned short     xuint16;\ntypedef unsigned int       xuint32;\ntypedef unsigned long long xuint64;\ntypedef xint64  intmax_t;\ntypedef xuint64 uintmax_t;\n#else\n#include \"stdint.h\"\ntypedef int8_t   xint8;\ntypedef int16_t  xint16;\ntypedef int32_t  xint32;\ntypedef int64_t  xint64;\ntypedef uint8_t  xuint8;\ntypedef uint16_t xuint16;\ntypedef uint32_t xuint32;\ntypedef uint64_t xuint64;\n#endif\n\n#include \"stdbool.h\"\n\n// REVISIT: included before mpfr.h to permit definition of prototypes for mpfr_printf\n#include \"stdio.h\"\n\n// Force MPFR to use intmax_t and uintmax_t types (the compiled libraries have the functions that use these)\n#define MPFR_USE_INTMAX_T\n\n// Tell MPIR on Windows platforms that it is compiled into a DLL\n#ifdef NT\n#define __GMP_LIBGMP_DLL 1\n#endif\n\n/* Check if GMP is included, and try to include it (Works with local GMP)\n   Note that where MPIR is provided as a compatible alternative to GMP,\n   it also provides a gmp.h header file to allow MPIR and GMP to be easily interchanged.\n   Select the correct gmp.h by setting the -I option (includes path) for your compiler. */\n#ifndef __GMP_H__\n#include \"gmp.h\"\n#endif\n\n/* Check if MPFR is included, and try to include it (Works with local MPFR) */\n#ifndef __MPFR_H\n#include \"mpfr.h\"\n#endif\n\n/* Precision of mantissa or exponent (bits) */\ntypedef long xip_fpo_prec_t;\n\n/* Definition of sign */\ntypedef int xip_fpo_sign_t;\n\n/* Definition of exponent */\ntypedef long xip_fpo_exp_t;\n\n/* The main floating point number structure */\ntypedef struct {\n  xip_fpo_prec_t  _xip_fpo_exp_prec;\n  xip_fpo_prec_t  _xip_fpo_mant_prec;\n  xip_fpo_sign_t  _xip_fpo_sign;\n  xip_fpo_exp_t   _xip_fpo_exp;\n  mp_limb_t      *_xip_fpo_d;\n} __xip_fpo_struct;\n\n/* The main fixed point number structure */\ntypedef struct {\n  xip_fpo_prec_t  _xip_fpo_i_prec;\n  xip_fpo_prec_t  _xip_fpo_frac_prec;\n  xint64         _xip_fpo_i;\n  xint64         _xip_fpo_frac;\n} __xip_fpo_fix_struct;\n\n/* User-visible types for floating point and fixed point numbers */\ntypedef       __xip_fpo_struct      xip_fpo_t[1];\ntypedef       __xip_fpo_fix_struct  xip_fpo_fix_t[1];\n\n/* Pointers to floating point and fixed point numbers, for function prototypes */\ntypedef       __xip_fpo_struct     *xip_fpo_ptr;\ntypedef const __xip_fpo_struct     *xip_fpo_srcptr;\ntypedef       __xip_fpo_fix_struct *xip_fpo_fix_ptr;\ntypedef const __xip_fpo_fix_struct *xip_fpo_fix_srcptr;\n\n/* Definition of exception flags - return type of most functions\n   Flags are as follows:\n   bit 0 : underflow\n   bit 1 : overflow\n   bit 2 : invalid operation\n   bit 3 : divide by zero\n   bit 4 : operation not supported\n   bit 5 : Accumulator Input Overflow\n   bit 6 : Accumulator Overflow\n   */\ntypedef int xip_fpo_exc_t;\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct xil_fpo_accum_state xil_fpo_accum_state;\n\n/* Information functions */\n__XIP_FPO_DLL const char * xip_fpo_get_version (void);\n\n/* Initialization functions */\n__XIP_FPO_DLL void xip_fpo_init2        (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);\n__XIP_FPO_DLL void xip_fpo_fix_init2    (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);\n__XIP_FPO_DLL void xip_fpo_inits2       (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_ptr, ...) __XIP_FPO_SENTINEL_ATTR;\n__XIP_FPO_DLL void xip_fpo_fix_inits2   (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_fix_ptr, ...) __XIP_FPO_SENTINEL_ATTR;\n__XIP_FPO_DLL void xip_fpo_clear        (xip_fpo_ptr);\n__XIP_FPO_DLL void xip_fpo_fix_clear    (xip_fpo_fix_ptr);\n__XIP_FPO_DLL void xip_fpo_clears       (xip_fpo_ptr, ...) __XIP_FPO_SENTINEL_ATTR;\n__XIP_FPO_DLL void xip_fpo_fix_clears   (xip_fpo_fix_ptr, ...) __XIP_FPO_SENTINEL_ATTR;\n__XIP_FPO_DLL void xip_fpo_set_prec     (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);\n__XIP_FPO_DLL void xip_fpo_fix_set_prec (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);\n__XIP_FPO_DLL xip_fpo_prec_t xip_fpo_get_prec_mant     (xip_fpo_ptr);\n__XIP_FPO_DLL xip_fpo_prec_t xip_fpo_get_prec_exp      (xip_fpo_ptr);\n__XIP_FPO_DLL xip_fpo_prec_t xip_fpo_fix_get_prec_frac (xip_fpo_fix_ptr);\n__XIP_FPO_DLL xip_fpo_prec_t xip_fpo_fix_get_prec_int  (xip_fpo_fix_ptr);\n\n/* Assignment functions */\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set         (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set     (xip_fpo_fix_ptr, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_ui      (xip_fpo_ptr, unsigned long);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_ui  (xip_fpo_fix_ptr, unsigned long);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_si      (xip_fpo_ptr, long);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_si  (xip_fpo_fix_ptr, long);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_uj      (xip_fpo_ptr, uintmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_uj  (xip_fpo_fix_ptr, uintmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_sj      (xip_fpo_ptr, intmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_sj  (xip_fpo_fix_ptr, intmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_flt     (xip_fpo_ptr, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_flt (xip_fpo_fix_ptr, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_d       (xip_fpo_ptr, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_d   (xip_fpo_fix_ptr, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_z       (xip_fpo_ptr, mpz_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_z   (xip_fpo_fix_ptr, mpz_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_q       (xip_fpo_ptr, mpq_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_q   (xip_fpo_fix_ptr, mpq_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_f       (xip_fpo_ptr, mpf_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_f   (xip_fpo_fix_ptr, mpf_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_fr      (xip_fpo_ptr, mpfr_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_fr  (xip_fpo_fix_ptr, mpfr_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_ui_2exp (xip_fpo_ptr, unsigned long, xip_fpo_exp_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_si_2exp (xip_fpo_ptr, long, xip_fpo_exp_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_uj_2exp (xip_fpo_ptr, uintmax_t, intmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_sj_2exp (xip_fpo_ptr, intmax_t, intmax_t);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_set_str     (xip_fpo_ptr, const char *, int);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_set_str (xip_fpo_fix_ptr, const char *, int);\n__XIP_FPO_DLL void          xip_fpo_set_nan     (xip_fpo_ptr);\n__XIP_FPO_DLL void          xip_fpo_set_inf     (xip_fpo_ptr, int);\n__XIP_FPO_DLL void          xip_fpo_set_zero    (xip_fpo_ptr, int);\n\n/* Conversion functions */\n__XIP_FPO_DLL unsigned long xip_fpo_get_ui         (xip_fpo_srcptr);\n__XIP_FPO_DLL unsigned long xip_fpo_fix_get_ui     (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL long          xip_fpo_get_si         (xip_fpo_srcptr);\n__XIP_FPO_DLL long          xip_fpo_fix_get_si     (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL uintmax_t     xip_fpo_get_uj         (xip_fpo_srcptr);\n__XIP_FPO_DLL uintmax_t     xip_fpo_fix_get_uj     (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL intmax_t      xip_fpo_get_sj         (xip_fpo_srcptr);\n__XIP_FPO_DLL intmax_t      xip_fpo_fix_get_sj     (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL float         xip_fpo_get_flt        (xip_fpo_srcptr);\n__XIP_FPO_DLL float         xip_fpo_fix_get_flt    (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL double        xip_fpo_get_d          (xip_fpo_srcptr);\n__XIP_FPO_DLL double        xip_fpo_fix_get_d      (xip_fpo_fix_srcptr);\n__XIP_FPO_DLL double        xip_fpo_get_d_2exp     (long *, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_get_z          (mpz_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_get_z      (mpz_ptr, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_get_f          (mpf_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_get_f      (mpf_ptr, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_get_fr         (mpfr_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fix_get_fr     (mpfr_ptr, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL char *        xip_fpo_get_str        (char *, xip_fpo_exp_t *, int, int, xip_fpo_srcptr);\n__XIP_FPO_DLL char *        xip_fpo_fix_get_str    (char *, int, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL void          xip_fpo_free_str       (char *);\n__XIP_FPO_DLL void          xip_fpo_fix_free_str   (char *);\n__XIP_FPO_DLL int           xip_fpo_sizeinbase     (xip_fpo_srcptr, int);\n__XIP_FPO_DLL int           xip_fpo_fix_sizeinbase (xip_fpo_fix_srcptr, int);\n\n/* Operation functions */\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_add                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_add_flt                    (float *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_add_d                      (double *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sub                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sub_flt                    (float *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sub_d                      (double *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_mul                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_mul_flt                    (float *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_mul_d                      (double *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fma                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fma_flt                    (float *, float, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fma_d                      (double *, double, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fms                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fms_flt                    (float *, float, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fms_d                      (double *, double, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_div                        (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_div_flt                    (float *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_div_d                      (double *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_rec                        (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_rec_flt                    (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_rec_d                      (double *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_abs                        (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_abs_flt                    (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_abs_d                      (double *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_log                        (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_log_flt                    (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_log_d                      (double *, double);\n__XIP_FPO_DLL int           xip_fpo_exp_array                  (xip_fpo_t * , xip_fpo_t * , xip_fpo_exc_t *, unsigned long long);\n__XIP_FPO_DLL void          xip_fpo_exp_flt_array              (float  *    , float     * , xip_fpo_exc_t *, unsigned long long);\n__XIP_FPO_DLL void          xip_fpo_exp_d_array                (double *    , double    * , xip_fpo_exc_t *, unsigned long long);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_exp                        (xip_fpo_ptr , xip_fpo_srcptr                    );\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_exp_flt                    (float  *    , float                             );\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_exp_d                      (double *    , double                            );\n__XIP_FPO_DLL struct xil_fpo_accum_state * xip_fpo_accum_create_state (int , int , int , int , int);\n__XIP_FPO_DLL void xip_fpo_accum_reset_state                   (struct xil_fpo_accum_state *);\n__XIP_FPO_DLL void xip_fpo_accum_destroy_state                 (struct xil_fpo_accum_state *);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_accum_sample               (xip_fpo_t, xip_fpo_t, bool, struct xil_fpo_accum_state *);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_accum_sample_flt           (float   *, float    , bool, struct xil_fpo_accum_state *);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_accum_sample_d             (double  *, double   , bool, struct xil_fpo_accum_state *);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sqrt                       (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sqrt_flt                   (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_sqrt_d                     (double *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_recsqrt                    (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_recsqrt_flt                (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_recsqrt_d                  (double *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_unordered                  (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_unordered_flt              (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_unordered_d                (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_equal                      (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_equal_flt                  (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_equal_d                    (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_less                       (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_less_flt                   (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_less_d                     (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_lessequal                  (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_lessequal_flt              (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_lessequal_d                (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greater                    (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greater_flt                (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greater_d                  (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greaterequal               (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greaterequal_flt           (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_greaterequal_d             (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_notequal                   (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_notequal_flt               (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_notequal_d                 (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_condcode                   (int *, xip_fpo_srcptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_condcode_flt               (int *, float, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_condcode_d                 (int *, double, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttofix                   (xip_fpo_fix_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttofix_int_flt           (int *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttofix_int_d             (int *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fixtoflt                   (xip_fpo_ptr, xip_fpo_fix_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fixtoflt_flt_int           (float *, int);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_fixtoflt_d_int             (double *, int);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttoflt                   (xip_fpo_ptr, xip_fpo_srcptr);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttoflt_flt_flt           (float *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttoflt_flt_d             (float *, double);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttoflt_d_flt             (double *, float);\n__XIP_FPO_DLL xip_fpo_exc_t xip_fpo_flttoflt_d_d               (double *, double);\n\n#ifdef  __cplusplus\n} /* End of \"C\" linkage block */\n#endif\n\n#endif // __xip_fpo_bitacc_cmodel_h\n\n",
    "mpfr.h": "/* mpfr.h -- Include file for mpfr.\n\nCopyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\nContributed by the Arenaire and Cacao projects, INRIA.\n\nThis file is part of the GNU MPFR Library.\n\nThe GNU MPFR Library is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or (at your\noption) any later version.\n\nThe GNU MPFR Library is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\nLicense for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with the GNU MPFR Library; see the file COPYING.LESSER.  If not, see\nhttp://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,\n51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. */\n\n#ifndef __MPFR_H\n#define __MPFR_H\n\n/* Define MPFR version number */\n#define MPFR_VERSION_MAJOR 3\n#define MPFR_VERSION_MINOR 0\n#define MPFR_VERSION_PATCHLEVEL 1\n#define MPFR_VERSION_STRING \"3.0.1-p4\"\n\n/* Macros dealing with MPFR VERSION */\n#define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))\n#define MPFR_VERSION \\\nMPFR_VERSION_NUM(MPFR_VERSION_MAJOR,MPFR_VERSION_MINOR,MPFR_VERSION_PATCHLEVEL)\n\n/* Check if GMP is included, and try to include it (Works with local GMP) */\n#ifndef __GMP_H__\n# include <gmp.h>\n#endif\n\n/* Check if stdio.h is included or if the user wants FILE */\n#if defined (_GMP_H_HAVE_FILE) || defined (MPFR_USE_FILE)\n# define _MPFR_H_HAVE_FILE 1\n#endif\n\n#if defined (_GMP_H_HAVE_VA_LIST)\n# define _MPFR_H_HAVE_VA_LIST 1\n#endif\n\n/* Check if <stdint.h> / <inttypes.h> is included or if the user\n   explicitly wants intmax_t. Automatical detection is done by\n   checking:\n     - INTMAX_C and UINTMAX_C, but not if the compiler is a C++ one\n       (as suggested by Patrick Pelissier) because the test does not\n       work well in this case. See:\n         http://websympa.loria.fr/wwsympa/arc/mpfr/2010-02/msg00025.html\n       We do not check INTMAX_MAX and UINTMAX_MAX because under Solaris,\n       these macros are always defined by <limits.h> (i.e. even when\n       <stdint.h> and <inttypes.h> are not included).\n     - _STDINT_H (defined by the glibc) and _STDINT_H_ (defined under\n       Mac OS X), but this test may not work with all implementations.\n       Portable software should not rely on these tests.\n*/\n#if (defined (INTMAX_C) && defined (UINTMAX_C) && !defined(__cplusplus)) || \\\n  defined (MPFR_USE_INTMAX_T) || defined (_STDINT_H) || defined (_STDINT_H_)\n# define _MPFR_H_HAVE_INTMAX_T 1\n#endif\n\n/* Avoid some problems with macro expansion if the user defines macros\n   with the same name as keywords. By convention, identifiers and macro\n   names starting with mpfr_ are reserved by MPFR. */\ntypedef void            mpfr_void;\ntypedef int             mpfr_int;\ntypedef unsigned int    mpfr_uint;\ntypedef long            mpfr_long;\ntypedef unsigned long   mpfr_ulong;\ntypedef size_t          mpfr_size_t;\n\n/* Definition of rounding modes (DON'T USE MPFR_RNDNA!).\n   Warning! Changing the contents of this enum should be seen as an\n   interface change since the old and the new types are not compatible\n   (the integer type compatible with the enumerated type can even change,\n   see ISO C99, 6.7.2.2#4), and in Makefile.am, AGE should be set to 0.\n\n   MPFR_RNDU must appear just before MPFR_RNDD (see\n   MPFR_IS_RNDUTEST_OR_RNDDNOTTEST in mpfr-impl.h).\n\n   MPFR_RNDF has been added, though not implemented yet, in order to avoid\n   to break the ABI once faithful rounding gets implemented.\n\n   If you change the order of the rounding modes, please update the routines\n   in texceptions.c which assume 0=RNDN, 1=RNDZ, 2=RNDU, 3=RNDD, 4=RNDA.\n*/\ntypedef enum {\n  MPFR_RNDN=0,  /* round to nearest, with ties to even */\n  MPFR_RNDZ,    /* round toward zero */\n  MPFR_RNDU,    /* round toward +Inf */\n  MPFR_RNDD,    /* round toward -Inf */\n  MPFR_RNDA,    /* round away from zero */\n  MPFR_RNDF,    /* faithful rounding (not implemented yet) */\n  MPFR_RNDNA=-1 /* round to nearest, with ties away from zero (mpfr_round) */\n} mpfr_rnd_t;\n\n/* kept for compatibility with MPFR 2.4.x and before */\n#define GMP_RNDN MPFR_RNDN\n#define GMP_RNDZ MPFR_RNDZ\n#define GMP_RNDU MPFR_RNDU\n#define GMP_RNDD MPFR_RNDD\n\n/* Define precision : 1 (short), 2 (int) or 3 (long) (DON'T USE IT!)*/\n#ifndef _MPFR_PREC_FORMAT\n# if __GMP_MP_SIZE_T_INT == 1\n#  define _MPFR_PREC_FORMAT 2\n# else\n#  define _MPFR_PREC_FORMAT 3\n# endif\n#endif\n\n/* Let's make mpfr_prec_t signed in order to avoid problems due to the\n   usual arithmetic conversions when mixing mpfr_prec_t and mpfr_exp_t\n   in an expression (for error analysis) if casts are forgotten. */\n#if   _MPFR_PREC_FORMAT == 1\ntypedef short mpfr_prec_t;\ntypedef unsigned short mpfr_uprec_t;\n#elif _MPFR_PREC_FORMAT == 2\ntypedef int   mpfr_prec_t;\ntypedef unsigned int   mpfr_uprec_t;\n#elif _MPFR_PREC_FORMAT == 3\ntypedef long  mpfr_prec_t;\ntypedef unsigned long  mpfr_uprec_t;\n#else\n# error \"Invalid MPFR Prec format\"\n#endif\n\n/* Definition of precision limits without needing <limits.h> */\n/* Note: the casts allows the expression to yield the wanted behavior\n   for _MPFR_PREC_FORMAT == 1 (due to integer promotion rules). */\n#define MPFR_PREC_MIN 2\n#define MPFR_PREC_MAX ((mpfr_prec_t)((mpfr_uprec_t)(~(mpfr_uprec_t)0)>>1))\n\n/* Definition of sign */\ntypedef int          mpfr_sign_t;\n\n/* Definition of the exponent: same as in GMP. */\ntypedef mp_exp_t     mpfr_exp_t;\n\n/* Definition of the standard exponent limits */\n#define MPFR_EMAX_DEFAULT ((mpfr_exp_t) (((mpfr_ulong) 1 << 30) - 1))\n#define MPFR_EMIN_DEFAULT (-(MPFR_EMAX_DEFAULT))\n\n/* Definition of the main structure */\ntypedef struct {\n  mpfr_prec_t  _mpfr_prec;\n  mpfr_sign_t  _mpfr_sign;\n  mpfr_exp_t   _mpfr_exp;\n  mp_limb_t   *_mpfr_d;\n} __mpfr_struct;\n\n/* Compatibility with previous types of MPFR */\n#ifndef mp_rnd_t\n# define mp_rnd_t  mpfr_rnd_t\n#endif\n#ifndef mp_prec_t\n# define mp_prec_t mpfr_prec_t\n#endif\n\n/*\n   The represented number is\n      _sign*(_d[k-1]/B+_d[k-2]/B^2+...+_d[0]/B^k)*2^_exp\n   where k=ceil(_mp_prec/GMP_NUMB_BITS) and B=2^GMP_NUMB_BITS.\n\n   For the msb (most significant bit) normalized representation, we must have\n      _d[k-1]>=B/2, unless the number is singular.\n\n   We must also have the last k*GMP_NUMB_BITS-_prec bits set to zero.\n*/\n\ntypedef __mpfr_struct mpfr_t[1];\ntypedef __mpfr_struct *mpfr_ptr;\ntypedef __gmp_const __mpfr_struct *mpfr_srcptr;\n\n/* For those who need a direct and fast access to the sign field.\n   However it is not in the API, thus use it at your own risk: it might\n   not be supported, or change name, in further versions!\n   Unfortunately, it must be defined here (instead of MPFR's internal\n   header file mpfr-impl.h) because it is used by some macros below.\n*/\n#define MPFR_SIGN(x) ((x)->_mpfr_sign)\n\n/* Stack interface */\ntypedef enum {\n  MPFR_NAN_KIND = 0,\n  MPFR_INF_KIND = 1, MPFR_ZERO_KIND = 2, MPFR_REGULAR_KIND = 3\n} mpfr_kind_t;\n\n/* GMP defines:\n    + size_t:                Standard size_t\n    + __GMP_ATTRIBUTE_PURE   Attribute for math functions.\n    + __GMP_NOTHROW          For C++: can't throw .\n    + __GMP_EXTERN_INLINE    Attribute for inline function.\n    * __gmp_const            const (Supports for K&R compiler only for mpfr.h).\n    + __GMP_DECLSPEC_EXPORT  compiling to go into a DLL\n    + __GMP_DECLSPEC_IMPORT  compiling to go into a application\n*/\n/* Extra MPFR defines */\n#define __MPFR_SENTINEL_ATTR\n#if defined (__GNUC__)\n# if __GNUC__ >= 4\n#  undef __MPFR_SENTINEL_ATTR\n#  define __MPFR_SENTINEL_ATTR __attribute__ ((sentinel))\n# endif\n#endif\n\n/* Prototypes: Support of K&R compiler */\n#if defined (__GMP_PROTO)\n# define _MPFR_PROTO __GMP_PROTO\n#elif defined (__STDC__) || defined (__cplusplus)\n# define _MPFR_PROTO(x) x\n#else\n# define _MPFR_PROTO(x) ()\n#endif\n/* Support for WINDOWS Dll:\n   Check if we are inside a MPFR build, and if so export the functions.\n   Otherwise does the same thing as GMP */\n#if defined(__MPFR_WITHIN_MPFR) && __GMP_LIBGMP_DLL\n# define __MPFR_DECLSPEC __GMP_DECLSPEC_EXPORT\n#else\n# define __MPFR_DECLSPEC __GMP_DECLSPEC\n#endif\n\n/* Note: In order to be declared, some functions need a specific\n   system header to be included *before* \"mpfr.h\". If the user\n   forgets to include the header, the MPFR function prototype in\n   the user object file is not correct. To avoid wrong results,\n   we raise a linker error in that case by changing their internal\n   name in the library (prefixed by __gmpfr instead of mpfr). See\n   the lines of the form \"#define mpfr_xxx __gmpfr_xxx\" below. */\n\n#if defined (__cplusplus)\nextern \"C\" {\n#endif\n\n__MPFR_DECLSPEC __gmp_const char * mpfr_get_version _MPFR_PROTO ((void));\n__MPFR_DECLSPEC __gmp_const char * mpfr_get_patches _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_buildopt_tls_p     _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_buildopt_decimal_p _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emin     _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int        mpfr_set_emin     _MPFR_PROTO ((mpfr_exp_t));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emin_min _MPFR_PROTO ((void));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emin_max _MPFR_PROTO ((void));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emax     _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int        mpfr_set_emax     _MPFR_PROTO ((mpfr_exp_t));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emax_min _MPFR_PROTO ((void));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_emax_max _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC void mpfr_set_default_rounding_mode _MPFR_PROTO((mpfr_rnd_t));\n__MPFR_DECLSPEC mpfr_rnd_t mpfr_get_default_rounding_mode _MPFR_PROTO((void));\n__MPFR_DECLSPEC __gmp_const char *\n   mpfr_print_rnd_mode _MPFR_PROTO((mpfr_rnd_t));\n\n__MPFR_DECLSPEC void mpfr_clear_flags _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_clear_underflow _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_clear_overflow _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_clear_nanflag _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_clear_inexflag _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_clear_erangeflag _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC void mpfr_set_underflow _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_set_overflow _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_set_nanflag _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_set_inexflag _MPFR_PROTO ((void));\n__MPFR_DECLSPEC void mpfr_set_erangeflag _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC int mpfr_underflow_p _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_overflow_p _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_nanflag_p _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_inexflag_p _MPFR_PROTO ((void));\n__MPFR_DECLSPEC int mpfr_erangeflag_p _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC int\n  mpfr_check_range _MPFR_PROTO ((mpfr_ptr, int, mpfr_rnd_t));\n\n__MPFR_DECLSPEC void mpfr_init2 _MPFR_PROTO ((mpfr_ptr, mpfr_prec_t));\n__MPFR_DECLSPEC void mpfr_init _MPFR_PROTO ((mpfr_ptr));\n__MPFR_DECLSPEC void mpfr_clear _MPFR_PROTO ((mpfr_ptr));\n\n__MPFR_DECLSPEC void\n  mpfr_inits2 _MPFR_PROTO ((mpfr_prec_t, mpfr_ptr, ...)) __MPFR_SENTINEL_ATTR;\n__MPFR_DECLSPEC void\n  mpfr_inits _MPFR_PROTO ((mpfr_ptr, ...)) __MPFR_SENTINEL_ATTR;\n__MPFR_DECLSPEC void\n  mpfr_clears _MPFR_PROTO ((mpfr_ptr, ...)) __MPFR_SENTINEL_ATTR;\n\n__MPFR_DECLSPEC int\n  mpfr_prec_round _MPFR_PROTO ((mpfr_ptr, mpfr_prec_t, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_can_round _MPFR_PROTO ((mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t,\n                               mpfr_prec_t));\n__MPFR_DECLSPEC mpfr_prec_t mpfr_min_prec _MPFR_PROTO ((mpfr_srcptr));\n\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_exp _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_set_exp _MPFR_PROTO ((mpfr_ptr, mpfr_exp_t));\n__MPFR_DECLSPEC mpfr_prec_t mpfr_get_prec _MPFR_PROTO((mpfr_srcptr));\n__MPFR_DECLSPEC void mpfr_set_prec _MPFR_PROTO((mpfr_ptr, mpfr_prec_t));\n__MPFR_DECLSPEC void mpfr_set_prec_raw _MPFR_PROTO((mpfr_ptr, mpfr_prec_t));\n__MPFR_DECLSPEC void mpfr_set_default_prec _MPFR_PROTO((mpfr_prec_t));\n__MPFR_DECLSPEC mpfr_prec_t mpfr_get_default_prec _MPFR_PROTO((void));\n\n__MPFR_DECLSPEC int mpfr_set_d _MPFR_PROTO ((mpfr_ptr, double, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_set_flt _MPFR_PROTO ((mpfr_ptr, float, mpfr_rnd_t));\n#ifdef MPFR_WANT_DECIMAL_FLOATS\n__MPFR_DECLSPEC int mpfr_set_decimal64 _MPFR_PROTO ((mpfr_ptr, _Decimal64,\n                                                     mpfr_rnd_t));\n#endif\n__MPFR_DECLSPEC int\n  mpfr_set_ld _MPFR_PROTO ((mpfr_ptr, long double, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_z _MPFR_PROTO ((mpfr_ptr, mpz_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_z_2exp _MPFR_PROTO ((mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t));\n__MPFR_DECLSPEC void mpfr_set_nan _MPFR_PROTO ((mpfr_ptr));\n__MPFR_DECLSPEC void mpfr_set_inf _MPFR_PROTO ((mpfr_ptr, int));\n__MPFR_DECLSPEC void mpfr_set_zero _MPFR_PROTO ((mpfr_ptr, int));\n__MPFR_DECLSPEC int\n  mpfr_set_f _MPFR_PROTO ((mpfr_ptr, mpf_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_get_f _MPFR_PROTO ((mpf_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_set_si _MPFR_PROTO ((mpfr_ptr, long, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_ui _MPFR_PROTO ((mpfr_ptr, unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_si_2exp _MPFR_PROTO ((mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_ui_2exp _MPFR_PROTO ((mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_q _MPFR_PROTO ((mpfr_ptr, mpq_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_str _MPFR_PROTO ((mpfr_ptr, __gmp_const char *, int, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_init_set_str _MPFR_PROTO ((mpfr_ptr, __gmp_const char *, int,\n                                  mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set4 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int));\n__MPFR_DECLSPEC int\n  mpfr_abs _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_neg _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_signbit _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC int\n  mpfr_setsign _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_copysign _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t));\n\n#ifdef _MPFR_H_HAVE_INTMAX_T\n#define mpfr_set_sj __gmpfr_set_sj\n#define mpfr_set_sj_2exp __gmpfr_set_sj_2exp\n#define mpfr_set_uj __gmpfr_set_uj\n#define mpfr_set_uj_2exp __gmpfr_set_uj_2exp\n#define mpfr_get_sj __gmpfr_mpfr_get_sj\n#define mpfr_get_uj __gmpfr_mpfr_get_uj\n__MPFR_DECLSPEC int mpfr_set_sj _MPFR_PROTO ((mpfr_t, intmax_t, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_sj_2exp _MPFR_PROTO ((mpfr_t, intmax_t, intmax_t, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_set_uj _MPFR_PROTO ((mpfr_t, uintmax_t, mpfr_rnd_t));\n__MPFR_DECLSPEC int\n  mpfr_set_uj_2exp _MPFR_PROTO ((mpfr_t, uintmax_t, intmax_t, mpfr_rnd_t));\n__MPFR_DECLSPEC intmax_t mpfr_get_sj _MPFR_PROTO ((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC uintmax_t mpfr_get_uj _MPFR_PROTO ((mpfr_srcptr, mpfr_rnd_t));\n#endif\n\n__MPFR_DECLSPEC mpfr_exp_t mpfr_get_z_2exp _MPFR_PROTO ((mpz_ptr, mpfr_srcptr));\n__MPFR_DECLSPEC float mpfr_get_flt _MPFR_PROTO ((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC double mpfr_get_d _MPFR_PROTO ((mpfr_srcptr, mpfr_rnd_t));\n#ifdef MPFR_WANT_DECIMAL_FLOATS\n__MPFR_DECLSPEC _Decimal64 mpfr_get_decimal64 _MPFR_PROTO ((mpfr_srcptr,\n                                                           mpfr_rnd_t));\n#endif\n__MPFR_DECLSPEC long double mpfr_get_ld _MPFR_PROTO ((mpfr_srcptr,\n                                                      mpfr_rnd_t));\n__MPFR_DECLSPEC double mpfr_get_d1 _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC double mpfr_get_d_2exp _MPFR_PROTO ((long*, mpfr_srcptr,\n                                                     mpfr_rnd_t));\n__MPFR_DECLSPEC long double mpfr_get_ld_2exp _MPFR_PROTO ((long*, mpfr_srcptr,\n                                                           mpfr_rnd_t));\n__MPFR_DECLSPEC long mpfr_get_si _MPFR_PROTO ((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC unsigned long mpfr_get_ui _MPFR_PROTO ((mpfr_srcptr,\n                                                        mpfr_rnd_t));\n__MPFR_DECLSPEC char*mpfr_get_str _MPFR_PROTO ((char*, mpfr_exp_t*, int, size_t,\n                                                mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_get_z _MPFR_PROTO ((mpz_ptr z, mpfr_srcptr f,\n                                             mpfr_rnd_t));\n\n__MPFR_DECLSPEC void mpfr_free_str _MPFR_PROTO ((char *));\n\n__MPFR_DECLSPEC int mpfr_urandom _MPFR_PROTO ((mpfr_ptr, gmp_randstate_t,\n                                               mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_urandomb _MPFR_PROTO ((mpfr_ptr, gmp_randstate_t));\n\n__MPFR_DECLSPEC void mpfr_nextabove _MPFR_PROTO ((mpfr_ptr));\n__MPFR_DECLSPEC void mpfr_nextbelow _MPFR_PROTO ((mpfr_ptr));\n__MPFR_DECLSPEC void mpfr_nexttoward _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr));\n\n#ifdef _MPFR_H_HAVE_FILE\n#define mpfr_inp_str __gmpfr_inp_str\n#define mpfr_out_str __gmpfr_out_str\n__MPFR_DECLSPEC size_t mpfr_inp_str _MPFR_PROTO ((mpfr_ptr, FILE*, int,\n                                                  mpfr_rnd_t));\n__MPFR_DECLSPEC size_t mpfr_out_str _MPFR_PROTO ((FILE*, int, size_t,\n                                                  mpfr_srcptr, mpfr_rnd_t));\n#define mpfr_fprintf __gmpfr_fprintf\n__MPFR_DECLSPEC int mpfr_fprintf _MPFR_PROTO ((FILE*, __gmp_const char*,\n                                               ...));\n#endif\n__MPFR_DECLSPEC int mpfr_printf _MPFR_PROTO ((__gmp_const char*, ...));\n__MPFR_DECLSPEC int mpfr_asprintf _MPFR_PROTO ((char**, __gmp_const char*,\n                                                ...));\n__MPFR_DECLSPEC int mpfr_sprintf _MPFR_PROTO ((char*, __gmp_const char*,\n                                               ...));\n__MPFR_DECLSPEC int mpfr_snprintf _MPFR_PROTO ((char*, size_t,\n                                                __gmp_const char*, ...));\n\n#ifdef _MPFR_H_HAVE_VA_LIST\n#ifdef _MPFR_H_HAVE_FILE\n#define mpfr_vfprintf __gmpfr_vfprintf\n__MPFR_DECLSPEC int mpfr_vfprintf _MPFR_PROTO ((FILE*, __gmp_const char*,\n                                                va_list));\n#endif /* _MPFR_H_HAVE_FILE */\n#define mpfr_vprintf __gmpfr_vprintf\n#define mpfr_vasprintf __gmpfr_vasprintf\n#define mpfr_vsprintf __gmpfr_vsprintf\n#define mpfr_vsnprintf __gmpfr_vsnprintf\n__MPFR_DECLSPEC int mpfr_vprintf _MPFR_PROTO ((__gmp_const char*, va_list));\n__MPFR_DECLSPEC int mpfr_vasprintf _MPFR_PROTO ((char**, __gmp_const char*,\n                                                 va_list));\n__MPFR_DECLSPEC int mpfr_vsprintf _MPFR_PROTO ((char*, __gmp_const char*,\n                                               va_list));\n__MPFR_DECLSPEC int mpfr_vsnprintf _MPFR_PROTO ((char*, size_t,\n                                                __gmp_const char*, va_list));\n#endif /* _MPFR_H_HAVE_VA_LIST */\n\n__MPFR_DECLSPEC int mpfr_pow _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_pow_si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_pow_ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              unsigned long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_ui_pow_ui _MPFR_PROTO ((mpfr_ptr, unsigned long int,\n                                             unsigned long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_ui_pow _MPFR_PROTO ((mpfr_ptr, unsigned long int,\n                                              mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_pow_z _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpz_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_sqrt _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                            mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sqrt_ui _MPFR_PROTO ((mpfr_ptr, unsigned long,\n                                               mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_rec_sqrt _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_add _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_add_ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub_ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_ui_sub _MPFR_PROTO ((mpfr_ptr, unsigned long,\n                                              mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul_ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_ui_div _MPFR_PROTO ((mpfr_ptr, unsigned long,\n                                              mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_add_si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub_si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_si_sub _MPFR_PROTO ((mpfr_ptr, long int,\n                                              mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul_si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              long int, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_si_div _MPFR_PROTO ((mpfr_ptr, long int,\n                                              mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_add_d _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              double, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub_d _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              double, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_d_sub _MPFR_PROTO ((mpfr_ptr, double,\n                                              mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul_d _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              double, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_d _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                              double, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_d_div _MPFR_PROTO ((mpfr_ptr, double,\n                                              mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_sqr _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_const_pi _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_const_log2 _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_const_euler _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_const_catalan _MPFR_PROTO ((mpfr_ptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_agm _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_log _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_log2 _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_log10 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_log1p _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_exp _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_exp2 _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_exp10 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_expm1 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_eint _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_li2 _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_cmp  _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_cmp3 _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr, int));\n__MPFR_DECLSPEC int mpfr_cmp_d _MPFR_PROTO ((mpfr_srcptr, double));\n__MPFR_DECLSPEC int mpfr_cmp_ld _MPFR_PROTO ((mpfr_srcptr, long double));\n__MPFR_DECLSPEC int mpfr_cmpabs _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_cmp_ui _MPFR_PROTO ((mpfr_srcptr, unsigned long));\n__MPFR_DECLSPEC int mpfr_cmp_si _MPFR_PROTO ((mpfr_srcptr, long));\n__MPFR_DECLSPEC int mpfr_cmp_ui_2exp _MPFR_PROTO ((mpfr_srcptr, unsigned long,\n                                                   mpfr_exp_t));\n__MPFR_DECLSPEC int mpfr_cmp_si_2exp _MPFR_PROTO ((mpfr_srcptr, long,\n                                                   mpfr_exp_t));\n__MPFR_DECLSPEC void mpfr_reldiff _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_eq _MPFR_PROTO((mpfr_srcptr, mpfr_srcptr,\n                                         unsigned long));\n__MPFR_DECLSPEC int mpfr_sgn _MPFR_PROTO ((mpfr_srcptr));\n\n__MPFR_DECLSPEC int mpfr_mul_2exp _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_2exp _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul_2ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                               unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_2ui _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                               unsigned long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_mul_2si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                               long, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_2si _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                               long, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_rint _MPFR_PROTO((mpfr_ptr,mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_round _MPFR_PROTO((mpfr_ptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_trunc _MPFR_PROTO((mpfr_ptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_ceil _MPFR_PROTO((mpfr_ptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_floor _MPFR_PROTO((mpfr_ptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_rint_round _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                  mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_rint_trunc _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                  mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_rint_ceil _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                 mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_rint_floor _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                  mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_frac _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_modf _MPFR_PROTO ((mpfr_ptr, mpfr_ptr, mpfr_srcptr,\n                                                  mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_remquo _MPFR_PROTO ((mpfr_ptr, long*, mpfr_srcptr,\n                                              mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_remainder _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                 mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fmod _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                                 mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_fits_ulong_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_slong_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_uint_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_sint_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_ushort_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_sshort_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_uintmax_p _MPFR_PROTO((mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fits_intmax_p _MPFR_PROTO((mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC void mpfr_extract _MPFR_PROTO ((mpz_ptr, mpfr_srcptr,\n                                                unsigned int));\n__MPFR_DECLSPEC void mpfr_swap _MPFR_PROTO ((mpfr_ptr, mpfr_ptr));\n__MPFR_DECLSPEC void mpfr_dump _MPFR_PROTO ((mpfr_srcptr));\n\n__MPFR_DECLSPEC int mpfr_nan_p _MPFR_PROTO((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_inf_p _MPFR_PROTO((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_number_p _MPFR_PROTO((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_integer_p _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_zero_p _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_regular_p _MPFR_PROTO ((mpfr_srcptr));\n\n__MPFR_DECLSPEC int mpfr_greater_p _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_greaterequal_p _MPFR_PROTO ((mpfr_srcptr,\n                                                      mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_less_p _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_lessequal_p _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_lessgreater_p _MPFR_PROTO((mpfr_srcptr,mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_equal_p _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n__MPFR_DECLSPEC int mpfr_unordered_p _MPFR_PROTO ((mpfr_srcptr, mpfr_srcptr));\n\n__MPFR_DECLSPEC int mpfr_atanh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_acosh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_asinh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cosh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sinh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_tanh _MPFR_PROTO((mpfr_ptr,mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sinh_cosh _MPFR_PROTO ((mpfr_ptr, mpfr_ptr,\n                                               mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_sech _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_csch _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_coth _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_acos _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_asin _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_atan _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sin _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sin_cos _MPFR_PROTO ((mpfr_ptr, mpfr_ptr,\n                                               mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cos _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_tan _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_atan2 _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_srcptr,\n                                             mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sec _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_csc _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cot _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_hypot _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_erf _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_erfc _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cbrt _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_root _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_gamma _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_lngamma _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_lgamma _MPFR_PROTO((mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_digamma _MPFR_PROTO((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_zeta _MPFR_PROTO ((mpfr_ptr,mpfr_srcptr,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_zeta_ui _MPFR_PROTO ((mpfr_ptr,unsigned long,mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fac_ui _MPFR_PROTO ((mpfr_ptr, unsigned long int,\n                                              mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_j0 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_j1 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_jn _MPFR_PROTO ((mpfr_ptr, long, mpfr_srcptr,\n                                          mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_y0 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_y1 _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_yn _MPFR_PROTO ((mpfr_ptr, long, mpfr_srcptr,\n                                          mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_ai _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_min _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_max _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_dim _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_rnd_t));\n\n__MPFR_DECLSPEC int mpfr_mul_z _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpz_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_z _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpz_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_add_z _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpz_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub_z _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpz_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cmp_z _MPFR_PROTO ((mpfr_srcptr, mpz_srcptr));\n\n__MPFR_DECLSPEC int mpfr_mul_q _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpq_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_div_q _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpq_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_add_q _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpq_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sub_q _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr,\n                                             mpq_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_cmp_q _MPFR_PROTO ((mpfr_srcptr, mpq_srcptr));\n\n__MPFR_DECLSPEC int mpfr_cmp_f _MPFR_PROTO ((mpfr_srcptr, mpf_srcptr));\n\n__MPFR_DECLSPEC int mpfr_fma _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_fms _MPFR_PROTO ((mpfr_ptr, mpfr_srcptr, mpfr_srcptr,\n                                           mpfr_srcptr, mpfr_rnd_t));\n__MPFR_DECLSPEC int mpfr_sum _MPFR_PROTO ((mpfr_ptr, mpfr_ptr *__gmp_const,\n                                           unsigned long, mpfr_rnd_t));\n\n__MPFR_DECLSPEC void mpfr_free_cache _MPFR_PROTO ((void));\n\n__MPFR_DECLSPEC int  mpfr_subnormalize _MPFR_PROTO ((mpfr_ptr, int,\n                                                     mpfr_rnd_t));\n\n__MPFR_DECLSPEC int  mpfr_strtofr _MPFR_PROTO ((mpfr_ptr, __gmp_const char *,\n                                                char **, int, mpfr_rnd_t));\n\n__MPFR_DECLSPEC size_t mpfr_custom_get_size   _MPFR_PROTO ((mpfr_prec_t));\n__MPFR_DECLSPEC void   mpfr_custom_init    _MPFR_PROTO ((void *, mpfr_prec_t));\n__MPFR_DECLSPEC void * mpfr_custom_get_significand _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC mpfr_exp_t mpfr_custom_get_exp  _MPFR_PROTO ((mpfr_srcptr));\n__MPFR_DECLSPEC void   mpfr_custom_move       _MPFR_PROTO ((mpfr_ptr, void *));\n__MPFR_DECLSPEC void   mpfr_custom_init_set   _MPFR_PROTO ((mpfr_ptr, int,\n                                             mpfr_exp_t, mpfr_prec_t, void *));\n__MPFR_DECLSPEC int    mpfr_custom_get_kind   _MPFR_PROTO ((mpfr_srcptr));\n\n#if defined (__cplusplus)\n}\n#endif\n\n/* DON'T USE THIS! (For MPFR-public macros only, see below.)\n   The mpfr_sgn macro uses the fact that __MPFR_EXP_NAN and __MPFR_EXP_ZERO\n   are the smallest values.\n   FIXME: In the following macros, the cast of an unsigned type with MSB set\n   to the signed type mpfr_exp_t yields an integer overflow, which can give\n   unexpected results with future compilers and aggressive optimisations.\n   Why not working only with signed types, using INT_MIN and LONG_MIN? */\n#if __GMP_MP_SIZE_T_INT\n#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+2))\n#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+1))\n#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_uint)0)>>1))+3))\n#else\n#define __MPFR_EXP_NAN  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2))\n#define __MPFR_EXP_ZERO ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1))\n#define __MPFR_EXP_INF  ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3))\n#endif\n\n/* Define MPFR_USE_EXTENSION to avoid \"gcc -pedantic\" warnings. */\n#ifndef MPFR_EXTENSION\n# if defined(MPFR_USE_EXTENSION)\n#  define MPFR_EXTENSION __extension__\n# else\n#  define MPFR_EXTENSION\n# endif\n#endif\n\n/* Warning! This macro doesn't work with K&R C (e.g., compare the \"gcc -E\"\n   output with and without -traditional) and shouldn't be used internally.\n   For public use only, but see the MPFR manual. */\n#define MPFR_DECL_INIT(_x, _p)                                        \\\n  MPFR_EXTENSION mp_limb_t __gmpfr_local_tab_##_x[((_p)-1)/GMP_NUMB_BITS+1]; \\\n  MPFR_EXTENSION mpfr_t _x = {{(_p),1,__MPFR_EXP_NAN,__gmpfr_local_tab_##_x}}\n\n/* Fast access macros to replace function interface.\n   If the USER don't want to use the macro interface, let him make happy\n   even if it produces faster and smaller code. */\n#ifndef MPFR_USE_NO_MACRO\n\n/* Inlining theses functions is both faster and smaller */\n#define mpfr_nan_p(_x)      ((_x)->_mpfr_exp == __MPFR_EXP_NAN)\n#define mpfr_inf_p(_x)      ((_x)->_mpfr_exp == __MPFR_EXP_INF)\n#define mpfr_zero_p(_x)     ((_x)->_mpfr_exp == __MPFR_EXP_ZERO)\n#define mpfr_regular_p(_x)  ((_x)->_mpfr_exp >  __MPFR_EXP_INF)\n#define mpfr_sgn(_x)                                               \\\n  ((_x)->_mpfr_exp < __MPFR_EXP_INF ?                              \\\n   (mpfr_nan_p (_x) ? mpfr_set_erangeflag () : (mpfr_void) 0), 0 : \\\n   MPFR_SIGN (_x))\n\n/* Prevent them from using as lvalues */\n#define MPFR_VALUE_OF(x)  (0 ? (x) : (x))\n#define mpfr_get_prec(_x) MPFR_VALUE_OF((_x)->_mpfr_prec)\n#define mpfr_get_exp(_x)  MPFR_VALUE_OF((_x)->_mpfr_exp)\n/* Note: if need be, the MPFR_VALUE_OF can be used for other expressions\n   (of any type). Thanks to Wojtek Lerch and Tim Rentsch for the idea. */\n\n#define mpfr_round(a,b) mpfr_rint((a), (b), MPFR_RNDNA)\n#define mpfr_trunc(a,b) mpfr_rint((a), (b), MPFR_RNDZ)\n#define mpfr_ceil(a,b)  mpfr_rint((a), (b), MPFR_RNDU)\n#define mpfr_floor(a,b) mpfr_rint((a), (b), MPFR_RNDD)\n\n#define mpfr_cmp_ui(b,i) mpfr_cmp_ui_2exp((b),(i),0)\n#define mpfr_cmp_si(b,i) mpfr_cmp_si_2exp((b),(i),0)\n#define mpfr_set(a,b,r)  mpfr_set4(a,b,r,MPFR_SIGN(b))\n#define mpfr_abs(a,b,r)  mpfr_set4(a,b,r,1)\n#define mpfr_copysign(a,b,c,r) mpfr_set4(a,b,r,MPFR_SIGN(c))\n#define mpfr_setsign(a,b,s,r) mpfr_set4(a,b,r,(s) ? -1 : 1)\n#define mpfr_signbit(x)  (MPFR_SIGN(x) < 0)\n#define mpfr_cmp(b, c)   mpfr_cmp3(b, c, 1)\n#define mpfr_mul_2exp(y,x,n,r) mpfr_mul_2ui((y),(x),(n),(r))\n#define mpfr_div_2exp(y,x,n,r) mpfr_div_2ui((y),(x),(n),(r))\n\n\n/* When using GCC, optimize certain common comparisons and affectations.\n   + Remove ICC since it defines __GNUC__ but produces a\n     huge number of warnings if you use this code.\n     VL: I couldn't reproduce a single warning when enabling these macros\n     with icc 10.1 20080212 on Itanium. But with this version, __ICC isn't\n     defined (__INTEL_COMPILER is, though), so that these macros are enabled\n     anyway. Checking with other ICC versions is needed. Possibly detect\n     whether warnings are produced or not with a configure test.\n   + Remove C++ too, since it complains too much. */\n/* Added casts to improve robustness in case of undefined behavior and\n   compiler extensions based on UB (in particular -fwrapv). MPFR doesn't\n   use such extensions, but these macros will be used by 3rd-party code,\n   where such extensions may be required.\n   Moreover casts to unsigned long have been added to avoid warnings in\n   programs that use MPFR and are compiled with -Wconversion; such casts\n   are OK since if X is a constant expression, then (unsigned long) X is\n   also a constant expression, so that the optimizations still work. The\n   warnings are probably related to the following two bugs:\n     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=4210\n     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38470 (possibly a variant)\n   and the casts could be removed once these bugs are fixed.\n   Casts shouldn't be used on the generic calls (to the ..._2exp functions),\n   where implicit conversions are performed. Indeed, having at least one\n   implicit conversion in the macro allows the compiler to emit diagnostics\n   when normally expected, for instance in the following call:\n     mpfr_set_ui (x, \"foo\", MPFR_RNDN);\n   If this is not possible (for future macros), one of the tricks described\n   on http://groups.google.com/group/comp.std.c/msg/e92abd24bf9eaf7b could\n   be used. */\n#if defined (__GNUC__) && !defined(__ICC) && !defined(__cplusplus)\n#if (__GNUC__ >= 2)\n#undef mpfr_cmp_ui\n/* We use the fact that mpfr_sgn on NaN sets the erange flag and returns 0.\n   But warning! mpfr_sgn is specified as a macro in the API, thus the macro\n   mustn't be used if side effects are possible, like here. */\n#define mpfr_cmp_ui(_f,_u)                                      \\\n  (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \\\n   (mpfr_sgn) (_f) :                                            \\\n   mpfr_cmp_ui_2exp ((_f), (_u), 0))\n#undef mpfr_cmp_si\n#define mpfr_cmp_si(_f,_s)                                      \\\n  (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \\\n   mpfr_cmp_ui ((_f), (mpfr_ulong) (mpfr_long) (_s)) :          \\\n   mpfr_cmp_si_2exp ((_f), (_s), 0))\n#if __GNUC__ > 2 || __GNUC_MINOR__ >= 95\n#undef mpfr_set_ui\n#define mpfr_set_ui(_f,_u,_r)                                   \\\n  (__builtin_constant_p (_u) && (mpfr_ulong) (_u) == 0 ?        \\\n   __extension__ ({                                             \\\n       mpfr_ptr _p = (_f);                                      \\\n       _p->_mpfr_sign = 1;                                      \\\n       _p->_mpfr_exp = __MPFR_EXP_ZERO;                         \\\n       (mpfr_void) (_r); 0; }) :                                \\\n   mpfr_set_ui_2exp ((_f), (_u), 0, (_r)))\n#endif\n#undef mpfr_set_si\n#define mpfr_set_si(_f,_s,_r)                                   \\\n  (__builtin_constant_p (_s) && (mpfr_long) (_s) >= 0 ?         \\\n   mpfr_set_ui ((_f), (mpfr_ulong) (mpfr_long) (_s), (_r)) :    \\\n   mpfr_set_si_2exp ((_f), (_s), 0, (_r)))\n#endif\n#endif\n\n/* Macro version of mpfr_stack interface for fast access */\n#define mpfr_custom_get_size(p) ((mpfr_size_t)                          \\\n       (((p)+GMP_NUMB_BITS-1)/GMP_NUMB_BITS*sizeof (mp_limb_t)))\n#define mpfr_custom_init(m,p) do {} while (0)\n#define mpfr_custom_get_significand(x) ((mpfr_void*)((x)->_mpfr_d))\n#define mpfr_custom_get_exp(x) ((x)->_mpfr_exp)\n#define mpfr_custom_move(x,m) do { ((x)->_mpfr_d = (mp_limb_t*)(m)); } while (0)\n#define mpfr_custom_init_set(x,k,e,p,m) do {                   \\\n  mpfr_ptr _x = (x);                                           \\\n  mpfr_exp_t _e;                                               \\\n  mpfr_kind_t _t;                                              \\\n  mpfr_int _s, _k;                                             \\\n  _k = (k);                                                    \\\n  if (_k >= 0)  {                                              \\\n    _t = (mpfr_kind_t) _k;                                     \\\n    _s = 1;                                                    \\\n  } else {                                                     \\\n    _t = (mpfr_kind_t) -k;                                     \\\n    _s = -1;                                                   \\\n  }                                                            \\\n  _e = _t == MPFR_REGULAR_KIND ? (e) :                         \\\n    _t == MPFR_NAN_KIND ? __MPFR_EXP_NAN :                     \\\n    _t == MPFR_INF_KIND ? __MPFR_EXP_INF : __MPFR_EXP_ZERO;    \\\n  _x->_mpfr_prec = (p);                                        \\\n  _x->_mpfr_sign = _s;                                         \\\n  _x->_mpfr_exp  = _e;                                         \\\n  _x->_mpfr_d    = (mp_limb_t*) (m);                           \\\n } while (0)\n#define mpfr_custom_get_kind(x)                                         \\\n  ( (x)->_mpfr_exp >  __MPFR_EXP_INF ?                                  \\\n    (mpfr_int) MPFR_REGULAR_KIND * MPFR_SIGN (x)                        \\\n  : (x)->_mpfr_exp == __MPFR_EXP_INF ?                                  \\\n    (mpfr_int) MPFR_INF_KIND * MPFR_SIGN (x)                            \\\n  : (x)->_mpfr_exp == __MPFR_EXP_NAN ? (mpfr_int) MPFR_NAN_KIND         \\\n  : (mpfr_int) MPFR_ZERO_KIND * MPFR_SIGN (x) )\n\n\n#endif /* MPFR_USE_NO_MACRO */\n\n/* Theses are defined to be macros */\n#define mpfr_init_set_si(x, i, rnd) \\\n ( mpfr_init(x), mpfr_set_si((x), (i), (rnd)) )\n#define mpfr_init_set_ui(x, i, rnd) \\\n ( mpfr_init(x), mpfr_set_ui((x), (i), (rnd)) )\n#define mpfr_init_set_d(x, d, rnd) \\\n ( mpfr_init(x), mpfr_set_d((x), (d), (rnd)) )\n#define mpfr_init_set_ld(x, d, rnd) \\\n ( mpfr_init(x), mpfr_set_ld((x), (d), (rnd)) )\n#define mpfr_init_set_z(x, i, rnd) \\\n ( mpfr_init(x), mpfr_set_z((x), (i), (rnd)) )\n#define mpfr_init_set_q(x, i, rnd) \\\n ( mpfr_init(x), mpfr_set_q((x), (i), (rnd)) )\n#define mpfr_init_set(x, y, rnd) \\\n ( mpfr_init(x), mpfr_set((x), (y), (rnd)) )\n#define mpfr_init_set_f(x, y, rnd) \\\n ( mpfr_init(x), mpfr_set_f((x), (y), (rnd)) )\n\n/* Compatibility layer -- obsolete functions and macros */\n#define mpfr_cmp_abs mpfr_cmpabs\n#define mpfr_round_prec(x,r,p) mpfr_prec_round(x,p,r)\n#define __gmp_default_rounding_mode (mpfr_get_default_rounding_mode())\n#define __mpfr_emin (mpfr_get_emin())\n#define __mpfr_emax (mpfr_get_emax())\n#define __mpfr_default_fp_bit_precision (mpfr_get_default_fp_bit_precision())\n#define MPFR_EMIN_MIN mpfr_get_emin_min()\n#define MPFR_EMIN_MAX mpfr_get_emin_max()\n#define MPFR_EMAX_MIN mpfr_get_emax_min()\n#define MPFR_EMAX_MAX mpfr_get_emax_max()\n#define mpfr_version (mpfr_get_version())\n#ifndef mpz_set_fr\n# define mpz_set_fr mpfr_get_z\n#endif\n#define mpfr_add_one_ulp(x,r) \\\n (mpfr_sgn (x) > 0 ? mpfr_nextabove (x) : mpfr_nextbelow (x))\n#define mpfr_sub_one_ulp(x,r) \\\n (mpfr_sgn (x) > 0 ? mpfr_nextbelow (x) : mpfr_nextabove (x))\n#define mpfr_get_z_exp mpfr_get_z_2exp\n#define mpfr_custom_get_mantissa mpfr_custom_get_significand\n\n#endif /* __MPFR_H*/\n\n",
    "ap_fixed_ref.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_FIXED_REF_H__\n#define __AP_FIXED_REF_H__\n\n#ifndef __AP_FIXED_H__\n// TODO make this an error\n#pragma message \\\n    \"Only ap_fixed.h and ap_int.h can be included directly in user code.\"\n#endif\n\n#ifndef __cplusplus\n#error \"C++ is required to include this header file\"\n\n#else\n#ifndef __SYNTHESIS__\n#include \"iostream\"\n#endif\n/// Proxy class, which allows bit selection  to be used as both rvalue (for\n/// reading) and lvalue (for writing)\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nstruct af_bit_ref {\n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;\n  ref_type& d_bv;\n  int d_index;\n\n public:\n  INLINE af_bit_ref(\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)\n      : d_bv(ref.d_bv), d_index(ref.d_index) {\n#ifndef __SYNTHESIS__\n    _AP_WARNING(d_index < 0, \"Index of bit vector  (%d) cannot be negative.\",\n                d_index);\n    _AP_WARNING(d_index >= _AP_W, \"Index of bit vector (%d) out of range (%d).\",\n                d_index, _AP_W);\n#endif\n  }\n\n  INLINE af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}\n\n  INLINE af_bit_ref(const ref_type* bv, int index = 0)\n      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}\n\n  /// convert operators.\n  INLINE operator bool() const { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n\n  /// @name assign operators\n  //  @{\n  INLINE af_bit_ref& operator=(bool val) {\n    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val);\n    return *this;\n  }\n\n  // Be explicit to prevent it from being deleted, as field d_bv\n  // is of reference type.\n  INLINE af_bit_ref& operator=(const af_bit_ref& val) {\n    return operator=(bool(val));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE af_bit_ref& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=(bool(val));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {\n    return operator=(bool(val));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {\n    return operator=(val != 0);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {\n    return operator=(ap_int_base<_AP_W2, false>(val));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE af_bit_ref& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=(ap_int_base<_AP_W2, false>(val));\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE af_bit_ref& operator=(\n      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {\n    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));\n  }\n  //  @}\n\n  /// @name concatenate operators\n  //  @{\n  template <int _AP_W2, int _AP_S2>\n  INLINE ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(\n        *this, op);\n  }\n\n  template <int _AP_W2, int _AP_S2>\n  INLINE ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(\n      const ap_bit_ref<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,\n                                                                        op);\n  }\n\n  template <int _AP_W2, int _AP_S2>\n  INLINE ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(\n        *this, op);\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {\n    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,\n                                                                         op);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<\n      1, af_bit_ref, _AP_W2,\n      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {\n    return ap_concat_ref<\n        1, af_bit_ref, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,\n                                                                       op);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,\n                                                    _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {\n    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,\n                                                      _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            op));\n  }\n  //  @}\n\n  /// @name comparison\n  //  @{\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator==(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    return get() == op.get();\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator!=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    return get() != op.get();\n  }\n  //  @}\n\n  INLINE bool operator~() const {\n    bool bit = _AP_ROOT_op_get_bit(d_bv.V, d_index);\n    return bit ? false : true;\n  }\n\n  INLINE bool get() const { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n\n  INLINE int length() const { return 1; }\n\n#ifndef __SYNTHESIS__\n  std::string to_string() const { return get() ? \"1\" : \"0\"; }\n#else\n  // XXX HLS will delete this in synthesis\n  INLINE char* to_string() const { return 0; }\n#endif\n}; // struct af_bit_ref\n\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE std::ostream& operator<<(\n    std::ostream& os,\n    const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {\n  os << x.to_string();\n  return os;\n}\n#endif // ifndef __SYNTHESIS__\n#endif // ifndef AP_AUTOCC\n\n/// Range (slice) reference.\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nstruct af_range_ref {\n#ifdef _MSC_VER\n#pragma warning(disable : 4521 4522)\n#endif\n  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;\n  ref_type& d_bv;\n  int l_index;\n  int h_index;\n\n public:\n  /// copy ctor\n  INLINE af_range_ref(\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)\n      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}\n\n  /// ctor from ap_fixed_base, higher and lower bound.\n  /** if h is less than l, the bits selected will be returned in reverse order.\n   */\n  INLINE af_range_ref(ref_type* bv, int h, int l)\n      : d_bv(*bv), l_index(l), h_index(h) {\n#ifndef __SYNTHESIS__\n    _AP_WARNING(h < 0 || l < 0,\n                \"Higher bound(%d) and lower(%d) bound cannot be negative.\", h,\n                l);\n    _AP_WARNING(h >= _AP_W || l >= _AP_W,\n                \"Higher bound(%d) or lower(%d) bound out of range.\", h, l);\n    _AP_WARNING(h < l, \"The bits selected will be returned in reverse order.\");\n#endif\n  }\n\n  INLINE af_range_ref(const ref_type* bv, int h, int l)\n      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {\n#ifndef __SYNTHESIS__\n    _AP_WARNING(h < 0 || l < 0,\n                \"Higher bound(%d) and lower(%d) bound cannot be negative.\", h,\n                l);\n    _AP_WARNING(h >= _AP_W || l >= _AP_W,\n                \"Higher bound(%d) or lower(%d) bound out of range.\", h, l);\n    _AP_WARNING(h < l, \"The bits selected will be returned in reverse order.\");\n#endif\n  }\n\n  /// @name assign operators\n  //  @{\n\n#define ASSIGN_CTYPE_TO_AF_RANGE(DATA_TYPE)                          \\\n  INLINE af_range_ref& operator=(const DATA_TYPE val) {              \\\n    ap_int_base<_AP_W, false> loc(val);                              \\\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); \\\n    return *this;                                                    \\\n  }\n\n  ASSIGN_CTYPE_TO_AF_RANGE(bool)\n  ASSIGN_CTYPE_TO_AF_RANGE(char)\n  ASSIGN_CTYPE_TO_AF_RANGE(signed char)\n  ASSIGN_CTYPE_TO_AF_RANGE(unsigned char)\n  ASSIGN_CTYPE_TO_AF_RANGE(short)\n  ASSIGN_CTYPE_TO_AF_RANGE(unsigned short)\n  ASSIGN_CTYPE_TO_AF_RANGE(int)\n  ASSIGN_CTYPE_TO_AF_RANGE(unsigned int)\n  ASSIGN_CTYPE_TO_AF_RANGE(long)\n  ASSIGN_CTYPE_TO_AF_RANGE(unsigned long)\n  ASSIGN_CTYPE_TO_AF_RANGE(ap_slong)\n  ASSIGN_CTYPE_TO_AF_RANGE(ap_ulong)\n  ASSIGN_CTYPE_TO_AF_RANGE(half)\n  ASSIGN_CTYPE_TO_AF_RANGE(float)\n  ASSIGN_CTYPE_TO_AF_RANGE(double)\n#undef ASSIGN_CTYPE_TO_AF_RANGE\n\n  /// assgin using a string. XXX crucial for cosim.\n  INLINE af_range_ref& operator=(const char* val) {\n    const ap_int_base<_AP_W, false> tmp(val); // XXX figure out radix\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);\n    return *this;\n  }\n\n  /// assign from ap_int_base.\n  // NOTE Base of other assgin operators.\n  template <int _AP_W3, bool _AP_S3>\n  INLINE af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);\n    return *this;\n  }\n\n  /// assign from range reference to ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {\n    const ap_int_base<_AP_W2, false> tmp(val);\n    return operator=(tmp);\n  }\n\n  /// assign from bit reference to ap_int_base..\n  template <int _AP_W2, bool _AP_S2>\n  INLINE af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {\n    const ap_int_base<1, false> tmp((bool)val);\n    return operator=(tmp);\n  }\n\n  /// assgin from ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE af_range_ref& operator=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          val) {\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);\n    return *this;\n  }\n\n  /// copy assgin.\n  // XXX This has to be explicit, otherwise it will be deleted, as d_bv is\n  // of reference type.\n  INLINE af_range_ref& operator=(const af_range_ref& val) {\n    ap_int_base<_AP_W, false> tmp(val);\n    return operator=(tmp);\n  }\n\n  /// assign from range reference to ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE af_range_ref& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    ap_int_base<_AP_W2, false> tmp(val);\n    return operator=(tmp);\n  }\n\n  /// assign from bit reference to ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE af_range_ref& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    ap_int_base<1, false> tmp((bool)val);\n    return operator=(tmp);\n  }\n\n  /// assign from compound reference.\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE af_range_ref& operator=(\n      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {\n    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);\n    return operator=(tmp);\n  }\n  //  @}\n\n  /// @name comparison operators with ap_range_ref.\n  //  @{\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop == rop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator==(op2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop < rop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop > rop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator>(op2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator<(op2));\n  }\n  //  @}\n\n  /// @name comparison operators with af_range_ref.\n  //  @{\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator==(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop == rop;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator!=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    return !(operator==(op2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator<(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop < rop;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator>(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> rop(op2);\n    return lop > rop;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator<=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    return !(operator>(op2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE bool operator>=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {\n    return !(operator<(op2));\n  }\n  //  @}\n\n  /// @name concatenate operators.\n  /// @{\n  /// concatenate with ap_int_base.\n  template <int _AP_W2, int _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);\n  }\n\n  /// concatenate with ap_bit_ref.\n  template <int _AP_W2, int _AP_S2>\n  INLINE ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));\n  }\n\n  /// concatenate with ap_bit_ref.\n  template <int _AP_W2, int _AP_S2>\n  INLINE ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {\n    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,\n                         ap_range_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));\n  }\n\n  /// concatenate with ap_concat_ref.\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {\n    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));\n  }\n\n  /// concatenate with another af_range_ref.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE\n      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,\n                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n                    &op) {\n    return ap_concat_ref<\n        _AP_W, af_range_ref, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            op));\n  }\n\n  /// concatenate with another af_bit_ref.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE\n      ap_concat_ref<_AP_W, af_range_ref, 1,\n                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n      operator,(\n          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {\n    return ap_concat_ref<\n        _AP_W, af_range_ref, 1,\n        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            op));\n  }\n  //  @}\n\n  INLINE operator ap_ulong() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret.to_uint64();\n  }\n\n  INLINE operator ap_int_base<_AP_W, false>() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret;\n  }\n\n  INLINE ap_int_base<_AP_W, false> to_ap_int_base() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret;\n  }\n\n  // used in ap_fixed_base::to_string()\n  INLINE char to_char() const {\n    return (char)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE int to_int() const {\n    return (int)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE unsigned to_uint() const {\n    return (unsigned)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE long to_long() const {\n    return (long)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE unsigned long to_ulong() const {\n    return (unsigned long)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE ap_slong to_int64() const {\n    return (ap_slong)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE ap_ulong to_uint64() const {\n    return (ap_ulong)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE ap_int_base<_AP_W, false> get() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret;\n  }\n\n  template <int _AP_W2>\n  INLINE void set(const ap_int_base<_AP_W2, false>& val) {\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);\n  }\n\n  INLINE int length() const {\n    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;\n  }\n\n#ifndef __SYNTHESIS__\n  std::string to_string(signed char rd = 2) const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret.to_string(rd);\n  }\n#else\n  // XXX HLS will delete this in synthesis\n  INLINE char* to_string(signed char rd = 2) const {\n    return 0;\n  }\n#endif\n}; // struct af_range_ref\n\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,\n          int _AP_N>\nINLINE std::ostream& operator<<(\n    std::ostream& os,\n    const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {\n  os << x.to_string();\n  return os;\n}\n#endif\n#endif // ifndef AP_AUTOCC\n\n#define AF_REF_REL_OP_WITH_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)            \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N>                                   \\\n  INLINE bool operator REL_OP(                                            \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,   \\\n      C_TYPE op2) {                                                       \\\n    return ap_int_base<_AP_W, false>(op)                                  \\\n        REL_OP ap_int_base<_AP_W2, _AP_S2>(op2);                          \\\n  }                                                                       \\\n                                                                          \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N>                                   \\\n  INLINE bool operator REL_OP(                                            \\\n      C_TYPE op2,                                                         \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { \\\n    return ap_int_base<_AP_W2, _AP_S2>(op2)                               \\\n        REL_OP ap_int_base<_AP_W, false>(op);                             \\\n  }                                                                       \\\n                                                                          \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N>                                   \\\n  INLINE bool operator REL_OP(                                            \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,     \\\n      C_TYPE op2) {                                                       \\\n    return bool(op) REL_OP op2;                                           \\\n  }                                                                       \\\n                                                                          \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N>                                   \\\n  INLINE bool operator REL_OP(                                            \\\n      C_TYPE op2,                                                         \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {   \\\n    return op2 REL_OP bool(op);                                           \\\n  }\n\n#define AF_REF_REL_OPS_WITH_INT(C_TYPE, _AP_W2, _AP_S2)  \\\n  AF_REF_REL_OP_WITH_INT(>, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  AF_REF_REL_OP_WITH_INT(<, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  AF_REF_REL_OP_WITH_INT(>=, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  AF_REF_REL_OP_WITH_INT(<=, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  AF_REF_REL_OP_WITH_INT(==, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  AF_REF_REL_OP_WITH_INT(!=, C_TYPE, (_AP_W2), (_AP_S2))\n\nAF_REF_REL_OPS_WITH_INT(bool, 1, false)\nAF_REF_REL_OPS_WITH_INT(char, 8, CHAR_IS_SIGNED)\nAF_REF_REL_OPS_WITH_INT(signed char, 8, true)\nAF_REF_REL_OPS_WITH_INT(unsigned char, 8, false)\nAF_REF_REL_OPS_WITH_INT(short, _AP_SIZE_short, true)\nAF_REF_REL_OPS_WITH_INT(unsigned short, _AP_SIZE_short, false)\nAF_REF_REL_OPS_WITH_INT(int, _AP_SIZE_int, true)\nAF_REF_REL_OPS_WITH_INT(unsigned int, _AP_SIZE_int, false)\nAF_REF_REL_OPS_WITH_INT(long, _AP_SIZE_long, true)\nAF_REF_REL_OPS_WITH_INT(unsigned long, _AP_SIZE_long, false)\nAF_REF_REL_OPS_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nAF_REF_REL_OPS_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef AF_REF_REL_OP_INT\n#undef AF_REF_REL_OPS_WITH_INT\n\n#define AF_REF_REL_OP_WITH_AP_INT(REL_OP)                                 \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>          \\\n  INLINE bool operator REL_OP(                                            \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,   \\\n      const ap_int_base<_AP_W2, _AP_S>& op2) {                            \\\n    return ap_int_base<_AP_W, false>(op) REL_OP op2;                      \\\n  }                                                                       \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>          \\\n  INLINE bool operator REL_OP(                                            \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2,                             \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { \\\n    return op2 REL_OP ap_int_base<_AP_W, false>(op);                      \\\n  }                                                                       \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>          \\\n  INLINE bool operator REL_OP(                                            \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,     \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {                           \\\n    return ap_int_base<1, false>(op) REL_OP op2;                          \\\n  }                                                                       \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,            \\\n            ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2>          \\\n  INLINE bool operator REL_OP(                                            \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2,                             \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {   \\\n    return op2 REL_OP ap_int_base<1, false>(op);                          \\\n  }\n\nAF_REF_REL_OP_WITH_AP_INT(>)\nAF_REF_REL_OP_WITH_AP_INT(<)\nAF_REF_REL_OP_WITH_AP_INT(>=)\nAF_REF_REL_OP_WITH_AP_INT(<=)\nAF_REF_REL_OP_WITH_AP_INT(==)\nAF_REF_REL_OP_WITH_AP_INT(!=)\n\n#endif // ifndef __cplusplus\n\n#endif // ifndef __AP_FIXED_REF_H__\n\n// -*- cpp -*-\n\n\n",
    "ap_int_special.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef AP_INT_SPECIAL_H\n#define AP_INT_SPECIAL_H\n#ifndef __SYNTHESIS__\n#include \"cstdio\"\n#include \"cstdlib\"\n#endif\n// FIXME AP_AUTOCC cannot handle many standard headers, so declare instead of\n// include.\n// #include \"complex\"\nnamespace std {\ntemplate<typename _Tp> class complex;\n}\n\n/*\n  TODO: Modernize the code using C++11/C++14\n  1. constexpr http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0415r0.html\n  2. move constructor\n*/\n\nnamespace std {\n/*\n   Specialize std::complex<ap_int> to zero initialization ap_int.\n\n   To reduce the area cost, ap_int is not zero initialized, just like basic\n   types float or double. However, libstdc++ provides specialization for float,\n   double and long double, initializing image part to 0 when not specified.\n\n   This has become a difficulty in switching legacy code from these C types to\n   ap_int. To ease the tranform of legacy code, we have to implement\n   specialization of std::complex<> for our type.\n\n   As ap_int is a template, it is impossible to specialize only the methods\n   that causes default initialization of value type in std::complex<>. An\n   explicit full specialization of the template class has to be done, covering\n   all the member functions and operators of std::complex<> as specified\n   in standard 26.2.4 and 26.2.5.\n*/\ntemplate <int _AP_W>\nclass complex<ap_int<_AP_W> > {\n public:\n  typedef ap_int<_AP_W> _Tp;\n  typedef _Tp value_type;\n\n  // 26.2.4/1\n  // Constructor without argument\n  // Default initialize, so that in dataflow, the variable is only written once.\n  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}\n  // Constructor with ap_int.\n  // Zero initialize image part when not specified, so that `C(1) == C(1,0)`\n  complex(const _Tp &__r, const _Tp &__i = _Tp(0))\n      : _M_real(__r), _M_imag(__i) {}\n\n  // Constructor with another complex number\n  template <typename _Up>\n  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}\n\n#if __cplusplus >= 201103L\n  const _Tp& real() const { return _M_real; }\n  const _Tp& imag() const { return _M_imag; }\n#else\n  _Tp& real() { return _M_real; }\n  const _Tp& real() const { return _M_real; }\n  _Tp& imag() { return _M_imag; }\n  const _Tp& imag() const { return _M_imag; }\n#endif\n\n  void real(_Tp __val) { _M_real = __val; }\n\n  void imag(_Tp __val) { _M_imag = __val; }\n\n  // Assign this complex number with ap_int.\n  // Zero initialize image poarrt, so that `C c; c = 1; c == C(1,0);`\n  complex<_Tp> &operator=(const _Tp __t) {\n    _M_real = __t;\n    _M_imag = _Tp(0);\n    return *this;\n  }\n\n  // 26.2.5/1\n  // Add ap_int to this complex number.\n  complex<_Tp> &operator+=(const _Tp &__t) {\n    _M_real += __t;\n    return *this;\n  }\n\n  // 26.2.5/3\n  // Subtract ap_int from this complex number.\n  complex<_Tp> &operator-=(const _Tp &__t) {\n    _M_real -= __t;\n    return *this;\n  }\n\n  // 26.2.5/5\n  // Multiply this complex number by ap_int.\n  complex<_Tp> &operator*=(const _Tp &__t) {\n    _M_real *= __t;\n    _M_imag *= __t;\n    return *this;\n  }\n\n  // 26.2.5/7\n  // Divide this complex number by ap_int.\n  complex<_Tp> &operator/=(const _Tp &__t) {\n    _M_real /= __t;\n    _M_imag /= __t;\n    return *this;\n  }\n\n  // Assign complex number to this complex number.\n  template <typename _Up>\n  complex<_Tp> &operator=(const complex<_Up> &__z) {\n    _M_real = __z.real();\n    _M_imag = __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/9\n  // Add complex number to this.\n  template <typename _Up>\n  complex<_Tp> &operator+=(const complex<_Up> &__z) {\n    _M_real += __z.real();\n    _M_imag += __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/11\n  // Subtract complex number from this.\n  template <typename _Up>\n  complex<_Tp> &operator-=(const complex<_Up> &__z) {\n    _M_real -= __z.real();\n    _M_imag -= __z.imag();\n    return *this;\n  }\n\n  // 26.2.5/13\n  // Multiply this by complex number.\n  template <typename _Up>\n  complex<_Tp> &operator*=(const complex<_Up> &__z) {\n    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n    _M_real = __r;\n    return *this;\n  }\n\n  // 26.2.5/15\n  // Divide this by complex number.\n  template <typename _Up>\n  complex<_Tp> &operator/=(const complex<_Up> &__z) {\n    complex<_Tp> cj (__z.real(), -__z.imag());\n    complex<_Tp> a = (*this) * cj;\n    complex<_Tp> b = cj * __z;\n    _M_real = a.real() / b.real();\n    _M_imag = a.imag() / b.real();\n    return *this;\n  }\n\n private:\n  _Tp _M_real;\n  _Tp _M_imag;\n\n}; // class complex<ap_int<_AP_W> >\n\n\n/*\n   Non-member operations\n   These operations are not required by standard in 26.2.6, but libstdc++\n   defines them for\n   float, double or long double's specialization.\n*/\n// Compare complex number with ap_int.\ntemplate <int _AP_W>\ninline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {\n  return __x.real() == __y &&\n         __x.imag() == 0;\n}\n\n// Compare ap_int with complex number.\ntemplate <int _AP_W>\ninline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {\n  return __x == __y.real() &&\n         0 == __y.imag();\n}\n\n// Compare complex number with ap_int.\ntemplate <int _AP_W>\ninline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {\n  return __x.real() != __y ||\n         __x.imag() != 0;\n}\n\n// Compare ap_int with complex number.\ntemplate <int _AP_W>\ninline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {\n  return __x != __y.real() ||\n         0 != __y.imag();\n}\n\n}  // namespace std\n\n#endif  // ifndef AP_INT_SPECIAL_H\n\n\n",
    "ap_int_base.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_INT_BASE_H__\n#define __AP_INT_BASE_H__\n\n#ifndef __AP_INT_H__\n// TODO make this an error\n#pragma message \\\n    \"Only ap_fixed.h and ap_int.h can be included directly in user code.\"\n#endif\n\n#ifndef __cplusplus\n#error \"C++ is required to include this header file\"\n#else\n\n#include \"ap_common.h\"\n#ifndef __SYNTHESIS__\n#include \"hls_half.h\"\n#include \"iostream\"\n#include \"string.h\"\n#endif\n\n/* ----------------------------------------------------------------\n * ap_int_base: AutoPilot integer/Arbitrary precision integer.\n * ----------------------------------------------------------------\n */\n\n/* helper trait. Selecting the smallest C type that can hold the value,\n * return 64 bit C type if not possible.\n */\ntemplate <int _AP_N, bool _AP_S>\nstruct retval;\n\n// at least 64 bit\ntemplate <int _AP_N>\nstruct retval<_AP_N, true> {\n  typedef ap_slong Type;\n};\n\ntemplate <int _AP_N>\nstruct retval<_AP_N, false> {\n  typedef ap_ulong Type;\n};\n\n// at least 8 bit\ntemplate <>\nstruct retval<1, true> {\n  typedef signed char Type;\n};\n\ntemplate <>\nstruct retval<1, false> {\n  typedef unsigned char Type;\n};\n\n// at least 16 bit\ntemplate <>\nstruct retval<2, true> {\n  typedef short Type;\n};\n\ntemplate <>\nstruct retval<2, false> {\n  typedef unsigned short Type;\n};\n\n// at least 32 bit\ntemplate <>\nstruct retval<3, true> {\n  typedef long Type;\n};\n\ntemplate <>\nstruct retval<3, false> {\n  typedef unsigned long Type;\n};\n\ntemplate <>\nstruct retval<4, true> {\n  typedef long Type;\n};\n\ntemplate <>\nstruct retval<4, false> {\n  typedef unsigned long Type;\n};\n\n// trait for letting base class to return derived class.\n// Notice that derived class template is incomplete, and we cannot use\n// the member of the derived class.\ntemplate <int _AP_W2, bool _AP_S2>\nstruct _ap_int_factory;\ntemplate <int _AP_W2>\nstruct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };\ntemplate <int _AP_W2>\nstruct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };\n\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_int_base : public _AP_ROOT_TYPE<_AP_W, _AP_S> {\n public:\n  typedef _AP_ROOT_TYPE<_AP_W, _AP_S> Base;\n\n  /* ap_int_base<_AP_W, _AP_S, true>\n   * typedef typename retval<(_AP_W + 7) / 8, _AP_S>::Type RetType;\n   *\n   * ap_int_base<_AP_W, _AP_S, false>\n   * typedef typename retval<8, _AP_S>::Type RetType;\n   */\n  typedef typename retval<AP_MAX((_AP_W + 7) / 8, 8), _AP_S>::Type RetType;\n\n  static const int width = _AP_W;\n\n  template <int _AP_W2, bool _AP_S2>\n  struct RType {\n    enum {\n      mult_w = _AP_W + _AP_W2,\n      mult_s = _AP_S || _AP_S2,\n      plus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      plus_s = _AP_S || _AP_S2,\n      minus_w =\n          AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)) + 1,\n      minus_s = true,\n      div_w = _AP_W + _AP_S2,\n      div_s = _AP_S || _AP_S2,\n      mod_w = AP_MIN(_AP_W, _AP_W2 + (!_AP_S2 && _AP_S)),\n      mod_s = _AP_S,\n      logic_w = AP_MAX(_AP_W + (_AP_S2 && !_AP_S), _AP_W2 + (_AP_S && !_AP_S2)),\n      logic_s = _AP_S || _AP_S2\n    };\n\n\n    typedef ap_int_base<mult_w, mult_s> mult_base;\n    typedef ap_int_base<plus_w, plus_s> plus_base;\n    typedef ap_int_base<minus_w, minus_s> minus_base;\n    typedef ap_int_base<logic_w, logic_s> logic_base;\n    typedef ap_int_base<div_w, div_s> div_base;\n    typedef ap_int_base<mod_w, mod_s> mod_base;\n    typedef ap_int_base<_AP_W, _AP_S> arg1_base;\n\n    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;\n    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;\n    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;\n    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;\n    typedef typename _ap_int_factory<div_w, div_s>::type div;\n    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;\n    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;\n    typedef bool reduce;\n  };\n\n  /* Constructors.\n   * ----------------------------------------------------------------\n   */\n  /// default ctor\n  INLINE ap_int_base() {\n    /*\n      #ifdef __SC_COMPATIBLE__\n      Base::V = 0;\n      #endif\n    */\n  }\n\n  /// copy ctor\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {\n    Base::V = op.V;\n  }\n\n  /// volatile copy ctor\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {\n    Base::V = op.V;\n  }\n\n// XXX C++11 feature.\n// The explicit specifier specifies that a constructor or conversion function\n// (since C++11) doesn't allow implicit conversions or copy-initialization.\n//   ap_int_base<W,S> x = 1;\n//   ap_int_base<W,S> foo() { return 1; }\n// but allows\n//   ap_int_base<W,S> x(1);\n//   ap_int_base<W,S> y {1};\n\n/// from all c types.\n#define CTOR_FROM_INT(Type, Size, Signed) \\\n  INLINE ap_int_base(const Type op) { Base::V = op; }\n\n  CTOR_FROM_INT(bool, 1, false)\n  CTOR_FROM_INT(char, 8, CHAR_IS_SIGNED)\n  CTOR_FROM_INT(signed char, 8, true)\n  CTOR_FROM_INT(unsigned char, 8, false)\n  CTOR_FROM_INT(short, _AP_SIZE_short, true)\n  CTOR_FROM_INT(unsigned short, _AP_SIZE_short, false)\n  CTOR_FROM_INT(int, _AP_SIZE_int, true)\n  CTOR_FROM_INT(unsigned int, _AP_SIZE_int, false)\n  CTOR_FROM_INT(long, _AP_SIZE_long, true)\n  CTOR_FROM_INT(unsigned long, _AP_SIZE_long, false)\n  CTOR_FROM_INT(ap_slong, _AP_SIZE_ap_slong, true)\n  CTOR_FROM_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n#undef CTOR_FROM_INT\n\n  /// ctor from half.\n  //  TODO optimize\n  INLINE ap_int_base(half op) {\n    ap_int_base<_AP_W, _AP_S> t((float)op);\n    Base::V = t.V;\n  }\n\n  /// ctor from float.\n  INLINE ap_int_base(float op) {\n    const int BITS = FLOAT_MAN + FLOAT_EXP + 1;\n    ap_int_base<BITS, false> reg;\n    reg.V = floatToRawBits(op);\n    bool is_neg = _AP_ROOT_op_get_bit(reg.V, BITS - 1);\n\n    ap_int_base<FLOAT_EXP + 1, true> exp = 0;\n    exp.V = _AP_ROOT_op_get_range(reg.V, FLOAT_MAN, BITS - 2);\n    exp = exp - FLOAT_BIAS;\n\n    ap_int_base<FLOAT_MAN + 2, true> man;\n    man.V = _AP_ROOT_op_get_range(reg.V, 0, FLOAT_MAN - 1);\n    // check for NaN\n    _AP_WARNING(exp == ((unsigned char)(FLOAT_BIAS + 1)) && man.V != 0,\n                \"assign NaN to ap integer value\");\n    // set leading 1.\n    man.V = _AP_ROOT_op_set_bit(man.V, FLOAT_MAN, 1);\n    //if (is_neg) man = -man;\n\n    if ((reg.V & 0x7ffffffful) == 0) {\n      Base::V = 0;\n    } else {\n      int sh_amt = FLOAT_MAN - exp.V;\n      if (sh_amt == 0) {\n        Base::V = man.V;\n      } else if (sh_amt > 0) {\n        if (sh_amt < FLOAT_MAN + 2) {\n          Base::V = man.V >> sh_amt;\n        } else {\n          if (is_neg)\n            Base::V = -1;\n          else\n            Base::V = 0;\n        }\n      } else {\n        sh_amt = -sh_amt;\n        if (sh_amt < _AP_W) {\n          Base::V = man.V;\n          Base::V <<= sh_amt;\n        } else {\n          Base::V = 0;\n        }\n      }\n    }\n    if (is_neg) *this = -(*this);\n  }\n\n  /// ctor from double.\n  INLINE ap_int_base(double op) {\n    const int BITS = DOUBLE_MAN + DOUBLE_EXP + 1;\n    ap_int_base<BITS, false> reg;\n    reg.V = doubleToRawBits(op);\n    bool is_neg = _AP_ROOT_op_get_bit(reg.V, BITS - 1);\n\n    ap_int_base<DOUBLE_EXP + 1, true> exp = 0;\n    exp.V = _AP_ROOT_op_get_range(reg.V, DOUBLE_MAN, BITS - 2);\n    exp = exp - DOUBLE_BIAS;\n\n    ap_int_base<DOUBLE_MAN + 2, true> man;\n    man.V = _AP_ROOT_op_get_range(reg.V, 0, DOUBLE_MAN - 1);\n    // check for NaN\n    _AP_WARNING(exp == ((unsigned char)(DOUBLE_BIAS + 1)) && man.V != 0,\n                \"assign NaN to ap integer value\");\n    // set leading 1.\n    man.V = _AP_ROOT_op_set_bit(man.V, DOUBLE_MAN, 1);\n    //if (is_neg) man = -man;\n\n    if ((reg.V & 0x7fffffffffffffffull) == 0) {\n      Base::V = 0;\n    } else {\n      int sh_amt = DOUBLE_MAN - exp.V;\n      if (sh_amt == 0) {\n        Base::V = man.V;\n      } else if (sh_amt > 0) {\n        if (sh_amt < DOUBLE_MAN + 2) {\n          Base::V = man.V >> sh_amt;\n        } else {\n          if (is_neg)\n            Base::V = -1;\n          else\n            Base::V = 0;\n        }\n      } else {\n        sh_amt = -sh_amt;\n        if (sh_amt < _AP_W) {\n          Base::V = man.V;\n          Base::V <<= sh_amt;\n        } else {\n          Base::V = 0;\n        }\n      }\n    }\n    if (is_neg) *this = -(*this);\n  }\n\n  /// from higer rank type.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    Base::V = op.to_ap_int_base().V;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {\n    Base::V = (ref.get()).V;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {\n    Base::V = ref.operator bool();\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {\n    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,\n                      false>\n        tmp = ref.get();\n    Base::V = tmp.V;\n  }\n\n  /* radix has default value in set */\n\n#ifndef __SYNTHESIS__\n  INLINE ap_int_base(const char* s, signed char rd = 0) {\n    if (rd == 0)\n      rd = guess_radix(s);\n    unsigned int length = strlen(s);\n    Base::V.fromString(s, length, rd);\n  }\n#else\n  // XXX __builtin_bit_from_string(...) requires const C string and radix.\n  INLINE ap_int_base(const char* s) {\n    typeof(Base::V) t;\n    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,\n                      AP_TRN, AP_WRAP, 0, _AP_C99);\n    Base::V = t;\n  }\n  INLINE ap_int_base(const char* s, signed char rd) {\n    typeof(Base::V) t;\n    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,\n                      AP_TRN, AP_WRAP, 0, _AP_C99);\n    Base::V = t;\n  }\n#endif\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    Base::V = (val.get()).V;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    Base::V = val.operator bool();\n  }\n\n  INLINE ap_int_base read() volatile {\n    /*AP_DEBUG(printf(\"call read %d\\n\", Base::V););*/\n    ap_int_base ret;\n    ret.V = Base::V;\n    return ret;\n  }\n\n  INLINE void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {\n    /*AP_DEBUG(printf(\"call write %d\\n\", op2.V););*/\n    Base::V = op2.V;\n  }\n\n  /* Another form of \"write\".*/\n  template <int _AP_W2, bool _AP_S2>\n  INLINE void operator=(\n      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n  INLINE void operator=(\n      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n  INLINE void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {\n    Base::V = op2.V;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator=(\n      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  INLINE ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n  INLINE ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) {\n    Base::V = op2.V;\n    return *this;\n  }\n\n\n#define ASSIGN_OP_FROM_INT(Type, Size, Signed) \\\n  INLINE ap_int_base& operator=(Type op) {     \\\n    Base::V = op;                              \\\n    return *this;                              \\\n  }\n\n  ASSIGN_OP_FROM_INT(bool, 1, false)\n  ASSIGN_OP_FROM_INT(char, 8, CHAR_IS_SIGNED)\n  ASSIGN_OP_FROM_INT(signed char, 8, true)\n  ASSIGN_OP_FROM_INT(unsigned char, 8, false)\n  ASSIGN_OP_FROM_INT(short, _AP_SIZE_short, true)\n  ASSIGN_OP_FROM_INT(unsigned short, _AP_SIZE_short, false)\n  ASSIGN_OP_FROM_INT(int, _AP_SIZE_int, true)\n  ASSIGN_OP_FROM_INT(unsigned int, _AP_SIZE_int, false)\n  ASSIGN_OP_FROM_INT(long, _AP_SIZE_long, true)\n  ASSIGN_OP_FROM_INT(unsigned long, _AP_SIZE_long, false)\n  ASSIGN_OP_FROM_INT(ap_slong, _AP_SIZE_ap_slong, true)\n  ASSIGN_OP_FROM_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef ASSIGN_OP_FROM_INT\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {\n    Base::V = (bool)op2;\n    return *this;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;\n    return *this;\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int_base& operator=(\n      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {\n    Base::V = op2.get().V;\n    return *this;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base& operator=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    Base::V = op.to_ap_int_base().V;\n    return *this;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    Base::V = (bool)op;\n    return *this;\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_int_base& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {\n    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;\n    return *this;\n  }\n\n  // FIXME: UG902 has clearly required user to use to_int() to convert to built-in\n  // types, but this implicit conversion is relied on in hls_cordic.h and hls_rsr.h.\n  // For example:\n  //     int d_exp = fps_x.exp - fps_y.exp;\n  INLINE operator RetType() const { return (RetType)(Base::V); }\n\n  /* Explicit conversions to C types.\n   * ----------------------------------------------------------------\n   */\n  INLINE bool to_bool() const { return (bool)(Base::V); }\n  INLINE char to_char() const { return (char)(Base::V); }\n  INLINE signed char to_schar() const { return (signed char)(Base::V); }\n  INLINE unsigned char to_uchar() const { return (unsigned char)(Base::V); }\n  INLINE short to_short() const { return (short)(Base::V); }\n  INLINE unsigned short to_ushort() const { return (unsigned short)(Base::V); }\n  INLINE int to_int() const { return (int)(Base::V); }\n  INLINE unsigned to_uint() const { return (unsigned)(Base::V); }\n  INLINE long to_long() const { return (long)(Base::V); }\n  INLINE unsigned long to_ulong() const { return (unsigned long)(Base::V); }\n  INLINE ap_slong to_int64() const { return (ap_slong)(Base::V); }\n  INLINE ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }\n  INLINE float to_float() const { return (float)(Base::V); }\n  INLINE double to_double() const { return (double)(Base::V); }\n\n  // TODO decide if user-defined conversion should be provided.\n#if 0\n  INLINE operator char() const { return (char)(Base::V); }\n  INLINE operator signed char() const { return (signed char)(Base::V); }\n  INLINE operator unsigned char() const { return (unsigned char)(Base::V); }\n  INLINE operator short() const { return (short)(Base::V); }\n  INLINE operator unsigned short() const { return (unsigned short)(Base::V); }\n  INLINE operator int() const { return (int)(Base::V); }\n  INLINE operator unsigned int () const { return (unsigned)(Base::V); }\n  INLINE operator long () const { return (long)(Base::V); }\n  INLINE operator unsigned long () const { return (unsigned long)(Base::V); }\n  INLINE operator ap_slong () { return (ap_slong)(Base::V); }\n  INLINE operator ap_ulong () { return (ap_ulong)(Base::V); }\n#endif\n\n  /* Helper methods.\n     ----------------------------------------------------------------\n  */\n  /* we cannot call a non-volatile function on a volatile instance.\n   * but calling a volatile function is ok.\n   * XXX deleted non-volatile version.\n   */\n  INLINE int length() const volatile { return _AP_W; }\n\n  /*Return true if the value of ap_int_base instance is zero*/\n  INLINE bool iszero() const { return Base::V == 0; }\n\n  /*Return true if the value of ap_int_base instance is zero*/\n  INLINE bool is_zero() const { return Base::V == 0; }\n\n  /* x < 0 */\n  INLINE bool sign() const {\n    if (_AP_S &&\n        _AP_ROOT_op_get_bit(Base::V, _AP_W - 1))\n      return true;\n    else\n      return false;\n  }\n\n  /* x[i] = 0 */\n  INLINE void clear(int i) {\n    AP_ASSERT(i >= 0 && i < _AP_W, \"position out of range\");\n    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);\n  }\n\n  /* x[i] = !x[i]*/\n  INLINE void invert(int i) {\n    AP_ASSERT(i >= 0 && i < _AP_W, \"position out of range\");\n    bool val = _AP_ROOT_op_get_bit(Base::V, i);\n    if (val)\n      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);\n    else\n      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);\n  }\n\n  INLINE bool test(int i) const {\n    AP_ASSERT(i >= 0 && i < _AP_W, \"position out of range\");\n    return _AP_ROOT_op_get_bit(Base::V, i);\n  }\n\n  // Get self. For ap_concat_ref expansion.\n  INLINE ap_int_base& get() { return *this; }\n\n  // Set the ith bit into 1\n  INLINE void set(int i) {\n    AP_ASSERT(i >= 0 && i < _AP_W, \"position out of range\");\n    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);\n  }\n\n  // Set the ith bit into v\n  INLINE void set(int i, bool v) {\n    AP_ASSERT(i >= 0 && i < _AP_W, \"position out of range\");\n    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_int_base object n places to the left\n  INLINE ap_int_base& lrotate(int n) {\n    AP_ASSERT(n >= 0 && n < _AP_W, \"shift value out of range\");\n    // TODO unify this.\n#ifdef __SYNTHESIS__\n    typeof(Base::V) l_p = Base::V << n;\n    typeof(Base::V) r_p = Base::V >> (_AP_W - n);\n    Base::V = l_p | r_p;\n#else\n    Base::V.lrotate(n);\n#endif\n    return *this;\n  }\n\n  // This is used for sc_lv and sc_bv, which is implemented by sc_uint\n  // Rotate an ap_int_base object n places to the right\n  INLINE ap_int_base& rrotate(int n) {\n    AP_ASSERT(n >= 0 && n < _AP_W, \"shift value out of range\");\n    // TODO unify this.\n#ifdef __SYNTHESIS__\n    typeof(Base::V) l_p = Base::V << (_AP_W - n);\n    typeof(Base::V) r_p = Base::V >> n;\n    Base::V = l_p | r_p;\n#else\n    Base::V.rrotate(n);\n#endif\n    return *this;\n  }\n\n  // Reverse the contents of ap_int_base instance.\n  // I.e. LSB becomes MSB and vise versa.\n  INLINE ap_int_base& reverse() {\n    Base::V = _AP_ROOT_op_get_range(Base::V, _AP_W - 1, 0);\n    return *this;\n  }\n\n  // Set the ith bit into v\n  INLINE void set_bit(int i, bool v) {\n    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);\n  }\n\n  // Get the value of ith bit\n  INLINE bool get_bit(int i) const {\n    return (bool)_AP_ROOT_op_get_bit(Base::V, i);\n  }\n\n  // complements every bit\n  INLINE void b_not() { Base::V = ~Base::V; }\n\n#define OP_ASSIGN_AP(Sym)                                                    \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_int_base& operator Sym(const ap_int_base<_AP_W2, _AP_S2>& op2) { \\\n    Base::V Sym op2.V;                                                       \\\n    return *this;                                                            \\\n  }\n\n  /* Arithmetic assign.\n   * ----------------------------------------------------------------\n   */\n  OP_ASSIGN_AP(*=)\n  OP_ASSIGN_AP(+=)\n  OP_ASSIGN_AP(-=)\n  OP_ASSIGN_AP(/=)\n  OP_ASSIGN_AP(%=)\n#undef OP_ASSIGN_AP\n\n  /* Bitwise assign: and, or, xor.\n   * ----------------------------------------------------------------\n   */\n#define OP_ASSIGN_AP_CHK(Sym)                                                \\\n  template <int _AP_W2, bool _AP_S2>                                         \\\n  INLINE ap_int_base& operator Sym(const ap_int_base<_AP_W2, _AP_S2>& op2) { \\\n    _AP_WARNING((_AP_W != _AP_W2),                                           \\\n                \"Bitsize mismatch for ap_[u]int\" #Sym \"ap_[u]int.\");         \\\n    Base::V Sym op2.V;                                                       \\\n    return *this;                                                            \\\n  }\n  OP_ASSIGN_AP_CHK(&=)\n  OP_ASSIGN_AP_CHK(|=)\n  OP_ASSIGN_AP_CHK(^=)\n#undef OP_ASSIGN_AP_CHK\n\n  /* Prefix increment, decrement.\n   * ----------------------------------------------------------------\n   */\n  INLINE ap_int_base& operator++() {\n    operator+=((ap_int_base<1, false>)1);\n    return *this;\n  }\n  INLINE ap_int_base& operator--() {\n    operator-=((ap_int_base<1, false>)1);\n    return *this;\n  }\n\n  /* Postfix increment, decrement\n   * ----------------------------------------------------------------\n   */\n  INLINE const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {\n    ap_int_base t = *this;\n    operator+=((ap_int_base<1, false>)1);\n    return t;\n  }\n  INLINE const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {\n    ap_int_base t = *this;\n    operator-=((ap_int_base<1, false>)1);\n    return t;\n  }\n\n  /* Unary arithmetic.\n   * ----------------------------------------------------------------\n   */\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }\n\n  // TODO used to be W>64 only... need check.\n  INLINE typename RType<1, false>::minus operator-() const {\n    return ap_int_base<1, false>(0) - *this;\n  }\n\n  /* Not (!)\n   * ----------------------------------------------------------------\n   */\n  INLINE bool operator!() const { return Base::V == 0; }\n\n  /* Bitwise (arithmetic) unary: complement\n     ----------------------------------------------------------------\n  */\n  // XXX different from Mentor's ac_int!\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator~() const {\n    ap_int_base<_AP_W, _AP_S> r;\n    r.V = ~Base::V;\n    return r;\n  }\n\n  /* Shift (result constrained by left operand).\n   * ----------------------------------------------------------------\n   */\n  template <int _AP_W2>\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {\n    bool isNeg = _AP_ROOT_op_get_bit(op2.V, _AP_W2 - 1);\n    ap_int_base<_AP_W2, false> sh = op2;\n    if (isNeg) {\n      sh = -op2;\n      return operator>>(sh);\n    } else\n      return operator<<(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {\n    ap_int_base r;\n    r.V = Base::V << op2.to_uint();\n    return r;\n  }\n\n  template <int _AP_W2>\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {\n    bool isNeg = _AP_ROOT_op_get_bit(op2.V, _AP_W2 - 1);\n    ap_int_base<_AP_W2, false> sh = op2;\n    if (isNeg) {\n      sh = -op2;\n      return operator<<(sh);\n    }\n    return operator>>(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {\n    ap_int_base r;\n    r.V = Base::V >> op2.to_uint();\n    return r;\n  }\n\n  // FIXME we standalone operator>> for ap_int_base and ap_range_ref.\n#if 0\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base operator<<(const ap_range_ref<_AP_W2, _AP_S2>& op2) const {\n    return *this << (op2.operator ap_int_base<_AP_W2, false>());\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base operator>>(const ap_range_ref<_AP_W2, _AP_S2>& op2) const {\n    return *this >> (op2.operator ap_int_base<_AP_W2, false>());\n  }\n#endif\n\n  /* Shift assign\n   * ----------------------------------------------------------------\n   */\n  template <int _AP_W2>\n  INLINE ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {\n    bool isNeg = _AP_ROOT_op_get_bit(op2.V, _AP_W2 - 1);\n    ap_int_base<_AP_W2, false> sh = op2;\n    if (isNeg) {\n      sh = -op2;\n      return operator>>=(sh);\n    } else\n      return operator<<=(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {\n    Base::V <<= op2.to_uint();\n    return *this;\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {\n    bool isNeg = _AP_ROOT_op_get_bit(op2.V, _AP_W2 - 1);\n    ap_int_base<_AP_W2, false> sh = op2;\n    if (isNeg) {\n      sh = -op2;\n      return operator<<=(sh);\n    }\n    return operator>>=(sh);\n  }\n\n  template <int _AP_W2>\n  INLINE ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {\n    Base::V >>= op2.to_uint();\n    return *this;\n  }\n\n  // FIXME we standalone operator>> for ap_int_base and ap_range_ref.\n#if 0\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator<<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return *this <<= (op2.operator ap_int_base<_AP_W2, false>());\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_int_base& operator>>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return *this >>= (op2.operator ap_int_base<_AP_W2, false>());\n  }\n#endif\n\n  /* Equality and Relational.\n   * ----------------------------------------------------------------\n   */\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return Base::V == op2.V;\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return !(Base::V == op2.V);\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return Base::V < op2.V;\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return Base::V >= op2.V;\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return Base::V > op2.V;\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {\n    return Base::V <= op2.V;\n  }\n\n  /* Bit and Part Select\n   * ----------------------------------------------------------------\n   */\n  INLINE ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {\n    _AP_ERROR(Hi >= _AP_W, \"Hi(%d)out of bound(%d) in range()\", Hi, _AP_W);\n    _AP_ERROR(Lo >= _AP_W, \"Lo(%d)out of bound(%d) in range()\", Lo, _AP_W);\n    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);\n  }\n\n  // This is a must to strip constness to produce reference type.\n  INLINE ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {\n    _AP_ERROR(Hi >= _AP_W, \"Hi(%d)out of bound(%d) in range()\", Hi, _AP_W);\n    _AP_ERROR(Lo >= _AP_W, \"Lo(%d)out of bound(%d) in range()\", Lo, _AP_W);\n    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE ap_range_ref<_AP_W, _AP_S> range(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE ap_range_ref<_AP_W, _AP_S> range(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  INLINE ap_range_ref<_AP_W, _AP_S> range() {\n    return this->range(_AP_W - 1, 0);\n  }\n\n  INLINE ap_range_ref<_AP_W, _AP_S> range() const {\n    return this->range(_AP_W - 1, 0);\n  }\n\n  INLINE ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {\n    return this->range(Hi, Lo);\n  }\n\n  INLINE ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE ap_range_ref<_AP_W, _AP_S> operator()(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>\n  INLINE ap_range_ref<_AP_W, _AP_S> operator()(\n      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,\n      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {\n    int Hi = HiIdx.to_int();\n    int Lo = LoIdx.to_int();\n    return this->range(Hi, Lo);\n  }\n\n#if 0\n  template<int Hi, int Lo>\n  INLINE ap_int_base<Hi-Lo+1, false> slice() const {\n    AP_ASSERT(Hi >= Lo && Hi < _AP_W && Lo < _AP_W, \"Out of bounds in slice()\");\n    ap_int_base<Hi-Lo+1, false> tmp ;\n    tmp.V = _AP_ROOT_op_get_range(Base::V, Lo, Hi);\n    return tmp;\n  }\n\n  INLINE ap_bit_ref<_AP_W,_AP_S> operator [] ( unsigned int uindex) {\n    AP_ASSERT(uindex < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W,_AP_S> bvh( this, uindex );\n    return bvh;\n  }\n#endif\n\n  INLINE ap_bit_ref<_AP_W, _AP_S> operator[](int index) {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);\n    return bvh;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_bit_ref<_AP_W, _AP_S> operator[](\n      const ap_int_base<_AP_W2, _AP_S2>& index) {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());\n    return bvh;\n  }\n\n  INLINE bool operator[](int index) const {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> br(this, index);\n    return br.to_bool();\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());\n    return br.to_bool();\n  }\n\n  INLINE ap_bit_ref<_AP_W, _AP_S> bit(int index) {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);\n    return bvh;\n  }\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_bit_ref<_AP_W, _AP_S> bit(\n      const ap_int_base<_AP_W2, _AP_S2>& index) {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());\n    return bvh;\n  }\n\n  INLINE bool bit(int index) const {\n    AP_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W, _AP_S> br(this, index);\n    return br.to_bool();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {\n    return bit(index.to_int());\n  }\n\n#if 0\n  template<typename _AP_T>\n  INLINE bool operator[](_AP_T index) const {\n    AP_ASSERT(index < _AP_W, \"Attempting to read bit beyond MSB\");\n    ap_bit_ref<_AP_W,_AP_S> br = operator[](index);\n    return br.to_bool();\n  }\n#endif\n\n  // Count the number of zeros from the most significant bit\n  // to the first one bit.\n  INLINE int countLeadingZeros() {\n#ifdef __SYNTHESIS__\n    if (_AP_W <= 32) {\n      ap_int_base<32, false> t(-1UL), x;\n      x.V = _AP_ROOT_op_get_range(this->V, _AP_W - 1, 0); // reverse\n      t.V = _AP_ROOT_op_set_range(t.V, 0, _AP_W - 1, x.V);\n      return __builtin_ctz(t.V); // count trailing zeros.\n    } else if (_AP_W <= 64) {\n      ap_int_base<64, false> t(-1ULL);\n      ap_int_base<64, false> x;\n      x.V = _AP_ROOT_op_get_range(this->V, _AP_W - 1, 0); // reverse\n      t.V = _AP_ROOT_op_set_range(t.V, 0, _AP_W - 1, x.V);\n      return __builtin_ctzll(t.V); // count trailing zeros.\n    } else {\n      enum { __N = (_AP_W + 63) / 64 };\n      int NZeros = 0;\n      int i = 0;\n      bool hitNonZero = false;\n      for (i = 0; i < __N - 1; ++i) {\n        ap_int_base<64, false> t;\n        t.V = _AP_ROOT_op_get_range(this->V, _AP_W - i * 64 - 64, _AP_W - i * 64 - 1);\n        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V); // count leading zeros.\n        hitNonZero |= (t.V != 0);\n      }\n      if (!hitNonZero) {\n        ap_int_base<64, false> t(-1ULL);\n        enum { REST = (_AP_W - 1) % 64 };\n        ap_int_base<64, false> x;\n        x.V = _AP_ROOT_op_get_range(this->V, 0, REST);\n        t.V = _AP_ROOT_op_set_range(t.V, 63 - REST, 63, x.V);\n        NZeros += __builtin_clzll(t.V);\n      }\n      return NZeros;\n    }\n#else\n    return (Base::V).countLeadingZeros();\n#endif\n  } // countLeadingZeros\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_range_ref<_AP_W2, _AP_S2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {\n    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >\n  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(\n        *this, a2);\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,\n                                                                         a2);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<\n      _AP_W, ap_int_base, _AP_W2,\n      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n                &a2) const {\n    return ap_concat_ref<\n        _AP_W, ap_int_base, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<\n            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<\n      _AP_W, ap_int_base, _AP_W2,\n      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n    return ap_concat_ref<\n        _AP_W, ap_int_base, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,\n                                                                       a2);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_int_base, 1,\n                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n                    &a2) const {\n    return ap_concat_ref<\n        _AP_W, ap_int_base, 1,\n        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),\n        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_int_base, 1,\n                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n      operator,(\n          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n    return ap_concat_ref<\n        _AP_W, ap_int_base, 1,\n        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int_base<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator&(\n      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n    return *this & a2.get();\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int_base<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator|(\n      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n    return *this | a2.get();\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_int_base<AP_MAX(_AP_W2 + _AP_W3, _AP_W), _AP_S> operator^(\n      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {\n    return *this ^ a2.get();\n  }\n\n  template <int _AP_W3>\n  INLINE void set(const ap_int_base<_AP_W3, false>& val) {\n    Base::V = val.V;\n  }\n\n  /* Reduce operations.\n   * ----------------------------------------------------------------\n   */\n  // XXX non-const version deleted.\n  INLINE bool and_reduce() const { return _AP_ROOT_op_reduce(and, Base::V); }\n  INLINE bool nand_reduce() const { return _AP_ROOT_op_reduce(nand, Base::V); }\n  INLINE bool or_reduce() const { return _AP_ROOT_op_reduce(or, Base::V); }\n  INLINE bool nor_reduce() const { return !(_AP_ROOT_op_reduce(or, Base::V)); }\n  INLINE bool xor_reduce() const { return _AP_ROOT_op_reduce (xor, Base::V); }\n  INLINE bool xnor_reduce() const {\n    return !(_AP_ROOT_op_reduce (xor, Base::V));\n  }\n\n  /* Output as a string.\n   * ----------------------------------------------------------------\n   */\n#ifndef __SYNTHESIS__\n  std::string to_string(signed char rd = 2, bool sign = _AP_S) const {\n    // XXX in autosim/autowrap.tcl \"(${name}).to_string(2).c_str()\" is used to\n    // initialize sc_lv, which seems incapable of handling format \"-0b\".\n    if (rd == 2) sign = false;\n    return (Base::V).to_string(rd, sign);\n  }\n#else\n  INLINE char* to_string(signed char rd = 2, bool sign = _AP_S) const {\n    return 0;\n  }\n#endif\n}; // struct ap_int_base\n\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, bool _AP_S>\nINLINE std::ostream& operator<<(std::ostream& os,\n                                const ap_int_base<_AP_W, _AP_S>& x) {\n  std::ios_base::fmtflags ff = std::cout.flags();\n  if (ff & std::cout.hex) {\n    os << x.to_string(16); // don't print sign\n  } else if (ff & std::cout.oct) {\n    os << x.to_string(8); // don't print sign\n  } else {\n    os << x.to_string(10);\n  }\n  return os;\n}\n#endif // ifndef __SYNTHESIS__\n\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, bool _AP_S>\nINLINE std::istream& operator>>(std::istream& in,\n                                ap_int_base<_AP_W, _AP_S>& op) {\n  std::string str;\n  in >> str;\n  const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;\n  unsigned radix = (basefield == std::ios_base::dec) ? 0 : (\n                     (basefield == std::ios_base::oct) ? 8 : (\n                       (basefield == std::ios_base::hex) ? 16 : 0));\n  op = ap_int_base<_AP_W, _AP_S>(str.c_str(), radix);\n  return in;\n}\n#endif // ifndef __SYNTHESIS__\n#endif // ifndef AP_AUTOCC\n\n/* Operators with another ap_int_base.\n * ----------------------------------------------------------------\n */\n#define OP_BIN_AP(Sym, Rty)                                                   \\\n  template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2>                   \\\n  INLINE                                                                      \\\n      typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::Rty \\\n      operator Sym(const ap_int_base<_AP_W, _AP_S>& op,                       \\\n                   const ap_int_base<_AP_W2, _AP_S2>& op2) {                  \\\n    typename ap_int_base<_AP_W, _AP_S>::template RType<                       \\\n        _AP_W2, _AP_S2>::Rty##_base lhs(op);                                  \\\n    typename ap_int_base<_AP_W, _AP_S>::template RType<                       \\\n        _AP_W2, _AP_S2>::Rty##_base rhs(op2);                                 \\\n    typename ap_int_base<_AP_W, _AP_S>::template RType<                       \\\n        _AP_W2, _AP_S2>::Rty##_base ret;                                      \\\n    ret.V = lhs.V Sym rhs.V;                                                  \\\n    return ret;                                                               \\\n  }\n\nOP_BIN_AP(*, mult)\nOP_BIN_AP(+, plus)\nOP_BIN_AP(-, minus)\nOP_BIN_AP(&, logic)\nOP_BIN_AP(|, logic)\nOP_BIN_AP(^, logic)\n\n#define OP_BIN_AP2(Sym, Rty)                                                  \\\n  template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2>                   \\\n  INLINE                                                                      \\\n      typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::Rty \\\n      operator Sym(const ap_int_base<_AP_W, _AP_S>& op,                       \\\n                   const ap_int_base<_AP_W2, _AP_S2>& op2) {                  \\\n    typename ap_int_base<_AP_W, _AP_S>::template RType<                       \\\n        _AP_W2, _AP_S2>::Rty##_base ret;                                      \\\n    ret.V = op.V Sym op2.V;                                                   \\\n    return ret;                                                               \\\n  }\n\nOP_BIN_AP2(/, div)\nOP_BIN_AP2(%, mod)\n\n// shift operators are defined inside class.\n// compound assignment operators are defined inside class.\n\n/* Operators with a pointer type.\n * ----------------------------------------------------------------\n *   char a[100];\n *   char* ptr = a;\n *   ap_int<2> n = 3;\n *   char* ptr2 = ptr + n*2;\n * avoid ambiguous errors.\n */\n#define OP_BIN_WITH_PTR(BIN_OP)                                           \\\n  template <typename PTR_TYPE, int _AP_W, bool _AP_S>                     \\\n  INLINE PTR_TYPE* operator BIN_OP(PTR_TYPE* i_op,                        \\\n                                   const ap_int_base<_AP_W, _AP_S>& op) { \\\n    ap_slong op2 = op.to_int64(); /* Not all implementation */            \\\n    return i_op BIN_OP op2;                                               \\\n  }                                                                       \\\n  template <typename PTR_TYPE, int _AP_W, bool _AP_S>                     \\\n  INLINE PTR_TYPE* operator BIN_OP(const ap_int_base<_AP_W, _AP_S>& op,   \\\n                                   PTR_TYPE* i_op) {                      \\\n    ap_slong op2 = op.to_int64(); /* Not all implementation */            \\\n    return op2 BIN_OP i_op;                                               \\\n  }\n\nOP_BIN_WITH_PTR(+)\nOP_BIN_WITH_PTR(-)\n\n/* Operators with a native floating point types.\n * ----------------------------------------------------------------\n */\n// float OP ap_int\n// when ap_int<wa>'s width > 64, then trunc ap_int<w> to ap_int<64>\n#define OP_BIN_WITH_FLOAT(BIN_OP, C_TYPE)                              \\\n  template <int _AP_W, bool _AP_S>                                     \\\n  INLINE C_TYPE operator BIN_OP(C_TYPE i_op,                           \\\n                                const ap_int_base<_AP_W, _AP_S>& op) { \\\n    typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op;              \\\n    return i_op BIN_OP op2;                                            \\\n  }                                                                    \\\n  template <int _AP_W, bool _AP_S>                                     \\\n  INLINE C_TYPE operator BIN_OP(const ap_int_base<_AP_W, _AP_S>& op,   \\\n                                C_TYPE i_op) {                         \\\n    typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op;              \\\n    return op2 BIN_OP i_op;                                            \\\n  }\n\n#define ALL_OP_WITH_FLOAT(C_TYPE) \\\n  OP_BIN_WITH_FLOAT(*, C_TYPE) \\\n  OP_BIN_WITH_FLOAT(/, C_TYPE) \\\n  OP_BIN_WITH_FLOAT(+, C_TYPE) \\\n  OP_BIN_WITH_FLOAT(-, C_TYPE)\n\nALL_OP_WITH_FLOAT(half)\nALL_OP_WITH_FLOAT(float)\nALL_OP_WITH_FLOAT(double)\n\n// TODO no shift?\n\n/* Operators with a native integral types.\n * ----------------------------------------------------------------\n */\n// arithmetic and bitwise operators.\n#define OP_BIN_WITH_INT(BIN_OP, C_TYPE, _AP_W2, _AP_S2, RTYPE)             \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,        \\\n                                                            _AP_S2>::RTYPE \\\n  operator BIN_OP(C_TYPE i_op, const ap_int_base<_AP_W, _AP_S>& op) {      \\\n    return ap_int_base<_AP_W2, _AP_S2>(i_op) BIN_OP(op);                   \\\n  }                                                                        \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,        \\\n                                                            _AP_S2>::RTYPE \\\n  operator BIN_OP(const ap_int_base<_AP_W, _AP_S>& op, C_TYPE i_op) {      \\\n    return op BIN_OP ap_int_base<_AP_W2, _AP_S2>(i_op);                    \\\n  }\n\n#define ALL_OP_BIN_WITH_INT(C_TYPE, _AP_W2, _AP_S2)    \\\n  OP_BIN_WITH_INT(*, C_TYPE, _AP_W2, _AP_S2, mult)  \\\n  OP_BIN_WITH_INT(+, C_TYPE, _AP_W2, _AP_S2, plus)  \\\n  OP_BIN_WITH_INT(-, C_TYPE, _AP_W2, _AP_S2, minus) \\\n  OP_BIN_WITH_INT(/, C_TYPE, _AP_W2, _AP_S2, div)   \\\n  OP_BIN_WITH_INT(%, C_TYPE, _AP_W2, _AP_S2, mod)   \\\n  OP_BIN_WITH_INT(&, C_TYPE, _AP_W2, _AP_S2, logic) \\\n  OP_BIN_WITH_INT(|, C_TYPE, _AP_W2, _AP_S2, logic) \\\n  OP_BIN_WITH_INT(^, C_TYPE, _AP_W2, _AP_S2, logic)\n\nALL_OP_BIN_WITH_INT(bool, 1, false)\nALL_OP_BIN_WITH_INT(char, 8, CHAR_IS_SIGNED)\nALL_OP_BIN_WITH_INT(signed char, 8, true)\nALL_OP_BIN_WITH_INT(unsigned char, 8, false)\nALL_OP_BIN_WITH_INT(short, _AP_SIZE_short, true)\nALL_OP_BIN_WITH_INT(unsigned short, _AP_SIZE_short, false)\nALL_OP_BIN_WITH_INT(int, _AP_SIZE_int, true)\nALL_OP_BIN_WITH_INT(unsigned int, _AP_SIZE_int, false)\nALL_OP_BIN_WITH_INT(long, _AP_SIZE_long, true)\nALL_OP_BIN_WITH_INT(unsigned long, _AP_SIZE_long, false)\nALL_OP_BIN_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nALL_OP_BIN_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef OP_BIN_WITH_INT\n#undef ALL_OP_BIN_WITH_INT\n\n// shift operators.\n#define ALL_OP_SHIFT_WITH_INT(C_TYPE, _AP_W2, _AP_S2)    \\\n  template <int _AP_W, bool _AP_S>                       \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<(           \\\n      const ap_int_base<_AP_W, _AP_S>& op, C_TYPE op2) { \\\n    ap_int_base<_AP_W, _AP_S> r;                         \\\n    if (_AP_S2)                                          \\\n      r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); \\\n    else                                                 \\\n      r.V = op.V << op2;                                 \\\n    return r;                                            \\\n  }                                                      \\\n  template <int _AP_W, bool _AP_S>                       \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>(           \\\n      const ap_int_base<_AP_W, _AP_S>& op, C_TYPE op2) { \\\n    ap_int_base<_AP_W, _AP_S> r;                         \\\n    if (_AP_S2)                                          \\\n      r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); \\\n    else                                                 \\\n      r.V = op.V >> op2;                                 \\\n    return r;                                            \\\n  }\n\nALL_OP_SHIFT_WITH_INT(char, 8, CHAR_IS_SIGNED)\nALL_OP_SHIFT_WITH_INT(signed char, 8, true)\nALL_OP_SHIFT_WITH_INT(short, _AP_SIZE_short, true)\nALL_OP_SHIFT_WITH_INT(int, _AP_SIZE_int, true)\nALL_OP_SHIFT_WITH_INT(long, _AP_SIZE_long, true)\nALL_OP_SHIFT_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\n\n#undef ALL_OP_SHIFT_WITH_INT\n\n#define ALL_OP_SHIFT_WITH_INT(C_TYPE, _AP_W2, _AP_S2)    \\\n  template <int _AP_W, bool _AP_S>                       \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<(           \\\n      const ap_int_base<_AP_W, _AP_S>& op, C_TYPE op2) { \\\n    ap_int_base<_AP_W, _AP_S> r;                         \\\n    r.V = op.V << op2;                                   \\\n    return r;                                            \\\n  }                                                      \\\n  template <int _AP_W, bool _AP_S>                       \\\n  INLINE typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>(           \\\n      const ap_int_base<_AP_W, _AP_S>& op, C_TYPE op2) { \\\n    ap_int_base<_AP_W, _AP_S> r;                         \\\n    r.V = op.V >> op2;                                   \\\n    return r;                                            \\\n  }\nALL_OP_SHIFT_WITH_INT(bool, 1, false)\nALL_OP_SHIFT_WITH_INT(unsigned char, 8, false)\nALL_OP_SHIFT_WITH_INT(unsigned short, _AP_SIZE_short, false)\nALL_OP_SHIFT_WITH_INT(unsigned int, _AP_SIZE_int, false)\nALL_OP_SHIFT_WITH_INT(unsigned long, _AP_SIZE_long, false)\nALL_OP_SHIFT_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef ALL_OP_SHIFT_WITH_INT\n\n// compound assign operators.\n#define OP_ASSIGN_WITH_INT(ASSIGN_OP, C_TYPE, _AP_W2, _AP_S2)       \\\n  template <int _AP_W, bool _AP_S>                                  \\\n  INLINE ap_int_base<_AP_W, _AP_S>& operator ASSIGN_OP(             \\\n      ap_int_base<_AP_W, _AP_S>& op, C_TYPE op2) {                  \\\n    return op ASSIGN_OP ap_int_base<_AP_W2, _AP_S2>(op2);           \\\n  }\n\n// TODO int a; ap_int<16> b; a += b;\n\n#define ALL_OP_ASSIGN_WITH_INT(C_TYPE, _AP_W2, _AP_S2) \\\n  OP_ASSIGN_WITH_INT(+=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(-=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(*=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(/=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(%=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(&=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(|=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(^=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_ASSIGN_WITH_INT(>>=, C_TYPE, _AP_W2, _AP_S2)      \\\n  OP_ASSIGN_WITH_INT(<<=, C_TYPE, _AP_W2, _AP_S2)\n\nALL_OP_ASSIGN_WITH_INT(bool, 1, false)\nALL_OP_ASSIGN_WITH_INT(char, 8, CHAR_IS_SIGNED)\nALL_OP_ASSIGN_WITH_INT(signed char, 8, true)\nALL_OP_ASSIGN_WITH_INT(unsigned char, 8, false)\nALL_OP_ASSIGN_WITH_INT(short, _AP_SIZE_short, true)\nALL_OP_ASSIGN_WITH_INT(unsigned short, _AP_SIZE_short, false)\nALL_OP_ASSIGN_WITH_INT(int, _AP_SIZE_int, true)\nALL_OP_ASSIGN_WITH_INT(unsigned int, _AP_SIZE_int, false)\nALL_OP_ASSIGN_WITH_INT(long, _AP_SIZE_long, true)\nALL_OP_ASSIGN_WITH_INT(unsigned long, _AP_SIZE_long, false)\nALL_OP_ASSIGN_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nALL_OP_ASSIGN_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef OP_ASSIGN_WITH_INT\n#undef ALL_OP_ASSIGN_WITH_INT\n\n// equality and relational operators.\n#define OP_REL_WITH_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)              \\\n  template <int _AP_W, bool _AP_S>                                   \\\n  INLINE bool operator REL_OP(C_TYPE i_op,                           \\\n                              const ap_int_base<_AP_W, _AP_S>& op) { \\\n    return ap_int_base<_AP_W2, _AP_S2>(i_op) REL_OP op;              \\\n  }                                                                  \\\n  template <int _AP_W, bool _AP_S>                                   \\\n  INLINE bool operator REL_OP(const ap_int_base<_AP_W, _AP_S>& op,   \\\n                              C_TYPE op2) {                          \\\n    return op REL_OP ap_int_base<_AP_W2, _AP_S2>(op2);               \\\n  }\n\n#define ALL_OP_REL_WITH_INT(C_TYPE, _AP_W2, _AP_S2) \\\n  OP_REL_WITH_INT(>, C_TYPE, _AP_W2, _AP_S2)        \\\n  OP_REL_WITH_INT(<, C_TYPE, _AP_W2, _AP_S2)        \\\n  OP_REL_WITH_INT(>=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_REL_WITH_INT(<=, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_REL_WITH_INT(==, C_TYPE, _AP_W2, _AP_S2)       \\\n  OP_REL_WITH_INT(!=, C_TYPE, _AP_W2, _AP_S2)\n\nALL_OP_REL_WITH_INT(bool, 1, false)\nALL_OP_REL_WITH_INT(char, 8, CHAR_IS_SIGNED)\nALL_OP_REL_WITH_INT(signed char, 8, true)\nALL_OP_REL_WITH_INT(unsigned char, 8, false)\nALL_OP_REL_WITH_INT(short, _AP_SIZE_short, true)\nALL_OP_REL_WITH_INT(unsigned short, _AP_SIZE_short, false)\nALL_OP_REL_WITH_INT(int, _AP_SIZE_int, true)\nALL_OP_REL_WITH_INT(unsigned int, _AP_SIZE_int, false)\nALL_OP_REL_WITH_INT(long, _AP_SIZE_long, true)\nALL_OP_REL_WITH_INT(unsigned long, _AP_SIZE_long, false)\nALL_OP_REL_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nALL_OP_REL_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef OP_REL_WITH_INT\n#undef ALL_OP_BIN_WITH_INT\n\n#define OP_REL_WITH_DOUBLE_OR_FLOAT(Sym)                            \\\n  template <int _AP_W, bool _AP_S>                                  \\\n  INLINE bool operator Sym(const ap_int_base<_AP_W, _AP_S>& op1,    \\\n                           double op2) {                            \\\n    return op1.to_double() Sym op2 ;                                \\\n  }                                                                 \\\n  template <int _AP_W, bool _AP_S>                                  \\\n  INLINE bool operator Sym(double op1,                              \\\n                           const ap_int_base<_AP_W, _AP_S>& op2) {  \\\n    return op1 Sym op2.to_double() ;                                \\\n  }                                                                 \\\n  template <int _AP_W, bool _AP_S>                                  \\\n  INLINE bool operator Sym(const ap_int_base<_AP_W, _AP_S>& op1,    \\\n                           float op2) {                             \\\n    return op1.to_double() Sym op2 ;                                \\\n  }                                                                 \\\n  template <int _AP_W, bool _AP_S>                                  \\\n  INLINE bool operator Sym(float op1,                               \\\n                           const ap_int_base<_AP_W, _AP_S>& op2) {  \\\n    return op1 Sym op2.to_double() ;                                \\\n  }\n  OP_REL_WITH_DOUBLE_OR_FLOAT(>)\n  OP_REL_WITH_DOUBLE_OR_FLOAT(<)\n  OP_REL_WITH_DOUBLE_OR_FLOAT(>=)\n  OP_REL_WITH_DOUBLE_OR_FLOAT(<=)\n  OP_REL_WITH_DOUBLE_OR_FLOAT(==)\n  OP_REL_WITH_DOUBLE_OR_FLOAT(!=)\n\n#undef OP_REL_WITH_DOUBLE_OR_FLOAT\n\n\n/* Operators with ap_bit_ref.\n * ------------------------------------------------------------\n */\n// arithmetic, bitwise and shift operators.\n#define OP_BIN_WITH_RANGE(BIN_OP, RTYPE)                                     \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                \\\n  INLINE typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2,        \\\n                                                              _AP_S2>::RTYPE \\\n  operator BIN_OP(const ap_range_ref<_AP_W1, _AP_S1>& op1,                   \\\n                  const ap_int_base<_AP_W2, _AP_S2>& op2) {                  \\\n    return ap_int_base<_AP_W1, false>(op1) BIN_OP op2;                       \\\n  }                                                                          \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                \\\n  INLINE typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2,        \\\n                                                              _AP_S2>::RTYPE \\\n  operator BIN_OP(const ap_int_base<_AP_W1, _AP_S1>& op1,                    \\\n                  const ap_range_ref<_AP_W2, _AP_S2>& op2) {                 \\\n    return op1 BIN_OP ap_int_base<_AP_W2, false>(op2);                       \\\n  }\n\nOP_BIN_WITH_RANGE(+, plus)\nOP_BIN_WITH_RANGE(-, minus)\nOP_BIN_WITH_RANGE(*, mult)\nOP_BIN_WITH_RANGE(/, div)\nOP_BIN_WITH_RANGE(%, mod)\nOP_BIN_WITH_RANGE(&, logic)\nOP_BIN_WITH_RANGE(|, logic)\nOP_BIN_WITH_RANGE(^, logic)\nOP_BIN_WITH_RANGE(>>, arg1)\nOP_BIN_WITH_RANGE(<<, arg1)\n\n#undef OP_BIN_WITH_RANGE\n\n// compound assignment operators.\n#define OP_ASSIGN_WITH_RANGE(ASSIGN_OP)                       \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_int_base<_AP_W1, _AP_S1>& operator ASSIGN_OP(     \\\n      ap_int_base<_AP_W1, _AP_S1>& op1,                       \\\n      const ap_range_ref<_AP_W2, _AP_S2>& op2) {              \\\n    return op1 ASSIGN_OP ap_int_base<_AP_W2, false>(op2);     \\\n  }                                                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_range_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP(    \\\n      ap_range_ref<_AP_W1, _AP_S1>& op1,                      \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {               \\\n    ap_int_base<_AP_W1, false> tmp(op1);                      \\\n    tmp ASSIGN_OP op2;                                        \\\n    op1 = tmp;                                                \\\n    return op1;                                               \\\n  }\n\nOP_ASSIGN_WITH_RANGE(+=)\nOP_ASSIGN_WITH_RANGE(-=)\nOP_ASSIGN_WITH_RANGE(*=)\nOP_ASSIGN_WITH_RANGE(/=)\nOP_ASSIGN_WITH_RANGE(%=)\nOP_ASSIGN_WITH_RANGE(>>=)\nOP_ASSIGN_WITH_RANGE(<<=)\n\n#undef OP_ASSIGN_WITH_RANGE\n\n// compound assignment operators\n// as range could be dynamic, do not check whether two integers are of same\n// width.\n#define OP_ASSIGN_WITH_RANGE(ASSIGN_OP)                       \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_int_base<_AP_W1, _AP_S1>& operator ASSIGN_OP(     \\\n      ap_int_base<_AP_W1, _AP_S1>& op1,                       \\\n      const ap_range_ref<_AP_W2, _AP_S2>& op2) {              \\\n    ap_int_base<_AP_W2, false> tmp(op2);                      \\\n    op1.V ASSIGN_OP tmp.V;                                    \\\n    return op1;                                               \\\n  }                                                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_range_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP(    \\\n      ap_range_ref<_AP_W1, _AP_S1>& op1,                      \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {               \\\n    ap_int_base<_AP_W1, false> tmp(op1);                      \\\n    tmp.V ASSIGN_OP op2.V;                                    \\\n    op1 = tmp;                                                \\\n    return op1;                                               \\\n  }\n\nOP_ASSIGN_WITH_RANGE(&=)\nOP_ASSIGN_WITH_RANGE(|=)\nOP_ASSIGN_WITH_RANGE(^=)\n\n#undef OP_ASSIGN_WITH_RANGE\n\n// equality and relational operators\n#define OP_REL_WITH_RANGE(REL_OP)                                          \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>              \\\n  INLINE bool operator REL_OP(const ap_range_ref<_AP_W1, _AP_S1>& op1,     \\\n                              const ap_int_base<_AP_W2, _AP_S2>& op2) {    \\\n    return ap_int_base<_AP_W1, false>(op1).operator REL_OP(op2);           \\\n  }                                                                        \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>              \\\n  INLINE bool operator REL_OP(const ap_int_base<_AP_W1, _AP_S1>& op1,      \\\n                              const ap_range_ref<_AP_W2, _AP_S2>& op2) {   \\\n    return op1.operator REL_OP(op2.operator ap_int_base<_AP_W2, false>()); \\\n  }\n\nOP_REL_WITH_RANGE(==)\nOP_REL_WITH_RANGE(!=)\nOP_REL_WITH_RANGE(>)\nOP_REL_WITH_RANGE(>=)\nOP_REL_WITH_RANGE(<)\nOP_REL_WITH_RANGE(<=)\n\n#undef OP_REL_WITH_RANGE\n\n/* Operators with ap_bit_ref.\n * ------------------------------------------------------------\n */\n// arithmetic, bitwise and shift operators.\n#define OP_BIN_WITH_BIT(BIN_OP, RTYPE)                                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                  \\\n  INLINE typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::RTYPE \\\n  operator BIN_OP(const ap_int_base<_AP_W1, _AP_S1>& op1,                      \\\n                  const ap_bit_ref<_AP_W2, _AP_S2>& op2) {                     \\\n    return op1 BIN_OP ap_int_base<1, false>(op2);                              \\\n  }                                                                            \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>                  \\\n  INLINE typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::RTYPE \\\n  operator BIN_OP(const ap_bit_ref<_AP_W1, _AP_S1>& op1,                       \\\n                  const ap_int_base<_AP_W2, _AP_S2>& op2) {                    \\\n    return ap_int_base<1, false>(op1) BIN_OP op2;                              \\\n  }\n\nOP_BIN_WITH_BIT(+, plus)\nOP_BIN_WITH_BIT(-, minus)\nOP_BIN_WITH_BIT(*, mult)\nOP_BIN_WITH_BIT(/, div)\nOP_BIN_WITH_BIT(%, mod)\nOP_BIN_WITH_BIT(&, logic)\nOP_BIN_WITH_BIT(|, logic)\nOP_BIN_WITH_BIT(^, logic)\nOP_BIN_WITH_BIT(>>, arg1)\nOP_BIN_WITH_BIT(<<, arg1)\n\n#undef OP_BIN_WITH_BIT\n\n// compound assignment operators.\n#define OP_ASSIGN_WITH_BIT(ASSIGN_OP)                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_int_base<_AP_W1, _AP_S1>& operator ASSIGN_OP(     \\\n      ap_int_base<_AP_W1, _AP_S1>& op1,                       \\\n      const ap_bit_ref<_AP_W2, _AP_S2>& op2) {                \\\n    return op1 ASSIGN_OP ap_int_base<1, false>(op2);          \\\n  }                                                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_bit_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP(      \\\n      ap_bit_ref<_AP_W1, _AP_S1>& op1,                        \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {               \\\n    ap_int_base<1, false> tmp(op1);                           \\\n    tmp ASSIGN_OP op2;                                        \\\n    op1 = tmp;                                                \\\n    return op1;                                               \\\n  }\n\nOP_ASSIGN_WITH_BIT(+=)\nOP_ASSIGN_WITH_BIT(-=)\nOP_ASSIGN_WITH_BIT(*=)\nOP_ASSIGN_WITH_BIT(/=)\nOP_ASSIGN_WITH_BIT(%=)\nOP_ASSIGN_WITH_BIT(>>=)\nOP_ASSIGN_WITH_BIT(<<=)\n\n#undef OP_ASSIGN_WITH_BIT\n\n// compound assignment operators.\n// as range could be dynamic, do not check whether two integers are of same\n// width.\n#define OP_ASSIGN_WITH_BIT(ASSIGN_OP)                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_int_base<_AP_W1, _AP_S1>& operator ASSIGN_OP(     \\\n      ap_int_base<_AP_W1, _AP_S1>& op1,                       \\\n      const ap_bit_ref<_AP_W2, _AP_S2>& op2) {                \\\n    ap_int_base<1, false> tmp(op2);                           \\\n    op1.V ASSIGN_OP tmp.V;                                    \\\n    return op1;                                               \\\n  }                                                           \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> \\\n  INLINE ap_bit_ref<_AP_W1, _AP_S1>& operator ASSIGN_OP(      \\\n      ap_bit_ref<_AP_W1, _AP_S1>& op1,                        \\\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {               \\\n    ap_int_base<1, false> tmp(op1);                           \\\n    tmp.V ASSIGN_OP op2.V;                                    \\\n    op1 = tmp;                                                \\\n    return op1;                                               \\\n  }\n\nOP_ASSIGN_WITH_BIT(&=)\nOP_ASSIGN_WITH_BIT(|=)\nOP_ASSIGN_WITH_BIT(^=)\n\n#undef OP_ASSIGN_WITH_BIT\n\n// equality and relational operators.\n#define OP_REL_WITH_BIT(REL_OP)                                         \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>           \\\n  INLINE bool operator REL_OP(const ap_int_base<_AP_W1, _AP_S1>& op1,   \\\n                              const ap_bit_ref<_AP_W2, _AP_S2>& op2) {  \\\n    return op1 REL_OP ap_int_base<1, false>(op2);                       \\\n  }                                                                     \\\n  template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2>           \\\n  INLINE bool operator REL_OP(const ap_bit_ref<_AP_W1, _AP_S1>& op1,    \\\n                              const ap_int_base<_AP_W2, _AP_S2>& op2) { \\\n    return ap_int_base<1, false>(op1) REL_OP op2;                       \\\n  }\n\nOP_REL_WITH_BIT(==)\nOP_REL_WITH_BIT(!=)\nOP_REL_WITH_BIT(>)\nOP_REL_WITH_BIT(>=)\nOP_REL_WITH_BIT(<)\nOP_REL_WITH_BIT(<=)\n\n#undef OP_REL_WITH_BIT\n\n\n/* Operators with ap_concat_ref.\n * ------------------------------------------------------------\n */\n// arithmetic, bitwise and shift operators.\n// bitwise operators are defined in struct.\n// TODO specify whether to define arithmetic and bitwise operators.\n#if 0\n#define OP_BIN_WITH_CONCAT(BIN_OP, RTYPE)                                      \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2,          \\\n            int _AP_W3, bool _AP_S3>                                           \\\n  INLINE typename ap_int_base<_AP_W3, _AP_S3>::template RType<_AP_W1 + _AP_W2, \\\n                                                              false>::RTYPE    \\\n  operator BIN_OP(const ap_int_base<_AP_W3, _AP_S3>& op1,                      \\\n                  const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) {  \\\n    /* convert ap_concat_ref to ap_int_base */                                 \\\n    return op1 BIN_OP op2.get();                                               \\\n  }                                                                            \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2,          \\\n            int _AP_W3, bool _AP_S3>                                           \\\n  INLINE typename ap_int_base<_AP_W1 + _AP_W2,                                 \\\n                              false>::template RType<_AP_W3, _AP_S3>::RTYPE    \\\n  operator BIN_OP(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1,    \\\n                  const ap_int_base<_AP_W3, _AP_S3>& op2) {                    \\\n    /* convert ap_concat_ref to ap_int_base */                                 \\\n    return op1.get() BIN_OP op2;                                               \\\n  }\n\nOP_BIN_WITH_CONCAT(+, plus)\nOP_BIN_WITH_CONCAT(-, minus)\nOP_BIN_WITH_CONCAT(*, mult)\nOP_BIN_WITH_CONCAT(/, div)\nOP_BIN_WITH_CONCAT(%, mod)\nOP_BIN_WITH_CONCAT(&, logic)\nOP_BIN_WITH_CONCAT(|, logic)\nOP_BIN_WITH_CONCAT(^, logic)\nOP_BIN_WITH_CONCAT(>>, arg1)\nOP_BIN_WITH_CONCAT(<<, arg1)\n\n#undef OP_BIN_WITH_CONCAT\n\n// compound assignment operators.\n#define OP_ASSIGN_WITH_CONCAT(ASSIGN_OP)                                       \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2,          \\\n            int _AP_W3, bool _AP_S3>                                           \\\n  INLINE typename ap_int_base<_AP_W3, _AP_S3>::template RType<_AP_W1 + _AP_W2, \\\n                                                              false>::RTYPE    \\\n  operator ASSIGN_OP(                                                          \\\n      const ap_int_base<_AP_W3, _AP_S3>& op1,                                  \\\n      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) {              \\\n    /* convert ap_concat_ref to ap_int_base */                                 \\\n    return op1 ASSIGN_OP op2.get();                                            \\\n  }                                                                            \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2,          \\\n            int _AP_W3, bool _AP_S3>                                           \\\n  INLINE typename ap_int_base<_AP_W1 + _AP_W2,                                 \\\n                              false>::template RType<_AP_W3, _AP_S3>::RTYPE    \\\n  operator ASSIGN_OP(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, \\\n                     const ap_int_base<_AP_W3, _AP_S3>& op2) {                 \\\n    /* convert ap_concat_ref to ap_int_base */                                 \\\n    ap_int_base<_AP_W1 + _AP_W2, false> tmp = op1.get();                       \\\n    tmp ASSIGN_OP op2;                                                         \\\n    op1 = tmp;                                                                 \\\n    return op1;                                                                \\\n  }\n\nOP_ASSIGN_WITH_CONCAT(+=)\nOP_ASSIGN_WITH_CONCAT(-=)\nOP_ASSIGN_WITH_CONCAT(*=)\nOP_ASSIGN_WITH_CONCAT(/=)\nOP_ASSIGN_WITH_CONCAT(%=)\nOP_ASSIGN_WITH_CONCAT(&=)\nOP_ASSIGN_WITH_CONCAT(|=)\nOP_ASSIGN_WITH_CONCAT(^=)\nOP_ASSIGN_WITH_CONCAT(>>=)\nOP_ASSIGN_WITH_CONCAT(<<=)\n\n#undef OP_ASSIGN_WITH_CONCAT\n#endif\n\n// equality and relational operators.\n#define OP_REL_WITH_CONCAT(REL_OP)                                    \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, \\\n            int _AP_W3, bool _AP_S3>                                  \\\n  INLINE bool operator REL_OP(                                        \\\n      const ap_int_base<_AP_W3, _AP_S3>& op1,                         \\\n      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) {     \\\n    /* convert ap_concat_ref to ap_int_base */                        \\\n    return op1 REL_OP op2.get();                                      \\\n  }                                                                   \\\n  template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, \\\n            int _AP_W3, bool _AP_S3>                                  \\\n  INLINE bool operator REL_OP(                                        \\\n      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1,       \\\n      const ap_int_base<_AP_W3, _AP_S3>& op2) {                       \\\n    /* convert ap_concat_ref to ap_int_base */                        \\\n    return op1.get() REL_OP op2;                                      \\\n  }\n\nOP_REL_WITH_CONCAT(==)\nOP_REL_WITH_CONCAT(!=)\nOP_REL_WITH_CONCAT(>)\nOP_REL_WITH_CONCAT(>=)\nOP_REL_WITH_CONCAT(<)\nOP_REL_WITH_CONCAT(<=)\n\n#undef OP_REL_WITH_CONCAT\n\n#endif // ifndef __cplusplus else\n#endif // ifndef __AP_INT_BASE_H__ else\n\n\n",
    "ap_int_ref.h": "// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n*/\n\n#ifndef __AP_INT_REF_H__\n#define __AP_INT_REF_H__\n\n#ifndef __AP_INT_H__\n// TODO make this an error\n#pragma message \\\n    \"Only ap_fixed.h and ap_int.h can be included directly in user code.\"\n#endif\n\n#ifndef __cplusplus\n#error \"C++ is required to include this header file\"\n\n#else\n\n#ifndef __SYNTHESIS__\n#include \"iostream\"\n#endif\n\n/* Concatination reference.\n   ----------------------------------------------------------------\n*/\ntemplate <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>\nstruct ap_concat_ref {\n  enum {\n    _AP_WR = _AP_W1 + _AP_W2,\n  };\n\n  _AP_T1& mbv1;\n  _AP_T2& mbv2;\n\n  INLINE ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)\n      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}\n\n  INLINE ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);\n    int W_ref1 = mbv1.length();\n    int W_ref2 = mbv2.length();\n    ap_int_base<_AP_W1, false> Part1;\n    Part1.V = _AP_ROOT_op_get_range(vval.V, W_ref2, W_ref1 + W_ref2 - 1);\n    mbv1.set(Part1);\n    ap_int_base<_AP_W2, false> Part2;\n    Part2.V = _AP_ROOT_op_get_range(vval.V, 0, W_ref2 - 1);\n    mbv2.set(Part2);\n    return *this;\n  }\n\n  // assign op from hls supported C integral types.\n  // FIXME disabled to support legacy code directly assign from sc_signal<T>\n  //template <typename T>\n  //INLINE typename _ap_type::enable_if<_ap_type::is_integral<T>::value,\n  //                                    ap_concat_ref&>::type\n  //operator=(T val) {\n  //  ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);\n  //  return operator=(tmpVal);\n  //}\n#define ASSIGN_WITH_CTYPE(_Tp)                       \\\n  INLINE ap_concat_ref& operator=(_Tp val) {         \\\n    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); \\\n    return operator=(tmpVal);                        \\\n  }\n\n  ASSIGN_WITH_CTYPE(bool)\n  ASSIGN_WITH_CTYPE(char)\n  ASSIGN_WITH_CTYPE(signed char)\n  ASSIGN_WITH_CTYPE(unsigned char)\n  ASSIGN_WITH_CTYPE(short)\n  ASSIGN_WITH_CTYPE(unsigned short)\n  ASSIGN_WITH_CTYPE(int)\n  ASSIGN_WITH_CTYPE(unsigned int)\n  ASSIGN_WITH_CTYPE(long)\n  ASSIGN_WITH_CTYPE(unsigned long)\n  ASSIGN_WITH_CTYPE(ap_slong)\n  ASSIGN_WITH_CTYPE(ap_ulong)\n  ASSIGN_WITH_CTYPE(half)\n  ASSIGN_WITH_CTYPE(float)\n  ASSIGN_WITH_CTYPE(double)\n\n#undef ASSIGN_WITH_CTYPE\n\n  // Be explicit to prevent it from being deleted, as field d_bv\n  // is of reference type.\n  INLINE ap_concat_ref& operator=(\n      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);\n    return operator=(tmpVal);\n  }\n\n  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>\n  INLINE ap_concat_ref& operator=(\n      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);\n    return operator=(tmpVal);\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);\n    return operator=(tmpVal);\n  }\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);\n    return operator=(tmpVal);\n  }\n\n  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n            ap_o_mode _AP_O3, int _AP_N3>\n  INLINE ap_concat_ref& operator=(\n      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {\n    return operator=((const ap_int_base<_AP_W3, false>)(val));\n  }\n\n  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n            ap_o_mode _AP_O3, int _AP_N3>\n  INLINE ap_concat_ref& operator=(\n      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&\n          val) {\n    return operator=(val.to_ap_int_base());\n  }\n\n  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n            ap_o_mode _AP_O3, int _AP_N3>\n  INLINE ap_concat_ref& operator=(\n      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {\n    return operator=((ap_ulong)(bool)(val));\n  }\n\n  INLINE operator ap_int_base<_AP_WR, false>() const { return get(); }\n\n  INLINE operator ap_ulong() const { return get().to_uint64(); }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                       ap_range_ref<_AP_W3, _AP_S3> >\n  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                         ap_range_ref<_AP_W3, _AP_S3> >(\n        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE\n      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >\n      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE\n      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >\n      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                         ap_int_base<_AP_W3, _AP_S3> >(\n        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE\n      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >\n      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                         ap_int_base<_AP_W3, _AP_S3> >(\n        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE\n      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >\n      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {\n    // FIXME op's life does not seem long enough\n    ap_int_base<_AP_W3, _AP_S3> op(a2);\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,\n                         ap_int_base<_AP_W3, _AP_S3> >(\n        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >\n  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(\n        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));\n  }\n\n  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>\n  INLINE ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,\n                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >\n  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {\n    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,\n                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(\n        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));\n  }\n\n  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n            ap_o_mode _AP_O3, int _AP_N3>\n  INLINE ap_concat_ref<\n      _AP_WR, ap_concat_ref, _AP_W3,\n      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >\n  operator,(\n      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {\n    return ap_concat_ref<\n        _AP_WR, ap_concat_ref, _AP_W3,\n        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(\n        *this,\n        const_cast<\n            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));\n  }\n\n  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,\n            ap_o_mode _AP_O3, int _AP_N3>\n  INLINE\n      ap_concat_ref<_AP_WR, ap_concat_ref, 1,\n                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >\n      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>\n                    &a2) {\n    return ap_concat_ref<\n        _AP_WR, ap_concat_ref, 1,\n        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(\n        *this,\n        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(\n            a2));\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_int_base<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator&(\n      const ap_int_base<_AP_W3, _AP_S3>& a2) {\n    return get() & a2;\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_int_base<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator|(\n      const ap_int_base<_AP_W3, _AP_S3>& a2) {\n    return get() | a2;\n  }\n\n  template <int _AP_W3, bool _AP_S3>\n  INLINE ap_int_base<AP_MAX(_AP_WR, _AP_W3), _AP_S3> operator^(\n      const ap_int_base<_AP_W3, _AP_S3>& a2) {\n    return get() ^ a2;\n  }\n\n#if 0\n  template<int Hi, int Lo>\n  INLINE ap_int_base<Hi-Lo+1, false> slice() {\n    ap_int_base<_AP_WR, false> bv = get();\n    return bv.slice<Hi,Lo>();\n  }\n#endif\n\n  INLINE ap_int_base<_AP_WR, false> get() const {\n    ap_int_base<_AP_WR, false> tmpVal(0);\n    int W_ref1 = mbv1.length();\n    int W_ref2 = mbv2.length();\n    ap_int_base<_AP_W2, false> v2(mbv2);\n    ap_int_base<_AP_W1, false> v1(mbv1);\n    tmpVal.V = _AP_ROOT_op_set_range(tmpVal.V, 0, W_ref2 - 1, v2.V);\n    tmpVal.V =\n        _AP_ROOT_op_set_range(tmpVal.V, W_ref2, W_ref1 + W_ref2 - 1, v1.V);\n    return tmpVal;\n  }\n\n  template <int _AP_W3>\n  INLINE void set(const ap_int_base<_AP_W3, false>& val) {\n    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);\n    int W_ref1 = mbv1.length();\n    int W_ref2 = mbv2.length();\n    ap_int_base<_AP_W1, false> tmpVal1;\n    tmpVal1.V = _AP_ROOT_op_get_range(vval.V, W_ref2, W_ref1 + W_ref2 - 1);\n    mbv1.set(tmpVal1);\n    ap_int_base<_AP_W2, false> tmpVal2;\n    tmpVal2.V = _AP_ROOT_op_get_range(vval.V, 0, W_ref2 - 1);\n    mbv2.set(tmpVal2);\n  }\n\n  INLINE int length() const { return mbv1.length() + mbv2.length(); }\n}; // struct ap_concat_ref\n\n/* Range (slice) reference.\n   ----------------------------------------------------------------\n*/\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_range_ref {\n  // struct ssdm_int or its sim model.\n  // TODO make it possible to reference to ap_fixed_base/ap_fixed/ap_ufixed\n  //      and then we can retire af_range_ref.\n  typedef ap_int_base<_AP_W, _AP_S> ref_type;\n  ref_type& d_bv;\n  int l_index;\n  int h_index;\n\n public:\n  INLINE ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)\n      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}\n\n  INLINE ap_range_ref(ref_type* bv, int h, int l)\n      : d_bv(*bv), l_index(l), h_index(h) {}\n\n  INLINE ap_range_ref(const ref_type* bv, int h, int l)\n      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}\n\n  INLINE operator ap_int_base<_AP_W, false>() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret;\n  }\n\n  INLINE operator ap_ulong() const { return to_uint64(); }\n\n  /// @name assign operators\n  //  @{\n\n  // FIXME disabled to work-around lagacy code assigning from sc_signal<T>,\n  // which dependes on implicit type conversion.\n  //\n  //   /// assign from hls supported C integral types.\n  //   template <typename T>\n  //   INLINE typename _ap_type::enable_if<_ap_type::is_integral<T>::value,\n  //                                       ap_range_ref&>::type\n  //   operator=(T val) {\n  //     ap_int_base<_AP_W, false> tmp(val);\n  //     d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);\n  //     return *this;\n  //   }\n#define ASSIGN_WITH_CTYPE(_Tp)                                       \\\n  INLINE ap_range_ref& operator=(_Tp val) {                          \\\n    ap_int_base<_AP_W, false> tmp(val);                              \\\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); \\\n    return *this;                                                    \\\n  }\n\n  ASSIGN_WITH_CTYPE(bool)\n  ASSIGN_WITH_CTYPE(char)\n  ASSIGN_WITH_CTYPE(signed char)\n  ASSIGN_WITH_CTYPE(unsigned char)\n  ASSIGN_WITH_CTYPE(short)\n  ASSIGN_WITH_CTYPE(unsigned short)\n  ASSIGN_WITH_CTYPE(int)\n  ASSIGN_WITH_CTYPE(unsigned int)\n  ASSIGN_WITH_CTYPE(long)\n  ASSIGN_WITH_CTYPE(unsigned long)\n  ASSIGN_WITH_CTYPE(ap_slong)\n  ASSIGN_WITH_CTYPE(ap_ulong)\n  ASSIGN_WITH_CTYPE(half)\n  ASSIGN_WITH_CTYPE(float)\n  ASSIGN_WITH_CTYPE(double)\n\n#undef ASSIGN_WITH_CTYPE\n\n  /// assign using string. XXX crucial for cosim.\n  INLINE ap_range_ref& operator=(const char* val) {\n    const ap_int_base<_AP_W, false> tmp(val); // XXX figure out radix\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);\n    return *this;\n  }\n\n  /// assign from ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {\n    ap_int_base<_AP_W, false> tmp(val);\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);\n    return *this;\n  }\n\n  /// copy assign operator\n  // XXX Be explicit to prevent it from being deleted, as field d_bv\n  // is of reference type.\n  INLINE ap_range_ref& operator=(const ap_range_ref& val) {\n    return operator=((const ap_int_base<_AP_W, false>)val);\n  }\n\n  /// assign from range reference to ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {\n    return operator=((const ap_int_base<_AP_W2, false>)val);\n  }\n\n  /// assign from bit reference to ap_int_base.\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {\n    return operator=((ap_ulong)(bool)(val));\n  }\n\n  /// assign from ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_range_ref& operator=(\n      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&\n          val) {\n    return operator=(val.to_ap_int_base());\n  }\n\n  /// assign from range reference to ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_range_ref& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=((const ap_int_base<_AP_W2, false>)val);\n  }\n\n  /// assign from bit reference to ap_fixed_base.\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_range_ref& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=((ap_ulong)(bool)(val));\n  }\n\n  /// assign from compound reference.\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_range_ref& operator=(\n      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {\n    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));\n  }\n  //  @}\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,\n                         ap_range_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);\n  }\n\n  INLINE\n  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >\n  operator,(ap_int_base<_AP_W, _AP_S>& a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,\n                         ap_int_base<_AP_W, _AP_S> >(*this, a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,\n                         ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<\n      _AP_W, ap_range_ref, _AP_W2,\n      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {\n    return ap_concat_ref<\n        _AP_W, ap_range_ref, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<\n            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE\n      ap_concat_ref<_AP_W, ap_range_ref, 1,\n                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>\n                    &a2) {\n    return ap_concat_ref<\n        _AP_W, ap_range_ref, 1,\n        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> hop(op2);\n    return lop == hop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator==(op2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> hop(op2);\n    return lop < hop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    ap_int_base<_AP_W, false> lop(*this);\n    ap_int_base<_AP_W2, false> hop(op2);\n    return lop <= hop;\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator<=(op2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    return !(operator<(op2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator|=(\n      const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V |= (op2.d_bv).V;\n    return *this;\n  };\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator|=(\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V |= op2.V;\n    return *this;\n  };\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator&=(\n      const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V &= (op2.d_bv).V;\n    return *this;\n  };\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator&=(\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V &= op2.V;\n    return *this;\n  };\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator^=(\n      const ap_range_ref<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V ^= (op2.d_bv).V;\n    return *this;\n  };\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_range_ref<_AP_W, _AP_S>& operator^=(\n      const ap_int_base<_AP_W2, _AP_S2>& op2) {\n    (this->d_bv).V ^= op2.V;\n    return *this;\n  };\n\n  INLINE ap_int_base<_AP_W, false> get() const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret;\n  }\n\n  template <int _AP_W2>\n  INLINE void set(const ap_int_base<_AP_W2, false>& val) {\n    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);\n  }\n\n  INLINE int length() const {\n    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;\n  }\n\n  INLINE int to_int() const {\n    return (int)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE unsigned to_uint() const {\n    return (unsigned)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE long to_long() const {\n    return (long)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE unsigned long to_ulong() const {\n    return (unsigned long)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE ap_slong to_int64() const {\n    return (ap_slong)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE ap_ulong to_uint64() const {\n    return (ap_ulong)(_AP_ROOT_op_get_range(d_bv.V, l_index, h_index));\n  }\n\n  INLINE bool and_reduce() const {\n    bool ret = true;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) {\n#ifdef __SYNTHESIS__\n#pragma HLS unroll\n#endif\n      ret &= _AP_ROOT_op_get_bit(d_bv.V, i);\n    }\n    return ret;\n  }\n\n  INLINE bool or_reduce() const {\n    bool ret = false;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) {\n#ifdef __SYNTHESIS__\n#pragma HLS unroll\n#endif\n      ret |= _AP_ROOT_op_get_bit(d_bv.V, i);\n    }\n    return ret;\n  }\n\n  INLINE bool xor_reduce() const {\n    bool ret = false;\n    bool reverse = l_index > h_index;\n    unsigned low = reverse ? h_index : l_index;\n    unsigned high = reverse ? l_index : h_index;\n    for (unsigned i = low; i != high; ++i) {\n#ifdef __SYNTHESIS__\n#pragma HLS unroll\n#endif\n      ret ^= _AP_ROOT_op_get_bit(d_bv.V, i);\n    }\n    return ret;\n  }\n#ifndef __SYNTHESIS__\n  std::string to_string(signed char radix = 2) const {\n    ap_int_base<_AP_W, false> ret;\n    ret.V = _AP_ROOT_op_get_range(d_bv.V, l_index, h_index);\n    return ret.to_string(radix);\n  }\n#else\n  // XXX HLS will delete this in synthesis\n  INLINE char* to_string(signed char radix = 2) const {\n    return 0;\n  }\n#endif\n}; // struct ap_range_ref\n\n// XXX apcc cannot handle global std::ios_base::Init() brought in by <iostream>\n#ifndef AP_AUTOCC\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, bool _AP_S>\nINLINE std::ostream& operator<<(std::ostream& os,\n                                const ap_range_ref<_AP_W, _AP_S>& x) {\n  std::ios_base::fmtflags ff = std::cout.flags();\n  if (ff & std::cout.hex) {\n    os << x.to_string(16); // don't print sign\n  } else if (ff & std::cout.oct) {\n    os << x.to_string(8); // don't print sign\n  } else {\n    os << x.to_string(10);\n  }\n  return os;\n}\n#endif // ifndef __SYNTHESIS__\n\n#ifndef __SYNTHESIS__\ntemplate <int _AP_W, bool _AP_S>\nINLINE std::istream& operator>>(std::istream& in,\n                                ap_range_ref<_AP_W, _AP_S>& op) {\n  std::string str;\n  in >> str;\n  op = ap_int_base<_AP_W, _AP_S>(str.c_str());\n  return in;\n}\n#endif // ifndef __SYNTHESIS__\n#endif // ifndef AP_AUTOCC\n\n/* Bit reference.\n   ----------------------------------------------------------------\n*/\ntemplate <int _AP_W, bool _AP_S>\nstruct ap_bit_ref {\n  // struct ssdm_int or its sim model.\n  // TODO make it possible to reference to ap_fixed_base/ap_fixed/ap_ufixed\n  //      and then we can retire af_bit_ref.\n  typedef ap_int_base<_AP_W, _AP_S> ref_type;\n  ref_type& d_bv;\n  int d_index;\n\n public:\n  // copy ctor\n  INLINE ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)\n      : d_bv(ref.d_bv), d_index(ref.d_index) {}\n\n  INLINE ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}\n\n  INLINE ap_bit_ref(const ref_type* bv, int index = 0)\n      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}\n\n  INLINE operator bool() const { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n  INLINE bool to_bool() const { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n\n  // assign op from hls supported C integral types.\n  // FIXME disabled to support sc_signal<bool>.\n  // NOTE this used to be unsigned long long.\n  //template <typename T>\n  //INLINE typename _ap_type::enable_if<_ap_type::is_integral<T>::value,\n  //                                    ap_bit_ref&>::type\n  //operator=(T val) {\n  //  d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val);\n  //  return *this;\n  //}\n#define ASSIGN_WITH_CTYPE(_Tp)                          \\\n  INLINE ap_bit_ref& operator=(_Tp val) {               \\\n    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); \\\n    return *this;                                       \\\n  }\n\n  ASSIGN_WITH_CTYPE(bool)\n  ASSIGN_WITH_CTYPE(char)\n  ASSIGN_WITH_CTYPE(signed char)\n  ASSIGN_WITH_CTYPE(unsigned char)\n  ASSIGN_WITH_CTYPE(short)\n  ASSIGN_WITH_CTYPE(unsigned short)\n  ASSIGN_WITH_CTYPE(int)\n  ASSIGN_WITH_CTYPE(unsigned int)\n  ASSIGN_WITH_CTYPE(long)\n  ASSIGN_WITH_CTYPE(unsigned long)\n  ASSIGN_WITH_CTYPE(ap_slong)\n  ASSIGN_WITH_CTYPE(ap_ulong)\n\n#undef ASSIGN_WITH_CTYPE\n\n#define ASSIGN_WITH_CTYPE_FP(_Tp)                           \\\n  INLINE ap_bit_ref& operator=(_Tp val) {                   \\\n    bool tmp_val = val;                                     \\\n    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val);  \\\n    return *this;                                           \\\n  }\n\n  ASSIGN_WITH_CTYPE_FP(half)\n  ASSIGN_WITH_CTYPE_FP(float)\n  ASSIGN_WITH_CTYPE_FP(double)\n\n#undef ASSIGN_WITH_CTYPE_FP\n\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {\n    return operator=((ap_ulong)(val.V != 0));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {\n    return operator=((ap_int_base<_AP_W2, false>)val);\n  }\n\n  // Be explicit to prevent it from being deleted, as field d_bv\n  // is of reference type.\n  INLINE ap_bit_ref& operator=(const ap_bit_ref& val) {\n    return operator=((ap_ulong)(bool)val);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {\n    return operator=((ap_ulong)(bool)val);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_bit_ref& operator=(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=((const ap_int_base<_AP_W2, false>)val);\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_bit_ref& operator=(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {\n    return operator=((ap_ulong)(bool)val);\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_bit_ref& operator=(\n      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {\n    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(\n        *this, a2);\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {\n    ap_int_base<_AP_W2, _AP_S2> op(a2);\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >\n  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {\n    ap_int_base<_AP_W2, _AP_S2> op(a2);\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >\n  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(\n      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(\n        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));\n  }\n\n  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>\n  INLINE ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,\n                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >\n  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,\n                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(\n        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<\n      1, ap_bit_ref, _AP_W2,\n      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(\n      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n    return ap_concat_ref<\n        1, ap_bit_ref, _AP_W2,\n        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<\n            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));\n  }\n\n  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,\n            ap_o_mode _AP_O2, int _AP_N2>\n  INLINE ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,\n                                                    _AP_Q2, _AP_O2, _AP_N2> >\n  operator,(\n      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {\n    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,\n                                                      _AP_Q2, _AP_O2, _AP_N2> >(\n        *this,\n        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(\n            a2));\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {\n    return get() == op.get();\n  }\n\n  template <int _AP_W2, bool _AP_S2>\n  INLINE bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {\n    return get() != op.get();\n  }\n\n  INLINE bool get() const { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n\n  INLINE bool get() { return _AP_ROOT_op_get_bit(d_bv.V, d_index); }\n\n  template <int _AP_W3>\n  INLINE void set(const ap_int_base<_AP_W3, false>& val) {\n    operator=(val);\n  }\n\n  INLINE bool operator~() const {\n    bool bit = _AP_ROOT_op_get_bit(d_bv.V, d_index);\n    return bit ? false : true;\n  }\n\n  INLINE int length() const { return 1; }\n\n#ifndef __SYNTHESIS__\n  std::string to_string() const { return get() ? \"1\" : \"0\"; }\n#else\n  // XXX HLS will delete this in synthesis\n  INLINE char* to_string() const { return 0; }\n#endif\n}; // struct ap_bit_ref\n\n/* ap_range_ref with int.\n * ------------------------------------------------------------\n */\n// equality and relational operators.\n#define REF_REL_OP_WITH_INT(REL_OP, C_TYPE, _AP_W2, _AP_S2)                \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE bool operator REL_OP(const ap_range_ref<_AP_W, _AP_S>& op,        \\\n                              C_TYPE op2) {                                \\\n    return ap_int_base<_AP_W, false>(op)                                   \\\n        REL_OP ap_int_base<_AP_W2, _AP_S2>(op2);                           \\\n  }                                                                        \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE bool operator REL_OP(const ap_bit_ref<_AP_W, _AP_S>& op,          \\\n                              C_TYPE op2) {                                \\\n    return bool(op) REL_OP op2;                                            \\\n  }                                                                        \\\n  template <int _AP_W, bool _AP_S>                                         \\\n  INLINE bool operator REL_OP(C_TYPE op2,                                  \\\n                              const ap_bit_ref<_AP_W, _AP_S>& op) {        \\\n    return op2 REL_OP bool(op);                                            \\\n  }                                                                        \\\n  template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1>        \\\n  INLINE bool operator REL_OP(                                             \\\n      const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, C_TYPE op2) { \\\n    return ap_int_base<_AP_W + _AP_W1, false>(op)                          \\\n        REL_OP ap_int_base<_AP_W2, _AP_S2>(op2);                           \\\n  }\n\n// Make the line shorter than 5000 chars\n#define REF_REL_WITH_INT_1(C_TYPE, _AP_WI, _AP_SI) \\\n  REF_REL_OP_WITH_INT(>, C_TYPE, _AP_WI, _AP_SI)   \\\n  REF_REL_OP_WITH_INT(<, C_TYPE, _AP_WI, _AP_SI)   \\\n  REF_REL_OP_WITH_INT(>=, C_TYPE, _AP_WI, _AP_SI)  \\\n  REF_REL_OP_WITH_INT(<=, C_TYPE, _AP_WI, _AP_SI)\n\nREF_REL_WITH_INT_1(bool, 1, false)\nREF_REL_WITH_INT_1(char, 8, CHAR_IS_SIGNED)\nREF_REL_WITH_INT_1(signed char, 8, true)\nREF_REL_WITH_INT_1(unsigned char, 8, false)\nREF_REL_WITH_INT_1(short, _AP_SIZE_short, true)\nREF_REL_WITH_INT_1(unsigned short, _AP_SIZE_short, false)\nREF_REL_WITH_INT_1(int, _AP_SIZE_int, true)\nREF_REL_WITH_INT_1(unsigned int, _AP_SIZE_int, false)\nREF_REL_WITH_INT_1(long, _AP_SIZE_long, true)\nREF_REL_WITH_INT_1(unsigned long, _AP_SIZE_long, false)\nREF_REL_WITH_INT_1(ap_slong, _AP_SIZE_ap_slong, true)\nREF_REL_WITH_INT_1(ap_ulong, _AP_SIZE_ap_slong, false)\n\n// Make the line shorter than 5000 chars\n#define REF_REL_WITH_INT_2(C_TYPE, _AP_WI, _AP_SI) \\\n  REF_REL_OP_WITH_INT(==, C_TYPE, _AP_WI, _AP_SI)  \\\n  REF_REL_OP_WITH_INT(!=, C_TYPE, _AP_WI, _AP_SI)\n\nREF_REL_WITH_INT_2(bool, 1, false)\nREF_REL_WITH_INT_2(char, 8, CHAR_IS_SIGNED)\nREF_REL_WITH_INT_2(signed char, 8, true)\nREF_REL_WITH_INT_2(unsigned char, 8, false)\nREF_REL_WITH_INT_2(short, _AP_SIZE_short, true)\nREF_REL_WITH_INT_2(unsigned short, _AP_SIZE_short, false)\nREF_REL_WITH_INT_2(int, _AP_SIZE_int, true)\nREF_REL_WITH_INT_2(unsigned int, _AP_SIZE_int, false)\nREF_REL_WITH_INT_2(long, _AP_SIZE_long, true)\nREF_REL_WITH_INT_2(unsigned long, _AP_SIZE_long, false)\nREF_REL_WITH_INT_2(ap_slong, _AP_SIZE_ap_slong, true)\nREF_REL_WITH_INT_2(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef REF_REL_OP_WITH_INT\n#undef REF_REL_WITH_INT_1\n#undef REF_REL_WITH_INT_2\n\n#define REF_BIN_OP_WITH_INT(BIN_OP, RTYPE, C_TYPE, _AP_W2, _AP_S2)          \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE typename ap_int_base<_AP_W, false>::template RType<_AP_W2,         \\\n                                                            _AP_S2>::RTYPE  \\\n  operator BIN_OP(const ap_range_ref<_AP_W, _AP_S>& op, C_TYPE op2) {       \\\n    return ap_int_base<_AP_W, false>(op)                                    \\\n        BIN_OP ap_int_base<_AP_W2, _AP_S2>(op2);                            \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE typename ap_int_base<_AP_W2, _AP_S2>::template RType<_AP_W,        \\\n                                                              false>::RTYPE \\\n  operator BIN_OP(C_TYPE op2, const ap_range_ref<_AP_W, _AP_S>& op) {       \\\n    return ap_int_base<_AP_W2, _AP_S2>(op2)                                 \\\n        BIN_OP ap_int_base<_AP_W, false>(op);                               \\\n  }\n\n// arithmetic operators.\n#define REF_BIN_OP_WITH_INT_ARITH(C_TYPE, _AP_W2, _AP_S2)   \\\n  REF_BIN_OP_WITH_INT(+, plus, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_WITH_INT(-, minus, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_WITH_INT(*, mult, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_WITH_INT(/, div, C_TYPE, (_AP_W2), (_AP_S2))   \\\n  REF_BIN_OP_WITH_INT(%, mod, C_TYPE, (_AP_W2), (_AP_S2))\n\nREF_BIN_OP_WITH_INT_ARITH(bool, 1, false)\nREF_BIN_OP_WITH_INT_ARITH(char, 8, CHAR_IS_SIGNED)\nREF_BIN_OP_WITH_INT_ARITH(signed char, 8, true)\nREF_BIN_OP_WITH_INT_ARITH(unsigned char, 8, false)\nREF_BIN_OP_WITH_INT_ARITH(short, _AP_SIZE_short, true)\nREF_BIN_OP_WITH_INT_ARITH(unsigned short, _AP_SIZE_short, false)\nREF_BIN_OP_WITH_INT_ARITH(int, _AP_SIZE_int, true)\nREF_BIN_OP_WITH_INT_ARITH(unsigned int, _AP_SIZE_int, false)\nREF_BIN_OP_WITH_INT_ARITH(long, _AP_SIZE_long, true)\nREF_BIN_OP_WITH_INT_ARITH(unsigned long, _AP_SIZE_long, false)\nREF_BIN_OP_WITH_INT_ARITH(ap_slong, _AP_SIZE_ap_slong, true)\nREF_BIN_OP_WITH_INT_ARITH(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef REF_BIN_OP_WITH_INT_ARITH\n\n// bitwise and shift operators\n#define REF_BIN_OP_WITH_INT_BITS(C_TYPE, _AP_W2, _AP_S2)     \\\n  REF_BIN_OP_WITH_INT(&, logic, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_WITH_INT(|, logic, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_WITH_INT(^, logic, C_TYPE, (_AP_W2), (_AP_S2)) \\\n  REF_BIN_OP_WITH_INT(>>, arg1, C_TYPE, (_AP_W2), (_AP_S2))  \\\n  REF_BIN_OP_WITH_INT(<<, arg1, C_TYPE, (_AP_W2), (_AP_S2))\n\nREF_BIN_OP_WITH_INT_BITS(bool, 1, false)\nREF_BIN_OP_WITH_INT_BITS(char, 8, CHAR_IS_SIGNED)\nREF_BIN_OP_WITH_INT_BITS(signed char, 8, true)\nREF_BIN_OP_WITH_INT_BITS(unsigned char, 8, false)\nREF_BIN_OP_WITH_INT_BITS(short, _AP_SIZE_short, true)\nREF_BIN_OP_WITH_INT_BITS(unsigned short, _AP_SIZE_short, false)\nREF_BIN_OP_WITH_INT_BITS(int, _AP_SIZE_int, true)\nREF_BIN_OP_WITH_INT_BITS(unsigned int, _AP_SIZE_int, false)\nREF_BIN_OP_WITH_INT_BITS(long, _AP_SIZE_long, true)\nREF_BIN_OP_WITH_INT_BITS(unsigned long, _AP_SIZE_long, false)\nREF_BIN_OP_WITH_INT_BITS(ap_slong, _AP_SIZE_ap_slong, true)\nREF_BIN_OP_WITH_INT_BITS(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef REF_BIN_OP_WITH_INT_BITS\n\n/* ap_range_ref with ap_range_ref\n *  ------------------------------------------------------------\n */\n#define REF_BIN_OP(BIN_OP, RTYPE)                                              \\\n  template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2>                    \\\n  INLINE                                                                       \\\n      typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::RTYPE \\\n      operator BIN_OP(const ap_range_ref<_AP_W, _AP_S>& lhs,                   \\\n                      const ap_range_ref<_AP_W2, _AP_S2>& rhs) {               \\\n    return (lhs.operator ap_int_base<_AP_W, false>())BIN_OP(                   \\\n        rhs.operator ap_int_base<_AP_W2, false>());                            \\\n  }\n\nREF_BIN_OP(+, plus)\nREF_BIN_OP(-, minus)\nREF_BIN_OP(*, mult)\nREF_BIN_OP(/, div)\nREF_BIN_OP(%, mod)\nREF_BIN_OP(&, logic)\nREF_BIN_OP(|, logic)\nREF_BIN_OP(^, logic)\nREF_BIN_OP(>>, arg1)\nREF_BIN_OP(<<, arg1)\n\n/* ap_concat_ref with ap_concat_ref.\n *  ------------------------------------------------------------\n */\n\n//************************************************************************\n//  Implement\n//      ap_int_base<M+N> = ap_concat_ref<M> OP ap_concat_ref<N>\n//  for operators  +, -, *, /, %, >>, <<, &, |, ^\n//  Without these operators the operands are converted to int64 and\n//  larger results lose informations (higher order bits).\n//\n//                       operand OP\n//                      /          |\n//              left-concat         right-concat\n//                /     |            /         |\n//         <LW1,LT1>  <LW2,LT2>   <RW1,RT1>    <RW2,RT2>\n//\n//      _AP_LW1, _AP_LT1 (width and type of left-concat's left side)\n//      _AP_LW2, _AP_LT2 (width and type of left-concat's right side)\n//  Similarly for RHS of operand OP: _AP_RW1, AP_RW2, _AP_RT1, _AP_RT2\n//\n//  In Verilog 2001 result of concatenation is always unsigned even\n//  when both sides are signed.\n//************************************************************************\n\n#undef SYN_CONCAT_REF_BIN_OP\n\n#define SYN_CONCAT_REF_BIN_OP(BIN_OP, RTYPE)                              \\\n  template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, \\\n            int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> \\\n  INLINE typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType<  \\\n      _AP_RW1 + _AP_RW2, false>::RTYPE                                    \\\n  operator BIN_OP(                                                        \\\n      const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs,       \\\n      const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) {     \\\n    return lhs.get() BIN_OP rhs.get();                                    \\\n  }\n\nSYN_CONCAT_REF_BIN_OP(+, plus)\nSYN_CONCAT_REF_BIN_OP(-, minus)\nSYN_CONCAT_REF_BIN_OP(*, mult)\nSYN_CONCAT_REF_BIN_OP(/, div)\nSYN_CONCAT_REF_BIN_OP(%, mod)\nSYN_CONCAT_REF_BIN_OP(&, logic)\nSYN_CONCAT_REF_BIN_OP(|, logic)\nSYN_CONCAT_REF_BIN_OP(^, logic)\nSYN_CONCAT_REF_BIN_OP(>>, arg1)\nSYN_CONCAT_REF_BIN_OP(<<, arg1)\n\n#undef SYN_CONCAT_REF_BIN_OP\n\n#define CONCAT_OP_WITH_INT(C_TYPE, _AP_WI, _AP_SI)                          \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      const ap_int_base<_AP_W, _AP_S> &op1, C_TYPE op2) {                   \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op2);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op1);                            \\\n    ret <<= _AP_WI;                                                         \\\n    if (_AP_SI) {                                                           \\\n      val <<= _AP_W;                                                        \\\n      val >>= _AP_W;                                                        \\\n    }                                                                       \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      C_TYPE op1, const ap_int_base<_AP_W, _AP_S> &op2) {                   \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op1);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op2);                            \\\n    if (_AP_S) {                                                            \\\n      ret <<= _AP_WI;                                                       \\\n      ret >>= _AP_WI;                                                       \\\n    }                                                                       \\\n    ret |= val << _AP_W;                                                    \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      const ap_range_ref<_AP_W, _AP_S> &op1, C_TYPE op2) {                  \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op2);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op1);                            \\\n    ret <<= _AP_WI;                                                         \\\n    if (_AP_SI) {                                                           \\\n      val <<= _AP_W;                                                        \\\n      val >>= _AP_W;                                                        \\\n    }                                                                       \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      C_TYPE op1, const ap_range_ref<_AP_W, _AP_S> &op2) {                  \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op1);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op2);                            \\\n    int len = op2.length();                                                 \\\n    val <<= len;                                                            \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_WI + 1, false> operator,(                          \\\n      const ap_bit_ref<_AP_W, _AP_S> &op1, C_TYPE op2) {                    \\\n    ap_int_base<_AP_WI + 1, false> val(op2);                                \\\n    val[_AP_WI] = op1;                                                      \\\n    return val;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, bool _AP_S>                                          \\\n  INLINE ap_int_base<_AP_WI + 1, false> operator,(                          \\\n      C_TYPE op1, const ap_bit_ref<_AP_W, _AP_S> &op2) {                    \\\n    ap_int_base<_AP_WI + 1, false> val(op1);                                \\\n    val <<= 1;                                                              \\\n    val[0] = op2;                                                           \\\n    return val;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2>         \\\n  INLINE ap_int_base<_AP_W + _AP_W2 + _AP_WI, false> operator,(             \\\n      const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, C_TYPE op2) { \\\n    ap_int_base<_AP_WI + _AP_W + _AP_W2, _AP_SI> val(op2);                  \\\n    ap_int_base<_AP_WI + _AP_W + _AP_W2, _AP_SI> ret(op1);                  \\\n    if (_AP_SI) {                                                           \\\n      val <<= _AP_W + _AP_W2;                                               \\\n      val >>= _AP_W + _AP_W2;                                               \\\n    }                                                                       \\\n    ret <<= _AP_WI;                                                         \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2>         \\\n  INLINE ap_int_base<_AP_W + _AP_W2 + _AP_WI, false> operator,(             \\\n      C_TYPE op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { \\\n    ap_int_base<_AP_WI + _AP_W + _AP_W2, _AP_SI> val(op1);                  \\\n    ap_int_base<_AP_WI + _AP_W + _AP_W2, _AP_SI> ret(op2);                  \\\n    int len = op2.length();                                                 \\\n    val <<= len;                                                            \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1,    \\\n      C_TYPE op2) {                                                         \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op2);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op1);                            \\\n    if (_AP_SI) {                                                           \\\n      val <<= _AP_W;                                                        \\\n      val >>= _AP_W;                                                        \\\n    }                                                                       \\\n    ret <<= _AP_WI;                                                         \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE ap_int_base<_AP_W + _AP_WI, false> operator,(                      \\\n      C_TYPE op1,                                                           \\\n      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) {  \\\n    ap_int_base<_AP_WI + _AP_W, false> val(op1);                            \\\n    ap_int_base<_AP_WI + _AP_W, false> ret(op2);                            \\\n    int len = op2.length();                                                 \\\n    val <<= len;                                                            \\\n    ret |= val;                                                             \\\n    return ret;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE ap_int_base<1 + _AP_WI, false> operator,(                          \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1,      \\\n      C_TYPE op2) {                                                         \\\n    ap_int_base<_AP_WI + 1, _AP_SI> val(op2);                               \\\n    val[_AP_WI] = op1;                                                      \\\n    return val;                                                             \\\n  }                                                                         \\\n  template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,              \\\n            ap_o_mode _AP_O, int _AP_N>                                     \\\n  INLINE ap_int_base<1 + _AP_WI, false> operator,(                          \\\n      C_TYPE op1,                                                           \\\n      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) {    \\\n    ap_int_base<_AP_WI + 1, _AP_SI> val(op1);                               \\\n    val <<= 1;                                                              \\\n    val[0] = op2;                                                           \\\n    return val;                                                             \\\n  }\n\nCONCAT_OP_WITH_INT(bool, 1, false)\nCONCAT_OP_WITH_INT(char, 8, CHAR_IS_SIGNED)\nCONCAT_OP_WITH_INT(signed char, 8, true)\nCONCAT_OP_WITH_INT(unsigned char, 8, false)\nCONCAT_OP_WITH_INT(short, _AP_SIZE_short, true)\nCONCAT_OP_WITH_INT(unsigned short, _AP_SIZE_short, false)\nCONCAT_OP_WITH_INT(int, _AP_SIZE_int, true)\nCONCAT_OP_WITH_INT(unsigned int, _AP_SIZE_int, false)\nCONCAT_OP_WITH_INT(long, _AP_SIZE_long, true)\nCONCAT_OP_WITH_INT(unsigned long, _AP_SIZE_long, false)\nCONCAT_OP_WITH_INT(ap_slong, _AP_SIZE_ap_slong, true)\nCONCAT_OP_WITH_INT(ap_ulong, _AP_SIZE_ap_slong, false)\n\n#undef CONCAT_OP_WITH_INT\n\n#define CONCAT_SHIFT_WITH_INT(C_TYPE, OP)                                  \\\n  template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1>        \\\n  INLINE ap_uint<_AP_W + _AP_W1> operator OP(                              \\\n      const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, C_TYPE rhs) { \\\n    return ap_uint<_AP_W + _AP_W1>(lhs).get() OP int(rhs);                 \\\n  }\n\n// FIXME int(rhs) may loose precision.\n\nCONCAT_SHIFT_WITH_INT(int, <<)\nCONCAT_SHIFT_WITH_INT(unsigned int, <<)\nCONCAT_SHIFT_WITH_INT(long, <<)\nCONCAT_SHIFT_WITH_INT(unsigned long, <<)\nCONCAT_SHIFT_WITH_INT(ap_slong, <<)\nCONCAT_SHIFT_WITH_INT(ap_ulong, <<)\n\nCONCAT_SHIFT_WITH_INT(int, >>)\nCONCAT_SHIFT_WITH_INT(unsigned int, >>)\nCONCAT_SHIFT_WITH_INT(long, >>)\nCONCAT_SHIFT_WITH_INT(unsigned long, >>)\nCONCAT_SHIFT_WITH_INT(ap_slong, >>)\nCONCAT_SHIFT_WITH_INT(ap_ulong, >>)\n\n#endif // ifndef __cplusplus else\n#endif // ifndef __AP_INT_REF_H__ else\n\n// -*- cpp -*-\n\n\n",
    "hls_fpo.h": "/* -*- c -*-*/\n/*\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES. \n#- ************************************************************************\n\n *\n *\n */\n\n\n#ifndef __AESL_FPO_H__\n#define __AESL_FPO_H__\n\n#ifndef __SYNTHESIS__\n#include \"math.h\"\n#endif\n\n#include \"assert.h\"\n\n#if defined __arm__ && !(defined HLS_NO_XIL_FPO_LIB)\n#warning \"Xilinx Floating Point Operator IP core does not provide simulation models for ARM architecture.  Automatically defining HLS_NO_XIL_FPO_LIB in order to avoid this library dependency, although bit-accurate simulation of some functions is no longer possible.  You can make this warning go away by adding this define yourself before including any other files.\" \n#define HLS_NO_XIL_FPO_LIB\n#endif\n\n#ifdef __SYNTHESIS__\n#define HLS_FPO_SQRTF(a)               __builtin_sqrtf(a) \n#define HLS_FPO_SQRT(a)                __builtin_sqrt(a)   \n#define HLS_FPO_RECSQRTF(a)            (1.0f/__builtin_sqrtf(a))\n#define HLS_FPO_RECSQRT(a)             (1.0/__builtin_sqrt(a))\n#define HLS_FPO_ABSF(a)                __builtin_fabsf(a)\n#define HLS_FPO_ABS(a)                 __builtin_fabs(a)\n#define HLS_FPO_LOGF(a)                __builtin_logf(a)\n#define HLS_FPO_LOG(a)                 __builtin_log(a)\n#define HLS_FPO_EXPF(a)                __builtin_expf(a)\n#define HLS_FPO_EXP(a)                 __builtin_exp(a)\n#else// csim\n#ifdef HLS_NO_XIL_FPO_LIB\n#define HLS_FPO_SQRTF(a)               sqrtf(a) \n#define HLS_FPO_SQRT(a)                sqrt(a)   \n#define HLS_FPO_RECSQRTF(a)            (1.0f/sqrtf(a))\n#define HLS_FPO_RECSQRT(a)             (1.0/sqrt(a))\n#define HLS_FPO_ABSF(a)                fabsf(a)\n#define HLS_FPO_ABS(a)                 fabs(a)\n#define HLS_FPO_LOGF(a)                logf(a)\n#define HLS_FPO_LOG(a)                 log(a)\n#define HLS_FPO_EXPF(a)                expf(a)\n#define HLS_FPO_EXP(a)                 exp(a)\n#else\n#define HLS_FPO_SQRTF(a)               xil_fpo_sqrt_flt(a)\n#define HLS_FPO_SQRT(a)                xil_fpo_sqrt_d(a) \n#define HLS_FPO_RECSQRTF(a)            xil_fpo_recsqrt_flt(a)      \n#define HLS_FPO_RECSQRT(a)             xil_fpo_recsqrt_d(a)\n#define HLS_FPO_ABSF(a)                xil_fpo_abs_flt(a)\n#define HLS_FPO_ABS(a)                 xil_fpo_abs_d(a)\n#define HLS_FPO_LOGF(a)                xil_fpo_log_flt(a)\n#define HLS_FPO_LOG(a)                 xil_fpo_log_d(a)\n#define HLS_FPO_EXPF(a)                xil_fpo_exp_flt(a)\n#define HLS_FPO_EXP(a)                 xil_fpo_exp_d(a)\n#endif //HLS_NO_XIL_FPO_LIB\n#endif //__SYNTHESIS__\n\n#if (defined __SYNTHESIS__ || defined HLS_NO_XIL_FPO_LIB)\n#define HLS_FPO_ADDF(a,b)              ((a) + (b))\n#define HLS_FPO_ADD(a,b)               ((a) + (b))\n#define HLS_FPO_SUBF(a,b)              ((a) - (b))\n#define HLS_FPO_SUB(a,b)               ((a) - (b))\n#define HLS_FPO_MULF(a,b)              ((a) * (b))\n#define HLS_FPO_MUL(a,b)               ((a) * (b))\n#define HLS_FPO_DIVF(a,b)              ((a)/(b))\n#define HLS_FPO_DIV(a,b)               ((a)/(b))\n#define HLS_FPO_RECF(a)                (1.0f/(a))\n#define HLS_FPO_RECIPF(a)              HLS_FPO_RECF(a)\n#define HLS_FPO_REC(a)                 (1.0/(a))\n#define HLS_FPO_RECIP(a)               HLS_FPO_REC(a)\n#define HLS_FPO_RSQRTF(a)              HLS_FPO_RECSQRTF(a)\n#define HLS_FPO_RSQRT(a)               HLS_FPO_RECSQRT(a)\n//#define HLS_FPO_UNORDEREDF(a,b)\n//#define HLS_FPO_UNORDERED(a,b)\n#define HLS_FPO_EQUALF(a,b)            ((a) == (b))\n#define HLS_FPO_EQUAL(a,b)             ((a) == (b))  \n#define HLS_FPO_LESSF(a,b)             ((a) < (b))\n#define HLS_FPO_LESS(a,b)              ((a) < (b))\n#define HLS_FPO_LESSEQUALF(a,b)        ((a) <= (b)) \n#define HLS_FPO_LESSEQUAL(a,b)         ((a) <= (b))\n#define HLS_FPO_GREATERF(a,b)          ((a) > (b))\n#define HLS_FPO_GREATER(a,b)           ((a) > (b))  \n#define HLS_FPO_GREATEREQUALF(a,b)     ((a) >= (b)) \n#define HLS_FPO_GREATEREQUAL(a,b)      ((a) >= (b))\n#define HLS_FPO_NOTEQUALF(a,b)         ((a) != (b))\n#define HLS_FPO_NOTEQUAL(a,b)          ((a) != (b))      \n//#define HLS_FPO_CONDCODEF(a,b)\n//#define HLS_FPO_CONDCODE(a,b)\n#define HLS_FPO_FTOI(a)                ((int)(a))\n#define HLS_FPO_DTOI(a)                ((int)(a))        \n#define HLS_FPO_ITOF(a)                ((float)(a))      \n#define HLS_FPO_ITOD(a)                ((double)(a))        \n#define HLS_FPO_FTOF(a)                ((float)(a))      \n#define HLS_FPO_DTOF(a)                ((float)(a))        \n#define HLS_FPO_FTOD(a)                ((double)(a))        \n#define HLS_FPO_DTOD(a)                ((double)(a))          \n#else\n#define HLS_FPO_ADDF(a,b)              xil_fpo_add_flt(a,b)        \n#define HLS_FPO_ADD(a,b)               xil_fpo_add_d(a,b)\n#define HLS_FPO_SUBF(a,b)              xil_fpo_sub_flt(a,b)\n#define HLS_FPO_SUB(a,b)               xil_fpo_sub_d(a,b)\n#define HLS_FPO_MULF(a,b)              xil_fpo_mul_flt(a,b)\n#define HLS_FPO_MUL(a,b)               xil_fpo_mul_d(a,b)\n#define HLS_FPO_DIVF(a,b)              xil_fpo_div_flt(a,b)\n#define HLS_FPO_DIV(a,b)               xil_fpo_div_d(a,b)\n#define HLS_FPO_RECF(a)                xil_fpo_rec_flt(a)\n#define HLS_FPO_RECIPF(a)              HLS_FPO_RECF(a)\n#define HLS_FPO_REC(a)                 xil_fpo_rec_d(a)\n#define HLS_FPO_RECIP(a)               HLS_FPO_REC(a)\n#define HLS_FPO_RSQRTF(a)              HLS_FPO_RECSQRTF(a)\n#define HLS_FPO_RSQRT(a)               HLS_FPO_RECSQRT(a)\n#define HLS_FPO_UNORDEREDF(a,b)        xil_fpo_unordered_flt(a,b)\n#define HLS_FPO_UNORDERED(a,b)         xil_fpo_unordered_d(a,b)\n#define HLS_FPO_EQUALF(a,b)            xil_fpo_equal_flt(a,b)\n#define HLS_FPO_EQUAL(a,b)             xil_fpo_equal_d(a,b)\n#define HLS_FPO_LESSF(a,b)             xil_fpo_less_flt(a,b)\n#define HLS_FPO_LESS(a,b)              xil_fpo_less_d(a,b)\n#define HLS_FPO_LESSEQUALF(a,b)        xil_fpo_lessequal_flt(a,b)\n#define HLS_FPO_LESSEQUAL(a,b)         xil_fpo_lessequal_d(a,b)\n#define HLS_FPO_GREATERF(a,b)          xil_fpo_greater_flt(a,b)\n#define HLS_FPO_GREATER(a,b)           xil_fpo_greater_d(a,b)\n#define HLS_FPO_GREATEREQUALF(a,b)     xil_fpo_greaterequal_flt(a,b)\n#define HLS_FPO_GREATEREQUAL(a,b)      xil_fpo_greaterequal_d(a,b)\n#define HLS_FPO_NOTEQUALF(a,b)         xil_fpo_notequal_flt(a,b)\n#define HLS_FPO_NOTEQUAL(a,b)          xil_fpo_notequal_d(a,b)\n#define HLS_FPO_CONDCODEF(a,b)         xil_fpo_condcode_flt(a,b)\n#define HLS_FPO_CONDCODE(a,b)          xil_fpo_condcode_d(a,b)\n#define HLS_FPO_FTOI(a)                xil_fpo_flttofix_int_flt(a)\n#define HLS_FPO_DTOI(a)                xil_fpo_flttofix_int_d(a)        \n#define HLS_FPO_ITOF(a)                xil_fpo_fixtoflt_flt_int(a)      \n#define HLS_FPO_ITOD(a)                xil_fpo_fixtoflt_d_int(a)        \n#define HLS_FPO_FTOF(a)                xil_fpo_flttoflt_flt_flt(a)      \n#define HLS_FPO_DTOF(a)                xil_fpo_flttoflt_flt_d(a)        \n#define HLS_FPO_FTOD(a)                xil_fpo_flttoflt_d_flt(a)        \n#define HLS_FPO_DTOD(a)                xil_fpo_flttoflt_d_d(a)          \n\n\n#include \"floating_point_v7_0_bitacc_cmodel.h\"  // Must include before GMP and MPFR\n#include \"gmp.h\"\n#include \"mpfr.h\"\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: add\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_add_flt(float a, float b)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_add_flt\n  xip_fpo_add_flt(&res_flt, a, b);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_add_d(double a, double b)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_add_d\n  xip_fpo_add_d(&res_d, a, b);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: subtract\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_sub_flt(float a, float b)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_sub_flt\n  xip_fpo_sub_flt(&res_flt, a, b);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_sub_d(double a, double b)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_sub_d\n  xip_fpo_sub_d(&res_d, a, b);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: multiply\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_mul_flt(float a, float b)\n{\n  float res_flt = 0.0f;\n \n  // xip_fpo_mul_flt\n  xip_fpo_mul_flt(&res_flt, a, b);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_mul_d(double a, double b)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_mul_d\n  xip_fpo_mul_d(&res_d, a, b);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: divide\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_div_flt(float a, float b)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_div_flt\n  xip_fpo_div_flt(&res_flt, a, b);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_div_d(double a, double b)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_div_d\n  xip_fpo_div_d(&res_d, a, b);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: reciprocal\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_rec_flt(float a)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_rec_flt\n  xip_fpo_rec_flt(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_rec_d(double a)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_rec_d\n  xip_fpo_rec_d(&res_d, a);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: square root\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_sqrt_flt(float a)\n{\n//  printf(\"Testing operation functions: square root\\n\");\n  float res_flt = 0.0f;\n\n  // xip_fpo_sqrt_flt\n  xip_fpo_sqrt_flt(&res_flt, a);  // normal operation\n//  printf(\"float = sqrtf(a), and got res_flt=%f\\n\", res_flt);\n  return res_flt;\n}\n\ninline double xil_fpo_sqrt_d(double a)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_sqrt_d\n  xip_fpo_sqrt_d(&res_d, a);  // normal operation\n//  printf(\"double = sqrt(a), and got res_d=%f\\n\", res_d);\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: reciprocal square root\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_recsqrt_flt(float a)      \n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_recsqrt_flt\n  xip_fpo_recsqrt_flt(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_recsqrt_d(double a)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_recsqrt_d\n  xip_fpo_recsqrt_d(&res_d, a);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: absolute value\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_abs_flt(float a)\n{\n  float res_flt = 0.0f;\n\n  xip_fpo_abs_flt(&res_flt, a);\n  return res_flt;\n}\n\ninline double xil_fpo_abs_d(double a)\n{\n  double res_d = 0.0;\n\n  xip_fpo_abs_d(&res_d, a);\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: logarithm\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_log_flt(float a)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_log_flt\n  xip_fpo_log_flt(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_log_d(double a)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_log_d\n  xip_fpo_log_d(&res_d, a);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: Exponential\n  ////////////////////////////////////////////////////////////////////////\n\ninline float xil_fpo_exp_flt(float a)\n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_exp_flt\n  xip_fpo_exp_flt(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_exp_d(double a)\n{\n  double res_d = 0.0;\n\n  // xip_fpo_exp_d\n  xip_fpo_exp_d(&res_d, a);  // normal operation\n  return res_d;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare unordered\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_unordered_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_unordered_flt\n  xip_fpo_unordered_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_unordered_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_unordered_d\n  xip_fpo_unordered_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare equal\n  ////////////////////////////////////////////////////////////////////////\n\n\ninline int xil_fpo_equal_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_equal_flt\n  xip_fpo_equal_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_equal_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_equal_d\n  xip_fpo_equal_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare less than\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_less_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_less_flt\n  xip_fpo_less_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_less_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_less_d\n  xip_fpo_less_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare less than or equal\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_lessequal_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_lessequal_flt\n  xip_fpo_lessequal_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_lessequal_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_lessequal_d\n  xip_fpo_lessequal_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare greater than\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_greater_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_greater_flt\n  xip_fpo_greater_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_greater_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_greater_d\n  xip_fpo_greater_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare greater than or equal\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_greaterequal_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_greaterequal_flt\n  xip_fpo_greaterequal_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_greaterequal_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_greaterequal_d\n  xip_fpo_greaterequal_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare not equal\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_notequal_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_notequal_flt\n  xip_fpo_notequal_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_notequal_d(double a, double b)\n{\n  int res_int = 0;\n\n  xip_fpo_notequal_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Operation functions: compare condition code\n  ////////////////////////////////////////////////////////////////////////\n\ninline int xil_fpo_condcode_flt(float a, float b)\n{\n  int res_int = 0;\n\n  // xip_fpo_condcode_flt\n  xip_fpo_condcode_flt(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_condcode_d(double a, double b)\n{\n  int res_int = 0;\n\n  // xip_fpo_condcode_d\n  xip_fpo_condcode_d(&res_int, a, b);  // normal operation\n  return res_int;\n}\n\n  ////////////////////////////////////////////////////////////////////////\n  // Conversion functions: conversion code\n  ////////////////////////////////////////////////////////////////////////\ninline int xil_fpo_flttofix_int_flt(float a)\n{\n  int res_int = 0;\n\n  // xip_fpo_flttofix_int_flt\n  xip_fpo_flttofix_int_flt(&res_int, a);  // normal operation\n  return res_int;\n}\n\ninline int xil_fpo_flttofix_int_d(double a)        \n{\n  int res_int = 0;\n\n  // xip_fpo_flttofix_int_d\n  xip_fpo_flttofix_int_d(&res_int, a);  // normal operation\n  return res_int;\n}\n\ninline float xil_fpo_fixtoflt_flt_int(int a)      \n{\n  float res_flt = 0.0f;\n  \n  // xip_fpo_fixtoflt_flt_int\n  xip_fpo_fixtoflt_flt_int(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_fixtoflt_d_int(int a)        \n{\n  double res_d = 0.0;\n\n  // xip_fpo_fixtoflt_d_int\n  xip_fpo_fixtoflt_d_int(&res_d, a);  // normal operation\n  return res_d;\n}\n\ninline float xil_fpo_flttoflt_flt_flt(float a)      \n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_flttoflt_flt_flt\n  xip_fpo_flttoflt_flt_flt(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline float xil_fpo_flttoflt_flt_d(double a)        \n{\n  float res_flt = 0.0f;\n\n  // xip_fpo_flttoflt_flt_d\n  xip_fpo_flttoflt_flt_d(&res_flt, a);  // normal operation\n  return res_flt;\n}\n\ninline double xil_fpo_flttoflt_d_flt(float a)        \n{\n  double res_d = 0.0;\n\n  // xip_fpo_flttoflt_d_flt\n  xip_fpo_flttoflt_d_flt(&res_d, a);  // normal operation\n  return res_d;\n}\n\ninline double xil_fpo_flttoflt_d_d(double a)          \n{\n  double res_d = 0.0;\n\n  // xip_fpo_flttoflt_d_d\n  xip_fpo_flttoflt_d_d(&res_d, a);  // normal operation\n  return res_d;\n}\n\n#endif\n#endif /* #ifndef __AESL_FPO_H__*/\n\n\n"
  }
}